<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanban Board</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, get, update, onValue, push, remove } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAAOyqnAE-9lFAsni2_AoDXK0Y7Aekg-t4",
            authDomain: "ultra-kanban.firebaseapp.com",
            databaseURL: "https://ultra-kanban-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "ultra-kanban",
            storageBucket: "ultra-kanban.firebasestorage.app",
            messagingSenderId: "190342751802",
            appId: "1:190342751802:web:5eb977207734bd6f187703"
        };
        
        // Initialize Firebase
        window.firebaseApp = initializeApp(firebaseConfig);
        window.database = getDatabase(window.firebaseApp);
        window.firebaseRef = ref;
        window.firebaseSet = set;
        window.firebaseGet = get;
        window.firebaseUpdate = update;
        window.firebaseOnValue = onValue;
        window.firebasePush = push;
        window.firebaseRemove = remove;
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            color: #1f2937;
        }

        .sidebar {
            width: 250px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(229, 231, 235, 0.5);
            padding: 14px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .sidebar h2 {
            color: #1f2937;
            margin-bottom: 20px;
            font-size: 20px;
            font-family: 'Playfair Display', serif;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .project-list {
            flex: 1;
            overflow-y: auto;
            min-height: 200px;
        }

        .project-item {
            background: #ffffff !important;
            border-radius: 6px;
            padding: 4px 7px;
            margin-bottom: 3px;
            cursor: grab;
            transition: all 0.3s ease;
            color: #000000 !important;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            text-transform: uppercase !important;
            font-weight: 700 !important;
            letter-spacing: -0.2px;
            font-size: 11px !important;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif !important;
            text-shadow: none !important;
            -webkit-text-fill-color: #000000 !important;
            opacity: 1 !important;
            font-stretch: normal;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .project-item:active {
            cursor: grabbing;
        }

        .project-item.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .project-item.drag-over {
            border-top: 3px solid #3b82f6;
        }

        .project-item:hover {
            background: #f9fafb;
            border-color: #d1d5db;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            color: #111827;
        }

        .project-item.active {
            background: #3b82f6 !important;
            border-color: #2563eb !important;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4) !important;
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
            font-weight: 900 !important;
            transform: scale(1.02);
        }

        .add-project {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            color: #374151;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            margin-top: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .add-project:hover {
            background: #f9fafb;
            border-color: #d1d5db;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .main-content {
            flex: 1;
            padding: 5px 15px;
            display: flex;
            flex-direction: column;
            min-width: 0;
            width: 100%;
            height: 100vh;
            box-sizing: border-box;
            overflow-x: auto;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin: 10px;
            border-radius: 16px;
        }

        .header {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            gap: 20px;
        }

        .workspace-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .workspace-dropdown {
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            font-size: 16px;
            min-width: 180px;
            cursor: pointer;
        }

        .workspace-btn {
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .workspace-btn:hover {
            background: #2563eb;
        }

        .board-title {
            font-size: 28px;
            font-weight: bold;
            color: #1f2937;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            padding: 8px 0;
            margin-right: 15px;
            min-width: 200px;
            outline: none;
        }

        .board-title:hover:not(:disabled),
        .board-title:focus:not(:disabled) {
            border-bottom-color: rgba(31, 41, 55, 0.5);
        }

        .board-title:disabled {
            background-color: #f9fafb !important;
            color: #6b7280 !important;
            cursor: default !important;
            border-bottom-color: #e5e7eb !important;
            opacity: 1 !important; /* Override default disabled opacity */
        }

        .project-info {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            margin-left: auto;
        }
        
        .user-info-bottom {
            position: sticky;
            bottom: 0;
            z-index: 100;
        }
        
        .user-info-bottom button:hover {
            background: #dc2626 !important;
            transform: translateY(-1px);
        }

        .kanban-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            flex: 1;
            width: 100%;
            margin: 0;
            align-items: stretch;
            justify-content: start;
            padding: 0 15px;
            box-sizing: border-box;
            height: 100%;
            min-width: 900px;
        }

        .column {
            background: #ffffff;
            border-radius: 12px;
            padding: 24px;
            height: 100%;
            width: 100%;
            border: 1px solid #e5e7eb;
            position: relative;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .column.todo {
            background: linear-gradient(to bottom, #ffffff 0%, #eff6ff 100%);
            border-left: 4px solid #3b82f6;
        }

        .column.doing {
            background: linear-gradient(to bottom, #ffffff 0%, #fef2f2 100%);
            border-left: 4px solid #ef4444;
        }

        .column.done {
            background: linear-gradient(to bottom, #ffffff 0%, #f3f4f6 100%);
            border-left: 4px solid #8b5cf6;
        }


        .column-header {
            font-size: 16px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 20px;
            text-align: left;
            padding: 0;
            background: transparent;
            position: relative;
        }

        .column.todo .column-header {
            color: #1d4ed8;
        }

        .column.doing .column-header {
            color: #dc2626;
        }

        .column.done .column-header {
            color: #7c3aed;
        }

        .sorting-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
        }

        .sort-btn {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 4px 8px;
            color: #374151;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .sort-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        .sort-btn.active {
            background: #f3f4f6;
            border-color: #6b7280;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .project-sorting {
            margin-top: 10px;
            padding: 8px;
            background: #ffffff;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .project-sorting select {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 4px 8px;
            color: #374151;
            font-size: 12px;
            outline: none;
        }

        .project-sorting select option {
            background: #ffffff;
            color: #374151;
        }


        .task-list {
            min-height: 300px;
            padding: 10px 0;
            flex: 1;
            width: 100%;
        }

        .task-item {
            background: #ffffff;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: move;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08), 0 1px 2px rgba(0, 0, 0, 0.04);
            user-select: none;
            border: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
            min-height: 40px;
        }

        .task-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12), 0 2px 4px rgba(0, 0, 0, 0.08);
        }

        .task-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .task-content {
            flex: 1;
            background: transparent;
            border: none;
            font-size: 14px;
            line-height: 1.4;
            outline: none;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 6px;
            transition: all 0.2s ease;
            min-height: 22px;
            color: #374151;
            font-weight: 400;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            word-break: break-word;
            max-height: 2.8em;
        }

        .task-content:hover {
            overflow: visible;
            display: block;
            max-height: none;
            -webkit-line-clamp: none;
            background: rgba(0, 0, 0, 0.03);
            z-index: 10;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            white-space: pre-wrap;
        }

        .task-content a {
            color: #3b82f6;
            text-decoration: underline;
            cursor: pointer;
        }

        .task-content a:hover {
            color: #1d4ed8;
            text-decoration: none;
        }


        .task-content:focus {
            background: #f3f4f6;
            cursor: text;
            border: 1px solid #3b82f6;
        }

        .task-item-wrapper {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            width: 100%;
        }

        .task-item.reordering {
            opacity: 0.3;
            transform: scale(0.95);
        }

        .task-list.drag-over-reorder {
            background: rgba(33, 150, 243, 0.1);
            border: 2px dashed rgba(33, 150, 243, 0.5);
        }

        .drop-indicator {
            height: 3px;
            background: #007bff;
            margin: 2px 0;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .drop-indicator.active {
            opacity: 1;
        }

        .task-content.copied {
            background: #dcfce7;
            transform: scale(1.02);
        }

        .copy-feedback {
            position: absolute;
            background: #16a34a;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }

        .copy-feedback.show {
            opacity: 1;
            transform: translateY(-20px);
        }

        .task-checkbox {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            cursor: pointer;
            accent-color: #007bff;
        }

        .task-item.selected {
            background: rgba(33, 150, 243, 0.1);
            border: 2px solid rgba(33, 150, 243, 0.5);
        }

        .multi-select-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px 20px;
            display: none;
            gap: 10px;
            align-items: center;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .multi-select-controls.show {
            display: flex;
        }

        .multi-select-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            margin: 0 2px;
        }

        .multi-select-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .multi-select-btn.danger {
            background: rgba(244, 67, 54, 0.8);
            border-color: rgba(244, 67, 54, 1);
        }

        .multi-select-btn.danger:hover {
            background: rgba(244, 67, 54, 1);
        }

        .multi-select-info {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            margin-right: 10px;
        }

        .column-header {
            position: relative;
        }

        .select-all-checkbox {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: white;
        }

        .column.drag-over {
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .todo-column.drag-over {
            background: linear-gradient(to bottom,
                rgba(244, 67, 54, 0.25) 0%,
                rgba(255, 152, 0, 0.2) 100%);
        }

        .doing-column.drag-over {
            background: linear-gradient(to bottom,
                rgba(255, 193, 7, 0.25) 0%,
                rgba(255, 235, 59, 0.2) 100%);
        }

        .done-column.drag-over {
            background: linear-gradient(to bottom,
                rgba(76, 175, 80, 0.25) 0%,
                rgba(139, 195, 74, 0.2) 100%);
        }

        .add-task {
            background: transparent;
            border: 2px dashed #d1d5db;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            cursor: pointer;
            color: #6b7280;
            transition: all 0.2s ease;
            margin-top: 12px;
            font-size: 14px;
            font-weight: 500;
        }

        .add-task:hover {
            background: #f9fafb;
            border-color: #9ca3af;
            color: #374151;
        }

        .task-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: #ffffff;
            margin-bottom: 10px;
            outline: none;
            color: #374151;
            font-size: 14px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .task-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn:hover {
            transform: translateY(-1px);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        .modal input {
            width: 100%;
            padding: 12px;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
        }

        .delete-task {
            background: transparent;
            border: none;
            border-radius: 6px;
            padding: 4px 6px;
            color: #9ca3af;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            opacity: 0;
        }

        .task-item:hover .delete-task {
            opacity: 1;
        }

        .delete-task:hover {
            background: #fef2f2;
            color: #ef4444;
        }

        .project-name {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            font-size: 14px;
            outline: none;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 4px;
            transition: all 0.3s ease;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .project-name:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .project-name:focus {
            background: rgba(255, 255, 255, 0.2);
            cursor: text;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .project-item-content {
            display: flex;
            align-items: center;
            gap: 4px;
            justify-content: space-between;
            width: 100%;
        }

        .project-context-menu {
            position: fixed;
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            padding: 4px 0;
            z-index: 1000;
            display: none;
            min-width: 150px;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #374151;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #f3f4f6;
        }

        .context-menu-item.duplicate {
            color: #059669;
        }

        .context-menu-item.delete {
            color: #dc2626;
        }

        .context-menu-item.delete:hover {
            background: #fef2f2;
        }

        .trash-item {
            background: #fef2f2;
            border-radius: 6px;
            padding: 6px;
            margin-bottom: 3px;
            font-size: 11px;
            color: #6b7280;
            border: 1px solid #fca5a5;
            cursor: pointer;
        }

        .trash-item:hover {
            background: #fee2e2;
            color: #dc2626;
        }

        .trash-item-name {
            font-weight: 600;
            color: #dc2626;
        }


        .task-count {
            background: #9ca3af !important;
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
            border-radius: 12px;
            padding: 3px 7px;
            font-size: 11px;
            font-weight: 900;
            min-width: 20px;
            text-align: center;
            margin-left: auto;
            flex-shrink: 0;
            display: inline-block;
            line-height: 1.2;
            border: 2px solid rgba(0, 0, 0, 0.3);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .task-count.zero {
            background: #fca5a5 !important;
            color: white !important;
        }

        .backup-controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e5e7eb;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }

        .backup-btn {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 8px 6px;
            color: #374151;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 4px;
            min-height: 32px;
            text-align: center;
            font-weight: 500;
        }

        .backup-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        .backup-status {
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            margin-top: 5px;
            text-align: center;
        }

        .import-input {
            display: none;
        }

        .password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
        }

        .password-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .password-container h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 24px;
        }

        .password-container p {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .password-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 20px;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .password-input:focus {
            border-color: #667eea;
        }

        .password-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            padding: 15px 30px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .password-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }

        .password-error {
            color: #e74c3c;
            margin-top: 15px;
            font-size: 14px;
            display: none;
        }

        .password-setup {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .password-setup h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .app-content {
            display: none;
            height: 100vh;
            overflow: hidden;
        }

        .app-content.unlocked {
            display: flex;
            height: 100vh;
        }

        @media (max-width: 1200px) {
            .kanban-board {
                grid-template-columns: repeat(3, 1fr);
                gap: 16px;
                padding: 0 12px;
            }
        }

        @media (max-width: 968px) {
            .kanban-board {
                grid-template-columns: repeat(3, 1fr);
                gap: 12px;
            }
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: auto;
                max-height: 200px;
                overflow-y: auto;
                border-right: none;
                border-bottom: 1px solid rgba(229, 231, 235, 0.5);
                padding: 10px;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
            }

            .project-list {
                display: flex;
                flex-direction: column;
                gap: 6px;
                min-height: auto;
                max-height: 180px;
                overflow-y: auto;
            }

            .project-item {
                font-size: 12px !important;
                padding: 6px 8px;
                margin-bottom: 0;
                text-align: center;
            }

            .task-count {
                font-size: 9px;
                padding: 2px 4px;
                min-width: 16px;
            }

            .kanban-board {
                grid-template-columns: 1fr;
                gap: 16px;
                padding: 0 12px;
                min-width: auto;
            }

            .column {
                min-height: 300px;
            }

            .main-content {
                padding: 10px;
                height: calc(100vh - 200px);
                margin: 5px;
                border-radius: 12px;
            }

            .header {
                margin-bottom: 10px;
            }
            
            .header-top {
                margin-bottom: 10px !important;
            }
            
            .header-bottom {
                flex-direction: column !important;
                gap: 10px;
                text-align: center;
            }

            .workspace-selector {
                width: 100%;
            }

            .workspace-dropdown {
                width: 100%;
            }

            .board-title {
                font-size: 16px;
                padding: 8px;
            }

            .add-project {
                font-size: 12px;
                padding: 8px;
            }

            .backup-controls {
                margin-top: 8px;
                padding-top: 8px;
            }

            .backup-btn {
                font-size: 11px;
                padding: 6px 8px;
            }
        }

        @media (max-width: 480px) {
            .sidebar {
                max-height: 150px;
                padding: 8px;
            }

            .project-list {
                display: flex;
                flex-direction: column;
                gap: 4px;
                max-height: 140px;
            }

            .project-item {
                font-size: 11px !important;
                padding: 5px 6px;
            }

            .task-count {
                font-size: 8px;
                padding: 1px 3px;
                min-width: 14px;
            }

            .main-content {
                padding: 8px;
                height: calc(100vh - 150px);
                margin: 3px;
                border-radius: 8px;
            }

            .column {
                min-height: 250px;
            }

            .column h3 {
                font-size: 14px;
                padding: 8px;
            }

            .task {
                font-size: 12px;
                padding: 12px;
                min-height: 44px;
                touch-action: pan-y;
            }

            .task-actions {
                gap: 12px;
            }

            .task-action {
                min-width: 44px;
                min-height: 44px;
                padding: 8px;
                font-size: 14px;
            }

            .board-title {
                font-size: 14px;
                padding: 6px;
            }

            .header {
                gap: 8px;
                margin-bottom: 8px;
            }
        }
    </style>
</head>
<body>
    <!-- Password Protection Overlay -->
    <div class="password-overlay" id="passwordOverlay">
        <div class="password-container">
            <h1>üîí Ultra Kanban</h1>
            <p id="authFormDescription">Accede a tu cuenta personal</p>

            <!-- User Login Form -->
            <div id="userLoginForm">
                <input type="email" class="password-input" id="emailInput" placeholder="Email" autocomplete="email" required>
                <input type="password" class="password-input" id="userPasswordInput" placeholder="Contrase√±a" autocomplete="current-password" required>
                <button class="password-btn" onclick="handleUserLogin()">Iniciar Sesi√≥n</button>
                <div class="password-error" id="userLoginError"></div>
                <div style="margin-top: 15px; text-align: center;">
                    <a href="#" onclick="showRegisterForm()" style="color: #667eea; text-decoration: none; font-size: 14px;">¬øNo tienes cuenta? Reg√≠strate</a>
                </div>
                <div style="margin-top: 10px; text-align: center;">
                    <a href="#" onclick="showLegacyLogin()" style="color: #888; text-decoration: none; font-size: 12px;">Modo compatibilidad (contrase√±a simple)</a>
                </div>
            </div>

            <!-- User Registration Form -->
            <div id="userRegisterForm" style="display: none;">
                <input type="email" class="password-input" id="registerEmail" placeholder="Email" autocomplete="email" required>
                <input type="password" class="password-input" id="registerPassword" placeholder="Contrase√±a" autocomplete="new-password" required>
                <input type="password" class="password-input" id="registerConfirmPassword" placeholder="Confirmar contrase√±a" autocomplete="new-password" required>
                <button class="password-btn" onclick="handleUserRegister()">Registrarse</button>
                <div class="password-error" id="userRegisterError"></div>
                <div style="margin-top: 15px; text-align: center;">
                    <a href="#" onclick="showLoginForm()" style="color: #667eea; text-decoration: none; font-size: 14px;">¬øYa tienes cuenta? Inicia sesi√≥n</a>
                </div>
            </div>

            <!-- Legacy Login Form (Original System) -->
            <div id="legacyLoginForm" style="display: none;">
                <div id="loginForm">
                    <input type="password" class="password-input" id="passwordInput" placeholder="Contrase√±a" autocomplete="current-password">
                    <button class="password-btn" onclick="checkPassword()">Ingresar</button>
                    <div class="password-error" id="passwordError">Contrase√±a incorrecta</div>
                </div>

                <div class="password-setup" id="setupForm" style="display: none;">
                    <h3>Configurar Contrase√±a</h3>
                    <p>Es la primera vez que accedes. Establece una contrase√±a:</p>
                    <input type="password" class="password-input" id="newPasswordInput" placeholder="Nueva contrase√±a" autocomplete="new-password">
                    <input type="password" class="password-input" id="confirmPasswordInput" placeholder="Confirmar contrase√±a" autocomplete="new-password">
                    <button class="password-btn" onclick="setupPassword()">Establecer Contrase√±a</button>
                    <div class="password-error" id="setupError">Las contrase√±as no coinciden</div>
                </div>
                
                <div style="margin-top: 15px; text-align: center;">
                    <a href="#" onclick="showLoginForm()" style="color: #667eea; text-decoration: none; font-size: 14px;">‚Üê Volver al login con email</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Application Content -->
    <div class="app-content" id="appContent">
        <div class="sidebar">
        <h2>Ultra Kanban</h2>
        <div class="project-list" id="projectList">
            <div class="project-item active" data-project="default">
                Default Board
            </div>
        </div>
        <button class="add-project" onclick="createProject()">+ Add Board</button>

        <div class="trash-section" id="trashSection" style="display: none;">
            <h3 style="color: #6b7280; font-size: 12px; margin: 10px 0 5px 0; text-transform: uppercase;">Trash</h3>
            <div class="trash-list" id="trashList"></div>
            <button class="empty-trash-btn" onclick="emptyTrash()" style="background: #fef2f2; border: 1px solid #fca5a5; color: #dc2626; padding: 6px 12px; border-radius: 6px; font-size: 11px; width: 100%; margin-top: 5px;">Empty Trash</button>
        </div>

        <div class="backup-controls">
            <button class="backup-btn" onclick="exportData()">
                <span style="font-size: 12px;">üì•</span>
                Export
            </button>
            <button class="backup-btn" onclick="document.getElementById('importInput').click()">
                <span style="font-size: 12px;">üì§</span>
                Import
            </button>
            <button class="backup-btn" onclick="document.getElementById('tasksImportInput').click()">
                <span style="font-size: 12px;">üìù</span>
                Tasks
            </button>
            <button class="backup-btn" onclick="toggleTrash()">
                <span style="font-size: 12px;">üóëÔ∏è</span>
                Trash
            </button>
            <button class="backup-btn" onclick="createBackup()">
                <span style="font-size: 12px;">üíæ</span>
                Backup
            </button>
            <div class="backup-status" id="backupStatus" style="grid-column: 1 / -1; text-align: center; margin-top: 4px; color: #6b7280; font-size: 9px;">Auto-saving...</div>
            <input type="file" id="importInput" class="import-input" accept=".json" onchange="importData(event)">
            <input type="file" id="tasksImportInput" class="import-input" accept=".txt,.md" onchange="importTasksFromFile(event)">
            <button class="backup-btn" onclick="lockApp()" style="background: #fef2f2; border-color: #fca5a5; color: #dc2626; grid-column: 1 / -1; margin-top: 4px;">
                <span style="font-size: 12px;">üîí</span>
                Logout
            </button>
        </div>
    </div>

    <div class="main-content">
        <div class="header">
            <div class="header-top" style="display: flex; justify-content: center; align-items: center; margin-bottom: 10px;">
                <div class="workspace-selector">
                    <select id="workspaceSelect" class="workspace-dropdown" style="font-size: 16px; font-weight: 600; min-width: 200px; text-align: center; background: rgba(255,255,255,0.9); border: 1px solid #d1d5db;">
                        <option value="personal">üìÅ Main Workspace</option>
                    </select>
                    <button class="workspace-btn" onclick="showWorkspaceModal()">+</button>
                </div>
            </div>
            <div class="header-bottom" style="display: flex; justify-content: space-between; align-items: center;">
                <input type="text" class="board-title" id="boardTitle" value="" placeholder="Enter board title...">
                <div class="project-info">
                    Board: <span id="currentProject">Default Board</span>
                </div>
            </div>
        </div>

        <div class="kanban-board">
            <div class="column todo" data-column="todo">
                <div class="column-header">TO DO</div>
                <div class="task-list" id="todoList"></div>
                <div class="add-task" onclick="showAddTaskModal('todo')">+ Add Task</div>
            </div>

            <div class="column doing" data-column="doing">
                <div class="column-header">DOING</div>
                <div class="task-list" id="doingList"></div>
            </div>

            <div class="column done" data-column="done">
                <div class="column-header">DONE</div>
                <div class="task-list" id="doneList"></div>
            </div>
        </div>
    </div>

    <!-- Context Menu for Projects -->
    <div class="project-context-menu" id="projectContextMenu">
        <div class="context-menu-item duplicate" onclick="duplicateProjectFromMenu()">
            <span>üìÑ</span> Duplicate Project
        </div>
        <div class="context-menu-item delete" onclick="deleteProjectFromMenu()">
            <span>üóëÔ∏è</span> Move to Trash
        </div>
    </div>

    <!-- Context Menu for Trash Items -->
    <div class="project-context-menu" id="trashContextMenu">
        <div class="context-menu-item" onclick="restoreProjectFromMenu()">
            <span>‚Ü©Ô∏è</span> Restore Project
        </div>
        <div class="context-menu-item delete" onclick="permanentDeleteFromMenu()">
            <span>‚ùå</span> Delete Permanently
        </div>
    </div>

    <!-- Workspace Management Modal -->
    <div class="modal" id="workspaceModal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <h2 style="margin-bottom: 20px;">üè¢ Workspace Management</h2>
            
            <div style="margin-bottom: 20px;">
                <h3>Create New Workspace</h3>
                <input type="text" id="newWorkspaceName" placeholder="Workspace name (e.g., Team Alpha, My Projects, Travel Plans)" style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 6px;">
                <div style="font-size: 12px; color: #666; margin-bottom: 10px;">üí° Tip: Use descriptive names like "Work Boards", "Family Tasks", or "Travel Planning" for smart emoji detection</div>
                <button onclick="createWorkspace()" style="background: #10b981; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer;">Create Workspace</button>
            </div>
            
            <div style="margin-bottom: 20px; border-top: 1px solid #eee; padding-top: 20px;">
                <h3>Manage Existing Workspaces</h3>
                <div id="workspaceListContainer" style="margin: 10px 0;">
                    <!-- Workspace list will be populated here -->
                </div>
                <button onclick="refreshWorkspaceList()" style="background: #6b7280; color: white; padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">üîÑ Refresh List</button>
            </div>
            
            <button onclick="closeWorkspaceModal()" style="background: #6b7280; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; float: right;">Close</button>
        </div>
    </div>

    <div class="modal" id="taskModal">
        <div class="modal-content">
            <h3>Add New Task</h3>
            <input type="text" id="taskInput" placeholder="Enter task description...">
            <div class="task-actions">
                <button class="btn btn-primary" onclick="addTask()">Add Task</button>
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="projectModal">
        <div class="modal-content">
            <h3>Create New Board</h3>
            <input type="text" id="projectInput" placeholder="Enter board name...">
            <div class="task-actions">
                <button class="btn btn-primary" onclick="addProject()">Create Board</button>
                <button class="btn btn-secondary" onclick="closeProjectModal()">Cancel</button>
            </div>
        </div>
    </div>
    </div> <!-- Close app-content -->

    <script>
        let currentProject = 'default';
        let currentColumn = '';
        let draggedTask = null;

        // Data version for migration support
        const DATA_VERSION = '1.1.0';
        const BACKUP_PREFIX = 'kanban_backup_';
        const MAX_BACKUPS = 10;

        let projects = {
            'default': {
                name: 'Default Project',
                title: 'My Kanban Board',
                sortingMode: 'free', // free, alphabetical, newest-first, oldest-first
                tasks: {
                    todo: [],
                    doing: [],
                    done: []
                },
                taskMetadata: {
                    todo: [],
                    doing: [],
                    done: []
                }
            }
        };

        // Project trash for recovery
        let projectTrash = [];

        // Firebase Storage Management System
        class FirebaseStorageManager {
            constructor() {
                this.userId = 'user_' + this.generateUserId(); // Simple user ID for demo
                this.workspaceId = 'personal'; // Default workspace
                this.isOnline = navigator.onLine;
                this.initializeOfflineSupport();
            }

            generateUserId() {
                // Check URL for shared user ID first
                const urlParams = new URLSearchParams(window.location.search);
                const sharedUserId = urlParams.get('user');
                
                if (sharedUserId) {
                    // Clean the user ID - remove extra "user_" prefix if present
                    const cleanUserId = sharedUserId.startsWith('user_user_') ? 
                        sharedUserId.substring(5) : sharedUserId;
                    localStorage.setItem('kanbanUserId', cleanUserId);
                    return cleanUserId;
                }
                
                // Check localStorage
                let userId = localStorage.getItem('kanbanUserId');
                if (!userId) {
                    // Generate new user ID
                    userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('kanbanUserId', userId);
                    
                    // Show sharing info
                    this.showSharingInfo(userId);
                }
                
                // Clean any existing double prefix
                if (userId.startsWith('user_user_')) {
                    userId = userId.substring(5);
                    localStorage.setItem('kanbanUserId', userId);
                }
                
                return userId;
            }
            
            showSharingInfo(userId) {
                const shareUrl = window.location.origin + window.location.pathname + '?user=' + userId;
                console.log('üîó Share this URL to sync across devices:', shareUrl);
                
                // Show notification with share URL
                setTimeout(() => {
                    const notification = document.createElement('div');
                    notification.innerHTML = `
                        üîó <strong>Share URL:</strong><br>
                        <input type="text" value="${shareUrl}" readonly style="width: 100%; margin-top: 5px; padding: 5px; font-size: 10px; border: 1px solid #ccc; border-radius: 4px;" onclick="this.select()">
                        <br><small>Copy this URL to sync the same data on other devices</small>
                    `;
                    notification.style.cssText = `
                        position: fixed;
                        top: 70px;
                        right: 20px;
                        background: #3b82f6;
                        color: white;
                        padding: 15px;
                        border-radius: 8px;
                        font-size: 12px;
                        z-index: 10000;
                        max-width: 300px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    `;
                    
                    document.body.appendChild(notification);
                    
                    // Auto-hide after 10 seconds
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 10000);
                }, 2000);
            }

            initializeOfflineSupport() {
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    this.syncOfflineChanges();
                });
                window.addEventListener('offline', () => {
                    this.isOnline = false;
                });
            }

            async save() {
                const data = {
                    version: '1.0.0',
                    projects: projects,
                    currentProject: currentProject,
                    projectTrash: projectTrash || [],
                    timestamp: new Date().toISOString()
                };

                const success = { firebase: false, localStorage: false };

                // Always save to localStorage as backup (workspace-specific keys)
                try {
                    localStorage.setItem(`kanbanProjects_${this.workspaceId}`, JSON.stringify(data.projects));
                    localStorage.setItem(`currentProject_${this.workspaceId}`, data.currentProject);
                    localStorage.setItem(`kanbanVersion_${this.workspaceId}`, data.version);
                    localStorage.setItem(`projectTrash_${this.workspaceId}`, JSON.stringify(data.projectTrash));
                    success.localStorage = true;
                } catch (error) {
                    console.error('localStorage save failed:', error);
                }

                // Save to Firebase if online
                if (this.isOnline && window.database) {
                    try {
                        const workspaceRef = window.firebaseRef(window.database, `workspaces/${this.workspaceId}/data`);
                        await window.firebaseSet(workspaceRef, data);
                        success.firebase = true;
                        console.log(`Data saved to Firebase workspace: ${this.workspaceId}`);
                    } catch (error) {
                        console.error('Firebase save failed:', error);
                        // Mark for offline sync
                        localStorage.setItem('kanbanPendingSync', 'true');
                    }
                }

                this.updateBackupStatus(success);
                return success;
            }

            async load() {
                let data = null;

                // Try to load from Firebase first if online
                if (this.isOnline && window.database) {
                    try {
                        const workspaceRef = window.firebaseRef(window.database, `workspaces/${this.workspaceId}/data`);
                        const snapshot = await window.firebaseGet(workspaceRef);
                        if (snapshot.exists()) {
                            data = snapshot.val();
                            console.log(`Data loaded from Firebase workspace: ${this.workspaceId}`);
                            
                            // Setup real-time listener
                            this.setupRealtimeListener();
                        }
                    } catch (error) {
                        console.error('Firebase load failed:', error);
                    }
                }

                // Fallback to localStorage (workspace-specific keys)
                if (!data) {
                    try {
                        const savedProjects = localStorage.getItem(`kanbanProjects_${this.workspaceId}`);
                        const savedCurrentProject = localStorage.getItem(`currentProject_${this.workspaceId}`);
                        const savedVersion = localStorage.getItem(`kanbanVersion_${this.workspaceId}`);
                        const savedTrash = localStorage.getItem(`projectTrash_${this.workspaceId}`);

                        if (savedProjects) {
                            data = {
                                version: savedVersion || '1.0.0',
                                projects: JSON.parse(savedProjects),
                                currentProject: savedCurrentProject || 'default',
                                projectTrash: savedTrash ? JSON.parse(savedTrash) : [],
                                timestamp: new Date().toISOString()
                            };
                            console.log('Data loaded from localStorage');
                        }
                    } catch (error) {
                        console.error('localStorage load failed:', error);
                        data = null;
                    }
                }

                return data;
            }

            setupRealtimeListener() {
                if (!window.database) return;

                const workspaceRef = window.firebaseRef(window.database, `workspaces/${this.workspaceId}/data`);
                window.firebaseOnValue(workspaceRef, (snapshot) => {
                    if (snapshot.exists()) {
                        const data = snapshot.val();
                        // Only update if the data is newer
                        const localTimestamp = localStorage.getItem('lastSyncTimestamp') || '0';
                        if (data.timestamp > localTimestamp) {
                            const previousProject = currentProject;
                            projects = data.projects;
                            projectTrash = data.projectTrash || [];
                            
                            // Ensure all projects have proper structure
                            Object.keys(projects).forEach(projectId => {
                                projects[projectId] = ensureProjectStructure(projects[projectId]);
                            });
                            
                            // Update UI but keep current project active
                            renderProjects();
                            renderKanbanBoard();
                            
                            localStorage.setItem('lastSyncTimestamp', data.timestamp);
                            console.log('Real-time update received from Firebase');
                            
                            // Show sync notification
                            this.showSyncNotification('Data synced from cloud');
                        }
                    }
                });
            }

            async syncOfflineChanges() {
                const hasPendingSync = localStorage.getItem('kanbanPendingSync');
                if (hasPendingSync && window.database) {
                    try {
                        await this.save();
                        localStorage.removeItem('kanbanPendingSync');
                        this.showSyncNotification('Offline changes synced');
                    } catch (error) {
                        console.error('Failed to sync offline changes:', error);
                    }
                }
            }

            showSyncNotification(message) {
                const notification = document.createElement('div');
                notification.textContent = `üîÑ ${message}`;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #3b82f6;
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-size: 14px;
                    z-index: 10000;
                    opacity: 0;
                    transform: translateY(-10px);
                    transition: all 0.3s ease;
                `;
                
                document.body.appendChild(notification);
                
                // Animate in
                setTimeout(() => {
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateY(0)';
                }, 100);
                
                // Remove after 3 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateY(-10px)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }

            updateBackupStatus(success) {
                const statusEl = document.getElementById('backupStatus');
                if (!statusEl) return;

                const now = new Date().toLocaleTimeString();

                if (success.firebase && success.localStorage) {
                    statusEl.textContent = `‚òÅÔ∏è Synced at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.firebase) {
                    statusEl.textContent = `‚òÅÔ∏è Cloud saved at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.localStorage) {
                    statusEl.textContent = `üíæ Local saved at ${now}`;
                    statusEl.style.color = 'rgba(255, 193, 7, 0.8)';
                } else {
                    statusEl.textContent = `‚ùå Save failed at ${now}`;
                    statusEl.style.color = 'rgba(244, 67, 54, 0.8)';
                }

                setTimeout(() => {
                    if (this.isOnline) {
                        statusEl.textContent = '‚òÅÔ∏è Auto-syncing...';
                    } else {
                        statusEl.textContent = 'üíæ Offline mode...';
                    }
                    statusEl.style.color = 'rgba(255, 255, 255, 0.7)';
                }, 3000);
            }

            // Export data to JSON file
            exportData() {
                const data = {
                    version: '1.0.0',
                    projects: projects,
                    currentProject: currentProject,
                    projectTrash: projectTrash || [],
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ultra-kanban-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.updateBackupStatus({ export: true, import: false });
            }

            // Import data from JSON file
            async importData(file) {
                try {
                    const text = await file.text();
                    const importedData = JSON.parse(text);

                    if (!this.validateData(importedData)) {
                        throw new Error('Invalid data format');
                    }

                    // Update global variables
                    projects = importedData.projects;
                    currentProject = importedData.currentProject;
                    projectTrash = importedData.projectTrash || [];

                    // Ensure all projects have proper structure
                    Object.keys(projects).forEach(projectId => {
                        projects[projectId] = ensureProjectStructure(projects[projectId]);
                    });

                    // Save to Firebase and localStorage
                    await this.save();

                    // Update UI
                    renderProjects();
                    renderTasks();
                    // Only render trash if currently visible
                    if (trashVisible) renderTrash();
                    switchProject(currentProject);

                    this.updateBackupStatus({ export: false, import: true });
                    this.showSyncNotification('Data imported successfully');

                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Import failed: ' + error.message);
                }
            }

            // Validate imported data structure
            validateData(data) {
                if (!data || typeof data !== 'object') return false;
                if (!data.version || !data.projects || !data.currentProject) return false;

                for (const [projectId, project] of Object.entries(data.projects)) {
                    if (!project.name || !project.title) return false;
                    // Don't require tasks structure as we can fix it with ensureProjectStructure
                }

                return true;
            }
        }

        // Legacy Storage Manager (keeping for backward compatibility)
        class StorageManager {
            constructor(workspaceId = 'personal') {
                this.workspaceId = workspaceId;
                this.storageKey = `kanbanProjects_${workspaceId}`;
                this.currentProjectKey = `currentProject_${workspaceId}`;
                this.versionKey = `kanbanVersion_${workspaceId}`;
                this.lastBackupKey = `lastBackup_${workspaceId}`;
                this.initIndexedDB();
            }

            // Initialize IndexedDB for robust storage
            async initIndexedDB() {
                try {
                    this.db = await new Promise((resolve, reject) => {
                        const request = indexedDB.open('UltraKanbanDB', 1);
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(request.result);
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('projects')) {
                                db.createObjectStore('projects', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('backups')) {
                                const backupStore = db.createObjectStore('backups', { keyPath: 'id' });
                                backupStore.createIndex('timestamp', 'timestamp', { unique: false });
                            }
                        };
                    });
                } catch (error) {
                    console.warn('IndexedDB not available, using localStorage only:', error);
                }
            }

            // Validate data integrity
            validateData(data) {
                if (!data || typeof data !== 'object') return false;
                if (!data.version || !data.projects || !data.currentProject) return false;

                for (const [projectId, project] of Object.entries(data.projects)) {
                    if (!project.name || !project.title || !project.tasks) return false;
                    if (!project.tasks.todo || !project.tasks.doing || !project.tasks.done) return false;
                    if (!Array.isArray(project.tasks.todo) || !Array.isArray(project.tasks.doing) || !Array.isArray(project.tasks.done)) return false;
                }
                return true;
            }

            // Create timestamped data package
            createDataPackage() {
                return {
                    version: DATA_VERSION,
                    timestamp: new Date().toISOString(),
                    projects: structuredClone(projects),
                    currentProject: currentProject,
                    projectTrash: structuredClone(projectTrash),
                    metadata: {
                        totalProjects: Object.keys(projects).length,
                        totalTasks: Object.values(projects).reduce((sum, p) =>
                            sum + p.tasks.todo.length + p.tasks.doing.length + p.tasks.done.length, 0),
                        trashedProjects: projectTrash.length
                    }
                };
            }

            // Save to multiple storage backends
            async save() {
                const data = this.createDataPackage();
                const success = { localStorage: false, indexedDB: false };

                // Save to localStorage
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(data.projects));
                    localStorage.setItem(this.currentProjectKey, data.currentProject);
                    localStorage.setItem(this.versionKey, data.version);
                    localStorage.setItem(this.lastBackupKey, data.timestamp);
                    success.localStorage = true;
                } catch (error) {
                    console.error('localStorage save failed:', error);
                }

                // Save to IndexedDB
                if (this.db) {
                    try {
                        const transaction = this.db.transaction(['projects'], 'readwrite');
                        const store = transaction.objectStore('projects');
                        await store.put({ id: 'main', data: data });
                        success.indexedDB = true;
                    } catch (error) {
                        console.error('IndexedDB save failed:', error);
                    }
                }

                this.updateBackupStatus(success);
                return success;
            }

            // Load from storage with fallback
            async load() {
                let data = null;

                // Try IndexedDB first
                if (this.db) {
                    try {
                        const transaction = this.db.transaction(['projects'], 'readonly');
                        const store = transaction.objectStore('projects');
                        const result = await store.get('main');
                        if (result && result.data && this.validateData(result.data)) {
                            data = result.data;
                        }
                    } catch (error) {
                        console.warn('IndexedDB load failed:', error);
                    }
                }

                // Fallback to localStorage
                if (!data) {
                    try {
                        const savedProjects = localStorage.getItem(this.storageKey);
                        const savedCurrentProject = localStorage.getItem(this.currentProjectKey);
                        const savedVersion = localStorage.getItem(this.versionKey);

                        if (savedProjects) {
                            data = {
                                version: savedVersion || '1.0.0',
                                projects: JSON.parse(savedProjects),
                                currentProject: savedCurrentProject || 'default',
                                timestamp: localStorage.getItem(this.lastBackupKey) || new Date().toISOString()
                            };

                            if (!this.validateData(data)) {
                                throw new Error('Data validation failed');
                            }
                        }
                    } catch (error) {
                        console.error('localStorage load failed:', error);
                        data = null;
                    }
                }

                return data;
            }

            // Create backup in IndexedDB
            async createBackup() {
                if (!this.db) return false;

                try {
                    const data = this.createDataPackage();
                    const transaction = this.db.transaction(['backups'], 'readwrite');
                    const store = transaction.objectStore('backups');

                    const backupId = `backup_${Date.now()}`;
                    await store.put({
                        id: backupId,
                        timestamp: data.timestamp,
                        data: data
                    });

                    // Clean old backups
                    await this.cleanOldBackups();
                    return true;
                } catch (error) {
                    console.error('Backup creation failed:', error);
                    return false;
                }
            }

            // Clean old backups (keep only MAX_BACKUPS)
            async cleanOldBackups() {
                if (!this.db) return;

                try {
                    const transaction = this.db.transaction(['backups'], 'readwrite');
                    const store = transaction.objectStore('backups');
                    const index = store.index('timestamp');

                    const allBackups = await index.getAll();
                    if (allBackups.length > MAX_BACKUPS) {
                        const toDelete = allBackups
                            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
                            .slice(0, allBackups.length - MAX_BACKUPS);

                        for (const backup of toDelete) {
                            await store.delete(backup.id);
                        }
                    }
                } catch (error) {
                    console.error('Backup cleanup failed:', error);
                }
            }

            // Export data as JSON file
            exportData() {
                const data = this.createDataPackage();
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ultra-kanban-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.updateBackupStatus({ export: true });
            }

            // Import data from JSON file
            async importData(file) {
                try {
                    const text = await file.text();
                    const importedData = JSON.parse(text);

                    if (!this.validateData(importedData)) {
                        throw new Error('Invalid data format');
                    }

                    // Create backup before import
                    await this.createBackup();

                    // Apply imported data
                    projects = importedData.projects;
                    currentProject = importedData.currentProject || 'default';

                    // Save and render
                    await this.save();
                    renderProjects();
                    switchProject(currentProject);

                    this.updateBackupStatus({ import: true });
                    return true;
                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Import failed: ' + error.message);
                    return false;
                }
            }

            // Update backup status display
            updateBackupStatus(success) {
                const statusEl = document.getElementById('backupStatus');
                const now = new Date().toLocaleTimeString();

                if (success.export) {
                    statusEl.textContent = `Exported at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.import) {
                    statusEl.textContent = `Imported at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.localStorage && success.indexedDB) {
                    statusEl.textContent = `All saved at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.localStorage || success.indexedDB) {
                    statusEl.textContent = `Partial save at ${now}`;
                    statusEl.style.color = 'rgba(255, 193, 7, 0.8)';
                } else {
                    statusEl.textContent = `Save failed at ${now}`;
                    statusEl.style.color = 'rgba(244, 67, 54, 0.8)';
                }

                setTimeout(() => {
                    statusEl.textContent = 'Auto-saving...';
                    statusEl.style.color = 'rgba(255, 255, 255, 0.7)';
                }, 3000);
            }
        }

        // Initialize storage manager
        const storage = new FirebaseStorageManager();

        // Define auth functions EARLY to ensure they're available for HTML onclick handlers
        function showLoginForm() {
            document.getElementById('userLoginForm').style.display = 'block';
            document.getElementById('userRegisterForm').style.display = 'none';
            document.getElementById('legacyLoginForm').style.display = 'none';
            document.getElementById('authFormDescription').textContent = 'Accede a tu cuenta personal';
        }

        function showRegisterForm() {
            document.getElementById('userLoginForm').style.display = 'none';
            document.getElementById('userRegisterForm').style.display = 'block';
            document.getElementById('legacyLoginForm').style.display = 'none';
            document.getElementById('authFormDescription').textContent = 'Crea tu cuenta personal';
        }

        function showLegacyLogin() {
            console.log('üîÑ Switching to legacy login mode...');
            document.getElementById('userLoginForm').style.display = 'none';
            document.getElementById('userRegisterForm').style.display = 'none';
            document.getElementById('legacyLoginForm').style.display = 'block';
            document.getElementById('authFormDescription').textContent = 'Modo compatibilidad';
            
            // Initialize legacy mode
            console.log('üöÄ Calling initializeLegacyMode...');
            if (typeof initializeLegacyMode === 'function') {
                initializeLegacyMode();
            } else {
                console.error('‚ùå initializeLegacyMode not yet available');
                setTimeout(() => {
                    if (typeof initializeLegacyMode === 'function') {
                        initializeLegacyMode();
                    }
                }, 100);
            }
        }

        // Make functions globally available
        window.showLoginForm = showLoginForm;
        window.showRegisterForm = showRegisterForm;
        window.showLegacyLogin = showLegacyLogin;

        // Placeholder functions for async operations - will be defined properly later
        async function handleUserLogin() { console.log('handleUserLogin called early - will be replaced'); }
        async function handleUserRegister() { console.log('handleUserRegister called early - will be replaced'); }
        async function checkPassword() { console.log('checkPassword called early - will be replaced'); }
        async function setupPassword() { console.log('setupPassword called early - will be replaced'); }
        
        // Make all functions globally available immediately
        window.handleUserLogin = handleUserLogin;
        window.handleUserRegister = handleUserRegister;
        window.checkPassword = checkPassword;
        window.setupPassword = setupPassword;

        console.log('‚úÖ Early auth functions defined:', {
            showLoginForm: typeof window.showLoginForm,
            showRegisterForm: typeof window.showRegisterForm, 
            showLegacyLogin: typeof window.showLegacyLogin,
            handleUserLogin: typeof window.handleUserLogin,
            handleUserRegister: typeof window.handleUserRegister,
            checkPassword: typeof window.checkPassword,
            setupPassword: typeof window.setupPassword,
            initializeLegacyMode: typeof window.initializeLegacyMode
        });

        // Password Protection System removed - using legacy PasswordManager instead

        // New User Authentication Manager
        class UserAuthManager {
            constructor() {
                this.userKey = 'kanbanCurrentUser';
                this.sessionKey = 'kanbanUserSession';
                this.sessionDuration = 365 * 24 * 60 * 60 * 1000; // 1 year
            }

            async hashEmail(email) {
                const encoder = new TextEncoder();
                const data = encoder.encode(email.toLowerCase().trim() + 'kanban_email_salt');
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            async hashPassword(password, email) {
                const encoder = new TextEncoder();
                const data = encoder.encode(password + email.toLowerCase() + 'kanban_pwd_salt');
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            async registerUser(email, password) {
                try {
                    console.log('üìù Registration attempt for:', email);
                    
                    // Validate Firebase is ready
                    if (!window.database || !window.firebaseGet || !window.firebaseSet) {
                        console.error('‚ùå Firebase not properly initialized');
                        return { success: false, error: 'Sistema no disponible. Recarga la p√°gina.' };
                    }

                    const emailHash = await this.hashEmail(email);
                    console.log('üìß Email hash for registration:', emailHash.substring(0, 10) + '...');
                    
                    // Check if user already exists
                    const exists = await this.userExists(emailHash);
                    console.log('üë§ User exists check:', exists);
                    
                    if (exists) {
                        console.log('‚ùå User already exists');
                        return { success: false, error: 'Usuario ya existe' };
                    }

                    const passwordHash = await this.hashPassword(password, email);
                    console.log('üîí Password hash generated for registration');

                    console.log('üî• Creating user in Firebase...');
                    const userRef = window.firebaseRef(window.database, `users/${emailHash}`);
                    await window.firebaseSet(userRef, {
                        email: email.toLowerCase().trim(),
                        passwordHash: passwordHash,
                        created: new Date().toISOString(),
                        lastLogin: new Date().toISOString()
                    });
                    console.log('üë§ User created in Firebase');

                    console.log('üóÇÔ∏è Creating user workspace...');
                    const workspaceRef = window.firebaseRef(window.database, `userWorkspaces/${emailHash}`);
                    await window.firebaseSet(workspaceRef, {
                        projects: {},
                        currentProject: null,
                        settings: {},
                        created: new Date().toISOString()
                    });
                    console.log('üóÇÔ∏è User workspace created');

                    console.log('‚úÖ Registration successful for:', email);
                    return { success: true, userHash: emailHash };
                    
                } catch (error) {
                    console.error('üí• Registration exception:', error);
                    return { success: false, error: `Error en registro: ${error.message}` };
                }
            }

            async loginUser(email, password) {
                try {
                    console.log('üîê Login attempt for:', email);
                    
                    // Validate Firebase is ready
                    if (!window.database || !window.firebaseGet || !window.firebaseUpdate) {
                        console.error('‚ùå Firebase not properly initialized');
                        return { success: false, error: 'Sistema no disponible. Recarga la p√°gina.' };
                    }

                    const emailHash = await this.hashEmail(email);
                    console.log('üìß Email hash generated:', emailHash.substring(0, 10) + '...');
                    
                    const passwordHash = await this.hashPassword(password, email);
                    console.log('üîí Password hash generated');

                    // Check user credentials
                    const userRef = window.firebaseRef(window.database, `users/${emailHash}`);
                    console.log('üîç Checking user in Firebase...');
                    
                    let snapshot;
                    try {
                        snapshot = await window.firebaseGet(userRef);
                    } catch (firebaseError) {
                        console.error('üî• Firebase get error:', firebaseError);
                        return { success: false, error: 'Error de conexi√≥n con la base de datos' };
                    }
                    
                    if (!snapshot.exists()) {
                        console.log('‚ùå User not found in Firebase');
                        return { success: false, error: 'Usuario no encontrado' };
                    }

                    const userData = snapshot.val();
                    console.log('üë§ User data found:', { email: userData.email, created: userData.created });
                    
                    if (userData.passwordHash !== passwordHash) {
                        console.log('‚ùå Password mismatch');
                        return { success: false, error: 'Contrase√±a incorrecta' };
                    }

                    console.log('‚úÖ Password verified, updating last login...');
                    
                    // Update last login (non-blocking)
                    try {
                        await window.firebaseUpdate(userRef, {
                            lastLogin: new Date().toISOString()
                        });
                        console.log('üìÖ Last login updated');
                    } catch (updateError) {
                        console.warn('‚ö†Ô∏è Could not update last login:', updateError);
                        // Don't fail login if we can't update timestamp
                    }

                    // Create session
                    const session = {
                        userHash: emailHash,
                        email: userData.email,
                        loginTime: Date.now(),
                        expires: Date.now() + this.sessionDuration
                    };

                    localStorage.setItem(this.userKey, emailHash);
                    sessionStorage.setItem(this.sessionKey, JSON.stringify(session));
                    
                    console.log('‚úÖ Login successful for:', userData.email);
                    return { success: true, userHash: emailHash, email: userData.email };

                } catch (error) {
                    console.error('üí• Login exception:', error);
                    return { success: false, error: `Error en login: ${error.message}` };
                }
            }

            async userExists(emailHash) {
                try {
                    if (window.database) {
                        const userRef = window.firebaseRef(window.database, `users/${emailHash}`);
                        const snapshot = await window.firebaseGet(userRef);
                        return snapshot.exists();
                    }
                    return false;
                } catch (error) {
                    console.error('User check failed:', error);
                    return false;
                }
            }

            getCurrentUser() {
                const session = sessionStorage.getItem(this.sessionKey);
                if (session) {
                    const parsed = JSON.parse(session);
                    if (parsed.expires > Date.now()) {
                        return {
                            userHash: parsed.userHash,
                            email: parsed.email,
                            isLoggedIn: true
                        };
                    }
                }
                return { isLoggedIn: false };
            }

            logout() {
                localStorage.removeItem(this.userKey);
                sessionStorage.removeItem(this.sessionKey);
                // Clear all kanban data
                localStorage.removeItem('kanbanProjects');
                localStorage.removeItem('currentProject');
                localStorage.removeItem('kanbanUserId');
                localStorage.removeItem('userWorkspaces');
            }

            isValidSession() {
                const user = this.getCurrentUser();
                return user.isLoggedIn;
            }
        }

        // Legacy Password Manager (Simple Password Mode)
        class PasswordManager {
            constructor() {
                this.userId = 'kanban_legacy_user';
                this.passwordKey = 'kanbanPassword';
                this.sessionKey = 'kanbanSession';
                this.sessionDuration = 7 * 24 * 60 * 60 * 1000; // 7 days
            }

            async hashPassword(password) {
                const encoder = new TextEncoder();
                const data = encoder.encode(password + 'kanban_salt');
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            async setPassword(password) {
                const hashedPassword = await this.hashPassword(password);
                localStorage.setItem(this.passwordKey, hashedPassword);
                
                // Also save to Firebase if available
                if (window.database) {
                    try {
                        const passwordRef = window.firebaseRef(window.database, `legacyPasswords/${this.userId}`);
                        await window.firebaseSet(passwordRef, {
                            hash: hashedPassword,
                            created: new Date().toISOString()
                        });
                        console.log('üîê Legacy password saved to Firebase');
                    } catch (error) {
                        console.error('Failed to save legacy password to Firebase:', error);
                    }
                }
            }

            async checkPassword(password) {
                const hashedPassword = await this.hashPassword(password);
                
                // Check Firebase first (for cross-device sync)
                if (window.database) {
                    try {
                        const passwordRef = window.firebaseRef(window.database, `legacyPasswords/${this.userId}`);
                        const snapshot = await window.firebaseGet(passwordRef);
                        if (snapshot.exists()) {
                            const data = snapshot.val();
                            return data.hash === hashedPassword;
                        }
                    } catch (error) {
                        console.error('Failed to check Firebase password:', error);
                    }
                }
                
                // Fall back to localStorage
                const savedHash = localStorage.getItem(this.passwordKey);
                return savedHash === hashedPassword;
            }

            async hasPassword() {
                // Check Firebase first
                if (window.database) {
                    try {
                        const passwordRef = window.firebaseRef(window.database, `legacyPasswords/${this.userId}`);
                        const snapshot = await window.firebaseGet(passwordRef);
                        if (snapshot.exists()) {
                            return true;
                        }
                    } catch (error) {
                        console.error('Failed to check Firebase password:', error);
                    }
                }
                
                // Check localStorage
                return localStorage.getItem(this.passwordKey) !== null;
            }

            createSession() {
                const sessionData = {
                    timestamp: Date.now(),
                    expires: Date.now() + this.sessionDuration
                };
                sessionStorage.setItem(this.sessionKey, JSON.stringify(sessionData));
            }

            isSessionValid() {
                const sessionData = sessionStorage.getItem(this.sessionKey);
                if (!sessionData) return false;
                
                try {
                    const session = JSON.parse(sessionData);
                    return Date.now() < session.expires;
                } catch {
                    return false;
                }
            }

            clearSession() {
                sessionStorage.removeItem(this.sessionKey);
            }
        }

        const userAuth = new UserAuthManager();
        const passwordManager = new PasswordManager();

        // New User Authentication UI Functions
        // Auth UI functions now defined early for immediate availability

        // Functions are assigned to window immediately after definition

        // Replace placeholder with real implementation
        handleUserLogin = async function() {
            const email = document.getElementById('emailInput').value.trim();
            const password = document.getElementById('userPasswordInput').value;
            const errorDiv = document.getElementById('userLoginError');

            if (!email || !password) {
                errorDiv.textContent = 'Email y contrase√±a son requeridos';
                errorDiv.style.display = 'block';
                return;
            }

            if (!email.includes('@')) {
                errorDiv.textContent = 'Ingresa un email v√°lido';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                errorDiv.style.display = 'none';
                console.log('üîê Starting login for:', email);
                const result = await userAuth.loginUser(email, password);
                console.log('üîê Login result:', result);
                
                if (result.success) {
                    console.log(`üîë User logged in successfully: ${result.email}`);
                    await initializeUserSession(result.userHash, result.email);
                } else {
                    console.error('‚ùå Login failed:', result.error);
                    errorDiv.textContent = result.error;
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('üí• Login exception:', error);
                errorDiv.textContent = 'Error al iniciar sesi√≥n: ' + error.message;
                errorDiv.style.display = 'block';
            }
        };

        // Replace placeholder with real implementation  
        handleUserRegister = async function() {
            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value;
            const confirmPassword = document.getElementById('registerConfirmPassword').value;
            const errorDiv = document.getElementById('userRegisterError');

            if (!email || !password || !confirmPassword) {
                errorDiv.textContent = 'Todos los campos son requeridos';
                errorDiv.style.display = 'block';
                return;
            }

            if (!email.includes('@')) {
                errorDiv.textContent = 'Ingresa un email v√°lido';
                errorDiv.style.display = 'block';
                return;
            }

            if (password !== confirmPassword) {
                errorDiv.textContent = 'Las contrase√±as no coinciden';
                errorDiv.style.display = 'block';
                return;
            }

            if (password.length < 6) {
                errorDiv.textContent = 'La contrase√±a debe tener al menos 6 caracteres';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                errorDiv.style.display = 'none';
                console.log('üöÄ Starting user registration for:', email);
                const result = await userAuth.registerUser(email, password);
                console.log('üìù Registration result:', result);
                
                if (result.success) {
                    console.log(`‚ú® User registered successfully: ${email}`);
                    // Auto-login after registration
                    console.log('üîê Auto-login after registration...');
                    const loginResult = await userAuth.loginUser(email, password);
                    console.log('üîê Auto-login result:', loginResult);
                    if (loginResult.success) {
                        console.log('‚úÖ Auto-login successful, initializing session...');
                        await initializeUserSession(loginResult.userHash, email);
                    } else {
                        console.error('‚ùå Auto-login failed:', loginResult.error);
                        errorDiv.textContent = 'Registro exitoso pero fall√≥ el login autom√°tico. Intenta hacer login manualmente.';
                        errorDiv.style.display = 'block';
                    }
                } else {
                    console.error('‚ùå Registration failed:', result.error);
                    errorDiv.textContent = result.error;
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('üí• Registration exception:', error);
                errorDiv.textContent = 'Error al registrar usuario: ' + error.message;
                errorDiv.style.display = 'block';
            }
        };

        async function initializeUserSession(userHash, email) {
            // Update storage to use the new user system
            storage.userId = userHash;
            
            // Load user data from Firebase
            await loadUserData(userHash);
            
            // Initialize workspaces AFTER user authentication
            console.log('üóÇÔ∏è Initializing workspaces for user:', email);
            initializeWorkspaces();
            
            // Hide password overlay and show app
            document.getElementById('passwordOverlay').style.display = 'none';
            document.getElementById('appContent').style.display = 'flex';
            
            // Update UI with user info
            updateUserInterface(email);
            
            // Render workspace dropdown
            renderWorkspaceDropdown();
            
            // Render projects and initialize app
            renderProjects();
            if (currentProject && projects[currentProject]) {
                switchProject(currentProject);
            } else if (Object.keys(projects).length > 0) {
                switchProject(Object.keys(projects)[0]);
            } else {
                // Show create board message for empty workspace
                console.log('üîß Setting empty workspace message');
                const boardTitle = document.getElementById('boardTitle');
                if (boardTitle) {
                    boardTitle.value = 'Please, create a Board';
                    boardTitle.disabled = true;
                    boardTitle.style.color = '#6b7280';
                    boardTitle.style.fontStyle = 'italic';
                    console.log('‚úÖ Board title set to:', boardTitle.value);
                }
            }
        }

        async function loadUserData(userHash) {
            try {
                if (window.database) {
                    const workspaceRef = window.firebaseRef(window.database, `userWorkspaces/${userHash}`);
                    const snapshot = await window.firebaseGet(workspaceRef);
                    
                    if (snapshot.exists()) {
                        const userData = snapshot.val();
                        projects = userData.projects || {};
                        currentProject = userData.currentProject;
                        console.log(`üìä Loaded ${Object.keys(projects).length} boards for user`);
                    } else {
                        // Initialize empty user workspace
                        projects = {};
                        currentProject = null;
                        await saveUserData(userHash);
                    }
                }
            } catch (error) {
                console.error('Failed to load user data:', error);
                projects = {};
                currentProject = null;
            }
        }

        async function saveUserData(userHash) {
            try {
                if (window.database) {
                    const workspaceRef = window.firebaseRef(window.database, `userWorkspaces/${userHash}`);
                    await window.firebaseSet(workspaceRef, {
                        projects: projects,
                        currentProject: currentProject,
                        settings: {},
                        lastUpdate: new Date().toISOString()
                    });
                }
                
                // Also save to localStorage for offline access (workspace-specific keys)
                const workspaceId = currentWorkspace || 'personal';
                localStorage.setItem(`kanbanProjects_${workspaceId}`, JSON.stringify(projects));
                localStorage.setItem(`currentProject_${workspaceId}`, currentProject || '');
            } catch (error) {
                console.error('Failed to save user data:', error);
            }
        }

        function updateUserInterface(email) {
            // Add user info below the kanban board, centered
            const mainContent = document.querySelector('.main-content');
            const userInfoDiv = document.createElement('div');
            userInfoDiv.className = 'user-info-bottom';
            userInfoDiv.innerHTML = `
                <div style="display: flex; justify-content: center; align-items: center; margin-top: 20px; padding: 8px 16px; background: rgba(255,255,255,0.8); border-radius: 8px; font-size: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <span style="color: #374151; font-weight: 500; margin-right: 12px;">üë§ Conectado como: ${email}</span>
                    <button onclick="handleLogout()" style="background: #ef4444; color: white; padding: 4px 12px; border: none; border-radius: 4px; font-size: 11px; cursor: pointer; transition: background 0.2s;">Cerrar Sesi√≥n</button>
                </div>
            `;
            
            // Insert at the end of main content
            mainContent.appendChild(userInfoDiv);
        }

        function handleLogout() {
            if (confirm('¬øSeguro que deseas cerrar sesi√≥n?')) {
                userAuth.logout();
                location.reload();
            }
        }

        function createDefaultProject() {
            const projectId = 'project_' + Date.now();
            projects[projectId] = {
                name: 'MI PRIMER BOARD',
                title: 'Mi Primer Board',
                tasks: {
                    todo: [],
                    doing: [],
                    done: []
                }
            };
            currentProject = projectId;
            saveUserData(userAuth.getCurrentUser().userHash);
        }

        // Password UI Functions (Legacy System)
        // Replace placeholder with real implementation
        checkPassword = async function() {
            console.log('üîê Checking password...');
            const password = document.getElementById('passwordInput').value;
            const errorDiv = document.getElementById('passwordError');

            if (!password) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Ingresa una contrase√±a';
                return;
            }

            const isValid = await passwordManager.checkPassword(password);
            if (isValid) {
                passwordManager.createSession();
                unlockApp();
            } else {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Contrase√±a incorrecta';
                document.getElementById('passwordInput').value = '';
                document.getElementById('passwordInput').focus();
            }
        };

        // Replace placeholder with real implementation  
        setupPassword = async function() {
            console.log('üìù Setting up new password...');
            const newPassword = document.getElementById('newPasswordInput').value;
            const confirmPassword = document.getElementById('confirmPasswordInput').value;
            const errorDiv = document.getElementById('setupError');

            if (!newPassword || newPassword.length < 4) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'La contrase√±a debe tener al menos 4 caracteres';
                return;
            }

            if (newPassword !== confirmPassword) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Las contrase√±as no coinciden';
                return;
            }

            await passwordManager.setPassword(newPassword);
            passwordManager.createSession();
            unlockApp();
        };

        // Verify all auth functions are properly loaded
        console.log('‚úÖ Auth functions loaded:', {
            showLoginForm: typeof window.showLoginForm,
            showRegisterForm: typeof window.showRegisterForm,
            showLegacyLogin: typeof window.showLegacyLogin,
            handleUserLogin: typeof window.handleUserLogin,
            handleUserRegister: typeof window.handleUserRegister,
            checkPassword: typeof window.checkPassword,
            setupPassword: typeof window.setupPassword
        });

        function unlockApp() {
            document.getElementById('passwordOverlay').style.display = 'none';
            document.getElementById('appContent').classList.add('unlocked');
            
            // Initialize workspaces for legacy users
            console.log('üóÇÔ∏è Initializing workspaces for legacy user');
            initializeWorkspaces();
            renderWorkspaceDropdown();
            
            loadData(); // Load the application data
        }

        function lockApp() {
            passwordManager.clearSession();
            document.getElementById('passwordOverlay').style.display = 'flex';
            document.getElementById('appContent').classList.remove('unlocked');
            document.getElementById('passwordInput').value = '';
            document.getElementById('passwordError').style.display = 'none';
        }

        // Initialize password protection
        async function initializePasswordProtection() {
            console.log('üîê Initializing authentication system...');
            
            // First check if user has a valid session with new system
            const currentUser = userAuth.getCurrentUser();
            if (currentUser.isLoggedIn) {
                console.log('‚úÖ Valid user session found:', currentUser.email);
                await initializeUserSession(currentUser.userHash, currentUser.email);
                return;
            }

            // Check for legacy session
            if (passwordManager.isSessionValid()) {
                console.log('‚úÖ Valid legacy session found, unlocking app');
                unlockApp();
                return;
            }

            // Show the new login form by default
            console.log('üë§ No valid session, showing user authentication');
            showLoginForm();
            document.getElementById('emailInput').focus();
        }

        // Define initializeLegacyMode function
        async function initializeLegacyMode() {
            console.log('üîß Initializing legacy mode...');
            
            try {
                const hasPassword = await passwordManager.hasPassword();
                console.log('üîç Has password check result:', hasPassword);
                
                if (hasPassword) {
                    // Show login form
                    console.log('üîë Password exists - showing login form');
                    document.getElementById('loginForm').style.display = 'block';
                    document.getElementById('setupForm').style.display = 'none';
                    document.getElementById('passwordInput').focus();
                } else {
                    // Show password setup form
                    console.log('üìù No password - showing setup form');
                    document.getElementById('loginForm').style.display = 'none';
                    document.getElementById('setupForm').style.display = 'block';
                    document.getElementById('newPasswordInput').focus();
                }
            } catch (error) {
                console.error('‚ùå Error initializing legacy mode:', error);
                // Fallback to setup form
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('setupForm').style.display = 'block';
                document.getElementById('newPasswordInput').focus();
            }
        }
        window.initializeLegacyMode = initializeLegacyMode;

        // Handle Enter key in authentication inputs
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                // New user system
                if (document.getElementById('userPasswordInput') === document.activeElement || 
                    document.getElementById('emailInput') === document.activeElement) {
                    handleUserLogin();
                } else if (document.getElementById('registerConfirmPassword') === document.activeElement ||
                          document.getElementById('registerPassword') === document.activeElement ||
                          document.getElementById('registerEmail') === document.activeElement) {
                    handleUserRegister();
                } 
                // Legacy system
                else if (document.getElementById('passwordInput') === document.activeElement) {
                    checkPassword();
                } else if (document.getElementById('confirmPasswordInput') === document.activeElement ||
                          document.getElementById('newPasswordInput') === document.activeElement) {
                    setupPassword();
                }
            }
        });

        // Load data with enhanced persistence
        // Ensure project has proper structure
        function ensureProjectStructure(project) {
            if (!project.tasks) {
                project.tasks = {
                    todo: [],
                    doing: [],
                    done: []
                };
            }
            if (!project.tasks.todo) project.tasks.todo = [];
            if (!project.tasks.doing) project.tasks.doing = [];
            if (!project.tasks.done) project.tasks.done = [];
            return project;
        }

        async function loadData() {
            try {
                const data = await storage.load();
                if (data) {
                    projects = data.projects;
                    currentProject = data.currentProject;
                    projectTrash = data.projectTrash || [];
                    
                    // Ensure all projects have proper structure
                    Object.keys(projects).forEach(projectId => {
                        projects[projectId] = ensureProjectStructure(projects[projectId]);
                    });
                }
            } catch (error) {
                console.error('Failed to load data:', error);
            }

            renderProjects();
            // Don't auto-render trash - only show when toggled
            switchProject(currentProject);
        }

        // Save data with enhanced persistence
        async function saveData() {
            try {
                // Check if using new user system
                const currentUser = userAuth.getCurrentUser();
                if (currentUser.isLoggedIn) {
                    await saveUserData(currentUser.userHash);
                } else {
                    // Fall back to legacy system
                    await storage.save();
                }
            } catch (error) {
                console.error('Failed to save data:', error);
            }
        }

        // Auto-save every 30 seconds
        setInterval(saveData, 30000);

        // Save before page unload
        window.addEventListener('beforeunload', saveData);

        // Periodic backup (every 5 minutes)
        setInterval(async () => {
            try {
                await storage.createBackup();
            } catch (error) {
                console.error('Auto-backup failed:', error);
            }
        }, 5 * 60 * 1000);

        // Global functions for UI
        function exportData() {
            storage.exportData();
        }

        function createBackup() {
            storage.createBackup().then(success => {
                if (success) {
                    storage.updateBackupStatus({ export: false, import: false });
                } else {
                    alert('Backup creation failed. Check console for details.');
                }
            });
        }

        function importData(event) {
            const file = event.target.files[0];
            if (file) {
                storage.importData(file);
                event.target.value = ''; // Reset input
            }
        }

        // Import tasks from text file
        async function importTasksFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const lines = text.split(/\r?\n/)
                    .map(line => line.trim())
                    .filter(line => line.length > 0); // Remove empty lines

                if (lines.length === 0) {
                    alert('No valid tasks found in the file.');
                    return;
                }

                // Add tasks to the current project's TODO column
                const addedTasks = [];
                lines.forEach(line => {
                    if (line.length > 0) {
                        projects[currentProject].tasks.todo.push(line);
                        addedTasks.push(line);
                    }
                });

                // Save and refresh the UI
                await saveData();
                renderTasks();

                // Show success feedback
                showTaskImportFeedback(addedTasks.length, file.name);

                // Reset input
                event.target.value = '';

            } catch (error) {
                console.error('Task import failed:', error);
                alert('Failed to import tasks: ' + error.message);
                event.target.value = '';
            }
        }

        // Show feedback for task import
        function showTaskImportFeedback(count, filename) {
            const statusEl = document.getElementById('backupStatus');
            const originalText = statusEl.textContent;
            const originalColor = statusEl.style.color;

            statusEl.textContent = `Imported ${count} tasks from ${filename}`;
            statusEl.style.color = 'rgba(76, 175, 80, 0.8)';

            setTimeout(() => {
                statusEl.textContent = originalText;
                statusEl.style.color = originalColor;
            }, 4000);
        }

        // Render projects in sidebar
        function renderProjects() {
            const projectList = document.getElementById('projectList');
            projectList.innerHTML = '';
            
            // Add drag and drop event listeners to the container
            projectList.addEventListener('dragover', handleProjectDragOver);
            projectList.addEventListener('drop', handleProjectDrop);

            Object.keys(projects).forEach(projectId => {
                const projectDiv = document.createElement('div');
                projectDiv.className = `project-item ${projectId === currentProject ? 'active' : ''}`;
                projectDiv.setAttribute('data-project', projectId);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'project-item-content';

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'project-name';
                nameInput.value = projects[projectId].name;
                nameInput.readOnly = true;
                nameInput.setAttribute('data-project-id', projectId);

                // Double-click to edit
                nameInput.addEventListener('dblclick', () => startEditingProjectName(nameInput, projectId));

                // Handle enter/escape keys
                nameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        finishEditingProjectName(nameInput, projectId);
                    } else if (e.key === 'Escape') {
                        cancelEditingProjectName(nameInput, projectId);
                    }
                });

                // Handle blur (clicking outside)
                nameInput.addEventListener('blur', () => {
                    if (!nameInput.readOnly) {
                        finishEditingProjectName(nameInput, projectId);
                    }
                });

                contentDiv.appendChild(nameInput);

                // Add task count badge
                const taskCount = projects[projectId].tasks?.todo?.length || 0;
                const countBadge = document.createElement('span');
                countBadge.className = `task-count ${taskCount === 0 ? 'zero' : ''}`;
                countBadge.textContent = taskCount;
                countBadge.title = `${taskCount} tareas pendientes`;
                contentDiv.appendChild(countBadge);

                // Add right-click context menu
                projectDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showProjectContextMenu(e, projectId);
                });

                projectDiv.appendChild(contentDiv);

                // Click to switch project (but not when editing)
                // Add drag and drop functionality
                projectDiv.draggable = true;
                projectDiv.addEventListener('dragstart', handleProjectDragStart);
                projectDiv.addEventListener('dragover', handleProjectDragOver);
                projectDiv.addEventListener('drop', handleProjectDrop);
                projectDiv.addEventListener('dragend', handleProjectDragEnd);

                projectDiv.onclick = (e) => {
                    if (e.target === nameInput && !nameInput.readOnly) {
                        return; // Don't switch if editing
                    }
                    if (e.target.className !== 'delete-task') {
                        switchProject(projectId);
                    }
                };

                projectList.appendChild(projectDiv);
            });
        }

        // Project drag and drop functionality
        let draggedProject = null;

        function handleProjectDragStart(e) {
            draggedProject = e.target.getAttribute('data-project');
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleProjectDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            // Remove existing drag-over classes
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('drag-over');
            });

            // Add drag-over class to current target
            const targetProject = e.target.closest('.project-item');
            if (targetProject && targetProject.getAttribute('data-project') !== draggedProject) {
                targetProject.classList.add('drag-over');
            }
        }

        function handleProjectDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const targetElement = e.target.closest('.project-item');
            if (!targetElement) return;
            
            const targetProjectId = targetElement.getAttribute('data-project');

            if (draggedProject && targetProjectId && draggedProject !== targetProjectId) {
                reorderProjects(draggedProject, targetProjectId);
                renderProjects(); // Re-render to show new order
                saveData(); // Save the new order
            }

            // Clean up
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        function handleProjectDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            draggedProject = null;
        }

        function reorderProjects(draggedId, targetId) {
            const projectKeys = Object.keys(projects);
            const draggedIndex = projectKeys.indexOf(draggedId);
            const targetIndex = projectKeys.indexOf(targetId);

            if (draggedIndex !== -1 && targetIndex !== -1) {
                // Remove dragged project from array
                projectKeys.splice(draggedIndex, 1);
                // Insert at target position
                projectKeys.splice(targetIndex, 0, draggedId);

                // Rebuild projects object in new order
                const reorderedProjects = {};
                projectKeys.forEach(key => {
                    reorderedProjects[key] = projects[key];
                });
                projects = reorderedProjects;

                saveData();
                renderProjects();
            }
        }

        // Switch between projects
        function switchProject(projectId) {
            currentProject = projectId;
            document.getElementById('currentProject').textContent = projects[projectId].name;
            
            const boardTitle = document.getElementById('boardTitle');
            boardTitle.value = projects[projectId].title;
            boardTitle.disabled = false;
            boardTitle.style.color = '#1f2937'; // Reset to normal color
            boardTitle.style.fontStyle = 'normal'; // Reset italic

            // Update active project in sidebar
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelector(`[data-project="${projectId}"]`).classList.add('active');

            // Render tasks for current project
            renderTasks();
            saveData();
        }

        // Render tasks for current project
        function renderTasks() {
            // Defensive check for valid project data
            if (!currentProject || !projects[currentProject] || !projects[currentProject].tasks) {
                console.log('‚ö†Ô∏è No valid board data for rendering tasks');
                clearAllTasks();
                return;
            }
            
            console.log('üé® Rendering tasks for board:', currentProject);
            const columns = ['todo', 'doing', 'done'];
            columns.forEach(column => {
                const taskList = document.getElementById(column + 'List');
                if (!taskList) return;
                
                taskList.innerHTML = '';

                const tasks = projects[currentProject].tasks[column] || [];
                tasks.forEach((task, index) => {
                    // Create drop indicator
                    const dropIndicator = document.createElement('div');
                    dropIndicator.className = 'drop-indicator';
                    dropIndicator.setAttribute('data-drop-index', index);
                    dropIndicator.setAttribute('data-column', column);
                    taskList.appendChild(dropIndicator);

                    // Create task item
                    const taskDiv = document.createElement('div');
                    taskDiv.className = 'task-item';
                    taskDiv.draggable = true;
                    taskDiv.setAttribute('data-task-id', index);
                    taskDiv.setAttribute('data-column', column);

                    // Create task wrapper
                    const wrapperDiv = document.createElement('div');
                    wrapperDiv.className = 'task-item-wrapper';

                    // Create editable task content
                    const taskContent = document.createElement('div');
                    taskContent.className = 'task-content';
                    taskContent.contentEditable = false;
                    taskContent.innerHTML = makeURLsClickable(task);
                    taskContent.setAttribute('data-task-id', index);
                    taskContent.setAttribute('data-column', column);

                    // Add single-click to edit and double-click to copy
                    let clickTimer = null;
                    taskContent.addEventListener('click', (e) => {
                        // Prevent editing when dragging
                        if (e.target.closest('.task-item').classList.contains('dragging')) return;

                        if (clickTimer) {
                            // This is a double-click
                            clearTimeout(clickTimer);
                            clickTimer = null;
                            copyTaskText(taskContent);
                        } else {
                            // This might be a single-click, wait to see if double-click follows
                            clickTimer = setTimeout(() => {
                                clickTimer = null;
                                if (taskContent.contentEditable !== 'true') {
                                    startEditingTask(taskContent, column, index);
                                }
                            }, 250);
                        }
                    });

                    // Handle enter/escape keys
                    taskContent.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            finishEditingTask(taskContent, column, index);
                        } else if (e.key === 'Escape') {
                            cancelEditingTask(taskContent, column, index);
                        }
                    });

                    // Handle blur (clicking outside)
                    taskContent.addEventListener('blur', () => {
                        if (taskContent.contentEditable === 'true') {
                            finishEditingTask(taskContent, column, index);
                        }
                    });

                    // Create delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-task';
                    deleteBtn.textContent = '√ó';
                    deleteBtn.onclick = () => deleteTask(column, index);

                    wrapperDiv.appendChild(taskContent);
                    wrapperDiv.appendChild(deleteBtn);
                    taskDiv.appendChild(wrapperDiv);

                    // Add drag event listeners
                    taskDiv.addEventListener('dragstart', handleTaskDragStart);
                    taskDiv.addEventListener('dragend', handleTaskDragEnd);
                    taskDiv.addEventListener('dragover', handleTaskDragOver);
                    taskDiv.addEventListener('drop', handleTaskDrop);

                    taskList.appendChild(taskDiv);
                });

                // Add final drop indicator
                const finalDropIndicator = document.createElement('div');
                finalDropIndicator.className = 'drop-indicator';
                finalDropIndicator.setAttribute('data-drop-index', projects[currentProject].tasks[column].length);
                finalDropIndicator.setAttribute('data-column', column);
                taskList.appendChild(finalDropIndicator);
            });
        }

        // Create new project
        function createProject() {
            document.getElementById('projectModal').style.display = 'flex';
            document.getElementById('projectInput').focus();
        }

        function addProject() {
            const projectName = document.getElementById('projectInput').value.trim().toUpperCase();
            if (projectName) {
                const projectId = 'project_' + Date.now();
                projects[projectId] = {
                    name: projectName,
                    title: projectName,
                    tasks: {
                        todo: [],
                        doing: [],
                        done: []
                    }
                };
                renderProjects();
                switchProject(projectId);
                closeProjectModal();
            }
        }

        function deleteProject(projectId, event) {
            event.stopPropagation();
            if (confirm('Move this board to trash? You can restore it later.')) {
                // Move project to trash
                const trashedProject = {
                    ...projects[projectId],
                    originalId: projectId,
                    trashedAt: Date.now()
                };
                projectTrash.push(trashedProject);

                // Remove from active projects
                delete projects[projectId];
                if (currentProject === projectId) {
                    switchProject('default');
                }

                renderProjects();
                // Only render trash if currently visible
                if (trashVisible) renderTrash();
                saveData();

                // Show success message
                showNotification(`Board "${trashedProject.name}" moved to trash`, '#dc2626');
            }
        }

        function duplicateProject(projectId, event) {
            event.stopPropagation();
            const originalProject = projects[projectId];
            const newProjectId = 'project_' + Date.now();
            const newProjectName = originalProject.name + ' COPY';

            projects[newProjectId] = {
                name: newProjectName,
                title: originalProject.title + ' Copy',
                tasks: {
                    todo: [...originalProject.tasks.todo],
                    doing: [...originalProject.tasks.doing],
                    done: [...originalProject.tasks.done]
                }
            };

            renderProjects();
            saveData();

            // Show feedback
            const notification = document.createElement('div');
            notification.textContent = `Board "${newProjectName}" created successfully!`;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                z-index: 1000;
                font-size: 14px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Context menu functionality
        let contextMenuProjectId = null;

        function showProjectContextMenu(event, projectId) {
            const contextMenu = document.getElementById('projectContextMenu');
            contextMenuProjectId = projectId;

            // Show/hide delete option for default project
            const deleteItem = contextMenu.querySelector('.delete');
            if (projectId === 'default') {
                deleteItem.style.display = 'none';
            } else {
                deleteItem.style.display = 'flex';
            }

            // Position and show context menu
            contextMenu.style.left = event.clientX + 'px';
            contextMenu.style.top = event.clientY + 'px';
            contextMenu.style.display = 'block';

            // Close context menu when clicking elsewhere
            document.addEventListener('click', hideProjectContextMenu);
        }

        function hideProjectContextMenu() {
            const contextMenu = document.getElementById('projectContextMenu');
            contextMenu.style.display = 'none';
            document.removeEventListener('click', hideProjectContextMenu);
        }

        function duplicateProjectFromMenu() {
            if (contextMenuProjectId) {
                duplicateProject(contextMenuProjectId, { stopPropagation: () => {} });
                hideProjectContextMenu();
            }
        }

        function deleteProjectFromMenu() {
            if (contextMenuProjectId && contextMenuProjectId !== 'default') {
                deleteProject(contextMenuProjectId, { stopPropagation: () => {} });
                hideProjectContextMenu();
            }
        }

        // Trash context menu functionality
        let contextMenuTrashIndex = null;

        function showTrashContextMenu(event, trashIndex) {
            const contextMenu = document.getElementById('trashContextMenu');
            contextMenuTrashIndex = trashIndex;

            contextMenu.style.left = event.clientX + 'px';
            contextMenu.style.top = event.clientY + 'px';
            contextMenu.style.display = 'block';

            document.addEventListener('click', hideTrashContextMenu);
        }

        function hideTrashContextMenu() {
            const contextMenu = document.getElementById('trashContextMenu');
            contextMenu.style.display = 'none';
            document.removeEventListener('click', hideTrashContextMenu);
        }

        function restoreProjectFromMenu() {
            if (contextMenuTrashIndex !== null) {
                restoreProject(contextMenuTrashIndex);
                hideTrashContextMenu();
            }
        }

        function permanentDeleteFromMenu() {
            if (contextMenuTrashIndex !== null) {
                permanentDelete(contextMenuTrashIndex);
                hideTrashContextMenu();
            }
        }

        // Trash management functions
        // Track trash visibility state
        let trashVisible = false;

        function toggleTrash() {
            const trashSection = document.getElementById('trashSection');
            trashVisible = !trashVisible;
            
            if (trashVisible && projectTrash.length > 0) {
                trashSection.style.display = 'block';
                renderTrash();
            } else {
                trashSection.style.display = 'none';
            }
        }

        function renderTrash() {
            const trashList = document.getElementById('trashList');
            const trashSection = document.getElementById('trashSection');

            // Don't auto-show trash section, only render if already visible
            if (!trashVisible || projectTrash.length === 0) {
                trashSection.style.display = 'none';
                return;
            }

            trashSection.style.display = 'block';
            trashList.innerHTML = '';

            projectTrash.forEach((trashedProject, index) => {
                const trashItem = document.createElement('div');
                trashItem.className = 'trash-item';
                trashItem.setAttribute('data-trash-index', index);

                const daysAgo = Math.floor((Date.now() - trashedProject.trashedAt) / (1000 * 60 * 60 * 24));
                const timeText = daysAgo === 0 ? 'Today' : `${daysAgo} days ago`;

                trashItem.innerHTML = `
                    <div class="trash-item-name">${trashedProject.name}</div>
                    <div style="font-size: 10px; color: #9ca3af;">${timeText}</div>
                `;

                // Add right-click context menu for trash items
                trashItem.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showTrashContextMenu(e, index);
                });

                trashList.appendChild(trashItem);
            });
        }

        function restoreProject(trashIndex) {
            const trashedProject = projectTrash[trashIndex];
            if (!trashedProject) return;

            // Generate new ID if original ID exists
            let newId = trashedProject.originalId;
            if (projects[newId]) {
                newId = 'project_' + Date.now();
            }

            // Restore project
            projects[newId] = {
                name: trashedProject.name,
                title: trashedProject.title,
                sortingMode: trashedProject.sortingMode || 'free',
                tasks: trashedProject.tasks,
                taskMetadata: trashedProject.taskMetadata || {}
            };

            // Remove from trash
            projectTrash.splice(trashIndex, 1);

            renderProjects();
            // Only render trash if currently visible
            if (trashVisible) renderTrash();
            saveData();

            showNotification(`Board "${trashedProject.name}" restored successfully!`, '#10b981');
        }

        function permanentDelete(trashIndex) {
            const trashedProject = projectTrash[trashIndex];
            if (!trashedProject) return;

            if (confirm(`Permanently delete "${trashedProject.name}" board? This cannot be undone.`)) {
                projectTrash.splice(trashIndex, 1);
                // Only render trash if currently visible
                if (trashVisible) renderTrash();
                saveData();
                showNotification(`Board "${trashedProject.name}" permanently deleted`, '#dc2626');
            }
        }

        function emptyTrash() {
            if (projectTrash.length === 0) return;

            if (confirm(`Permanently delete all ${projectTrash.length} boards in trash? This cannot be undone.`)) {
                projectTrash = [];
                // Only render trash if currently visible
                if (trashVisible) renderTrash();
                saveData();
                showNotification('Trash emptied successfully', '#dc2626');
            }
        }

        // Notification function
        function showNotification(message, color = '#10b981') {
            const notification = document.createElement('div');
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${color};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                z-index: 1000;
                font-size: 14px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function closeProjectModal() {
            document.getElementById('projectModal').style.display = 'none';
            document.getElementById('projectInput').value = '';
        }

        // Task management
        function showAddTaskModal(column) {
            currentColumn = column;
            document.getElementById('taskModal').style.display = 'flex';
            document.getElementById('taskInput').focus();
        }

        function addTask() {
            const taskText = document.getElementById('taskInput').value.trim();
            if (taskText) {
                projects[currentProject].tasks[currentColumn].push(taskText);
                renderTasks();
                renderProjects(); // Update task counts
                closeModal();
                saveData();
            }
        }

        function deleteTask(column, index) {
            projects[currentProject].tasks[column].splice(index, 1);
            renderTasks();
            saveData();
        }

        function closeModal() {
            document.getElementById('taskModal').style.display = 'none';
            document.getElementById('taskInput').value = '';
        }

        // Task editing functions
        function startEditingTask(element, column, index) {
            element.contentEditable = true;
            element.focus();

            // Select all text
            const range = document.createRange();
            range.selectNodeContents(element);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);

            element.setAttribute('data-original-value', element.textContent);
        }

        function finishEditingTask(element, column, index) {
            const newText = element.textContent.trim();
            if (newText && newText !== '') {
                projects[currentProject].tasks[column][index] = newText;
                element.innerHTML = makeURLsClickable(newText);
                saveData();
            } else {
                // Revert to original value if empty
                element.textContent = element.getAttribute('data-original-value');
            }
            element.contentEditable = false;
            element.removeAttribute('data-original-value');
        }

        function cancelEditingTask(element, column, index) {
            element.textContent = element.getAttribute('data-original-value');
            element.contentEditable = false;
            element.removeAttribute('data-original-value');
        }

        // Copy task text to clipboard
        async function copyTaskText(element) {
            const text = element.textContent.trim();

            try {
                await navigator.clipboard.writeText(text);
                showCopyFeedback(element, 'Copied!');
            } catch (error) {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showCopyFeedback(element, 'Copied!');
            }
        }

        // Show copy feedback
        function showCopyFeedback(element, message) {
            // Add visual feedback to the task
            element.classList.add('copied');
            setTimeout(() => {
                element.classList.remove('copied');
            }, 300);

            // Create and show feedback tooltip
            const feedback = document.createElement('div');
            feedback.className = 'copy-feedback';
            feedback.textContent = message;

            const rect = element.getBoundingClientRect();
            feedback.style.left = rect.left + rect.width / 2 - 25 + 'px';
            feedback.style.top = rect.top - 10 + 'px';

            document.body.appendChild(feedback);

            // Animate in
            setTimeout(() => feedback.classList.add('show'), 10);

            // Remove after animation
            setTimeout(() => {
                feedback.classList.remove('show');
                setTimeout(() => {
                    if (feedback.parentNode) {
                        document.body.removeChild(feedback);
                    }
                }, 300);
            }, 1500);
        }

        // Enhanced drag and drop functionality
        let draggedTaskData = null;
        let isReordering = false;

        function handleTaskDragStart(e) {
            draggedTask = e.target;
            const taskId = parseInt(e.target.getAttribute('data-task-id'));
            const column = e.target.getAttribute('data-column');

            draggedTaskData = {
                taskId: taskId,
                column: column,
                content: projects[currentProject].tasks[column][taskId]
            };

            e.target.classList.add('dragging');

            // Determine if this is reordering within the same column or moving between columns
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleTaskDragEnd(e) {
            e.target.classList.remove('dragging', 'reordering');

            // Clear all drop indicators
            document.querySelectorAll('.drop-indicator').forEach(indicator => {
                indicator.classList.remove('active');
            });

            document.querySelectorAll('.task-list').forEach(list => {
                list.classList.remove('drag-over-reorder');
            });

            draggedTask = null;
            draggedTaskData = null;
            isReordering = false;
        }

        function handleTaskDragOver(e) {
            e.preventDefault();

            if (!draggedTask || !draggedTaskData) return;

            const rect = e.target.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const isAbove = e.clientY < midpoint;

            // Find the closest drop indicator
            const taskElement = e.target.closest('.task-item');
            if (taskElement) {
                const taskList = taskElement.parentElement;
                const indicators = taskList.querySelectorAll('.drop-indicator');

                // Clear all indicators first
                indicators.forEach(indicator => indicator.classList.remove('active'));

                const taskId = parseInt(taskElement.getAttribute('data-task-id'));
                const column = taskElement.getAttribute('data-column');

                // Activate appropriate indicator
                if (isAbove) {
                    const indicator = taskList.querySelector(`[data-drop-index="${taskId}"]`);
                    if (indicator) indicator.classList.add('active');
                } else {
                    const indicator = taskList.querySelector(`[data-drop-index="${taskId + 1}"]`);
                    if (indicator) indicator.classList.add('active');
                }

                // Add visual feedback for reordering vs moving
                if (column === draggedTaskData.column) {
                    taskList.classList.add('drag-over-reorder');
                    draggedTask.classList.add('reordering');
                    isReordering = true;
                } else {
                    taskList.classList.remove('drag-over-reorder');
                    draggedTask.classList.remove('reordering');
                    isReordering = false;
                }
            }
        }

        function handleTaskDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!draggedTask || !draggedTaskData) return;

            const targetElement = e.target.closest('.task-item');
            if (!targetElement) return;

            const targetTaskId = parseInt(targetElement.getAttribute('data-task-id'));
            const targetColumn = targetElement.getAttribute('data-column');

            const rect = targetElement.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const isAbove = e.clientY < midpoint;

            // Calculate drop position
            let dropIndex = isAbove ? targetTaskId : targetTaskId + 1;

            // Handle the drop
            const sourceColumn = draggedTaskData.column;
            const sourceIndex = draggedTaskData.taskId;

            if (sourceColumn === targetColumn) {
                // Reordering within the same column
                if (sourceIndex !== dropIndex && sourceIndex !== dropIndex - 1) {
                    const task = projects[currentProject].tasks[sourceColumn].splice(sourceIndex, 1)[0];

                    // Adjust drop index if we removed an item before it
                    if (sourceIndex < dropIndex) {
                        dropIndex--;
                    }

                    projects[currentProject].tasks[targetColumn].splice(dropIndex, 0, task);
                    renderTasks();
                    saveData();
                }
            } else {
                // Moving between columns
                const task = projects[currentProject].tasks[sourceColumn].splice(sourceIndex, 1)[0];
                projects[currentProject].tasks[targetColumn].splice(dropIndex, 0, task);
                renderTasks();
                saveData();
            }
        }

        // Legacy drag and drop for column-level drops (fallback)
        function handleDragStart(e) {
            if (!e.target.classList.contains('task-item')) return;
            handleTaskDragStart(e);
        }

        function handleDragEnd(e) {
            if (!e.target.classList.contains('task-item')) return;
            handleTaskDragEnd(e);
        }

        // Add drag and drop event listeners to columns
        document.querySelectorAll('.column').forEach(column => {
            column.addEventListener('dragover', handleDragOver);
            column.addEventListener('drop', handleDrop);
            column.addEventListener('dragenter', handleDragEnter);
            column.addEventListener('dragleave', handleDragLeave);
        });

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDragEnter(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            if (draggedTask) {
                const sourceColumn = draggedTask.getAttribute('data-column');
                const targetColumn = e.currentTarget.getAttribute('data-column');
                const taskIndex = parseInt(draggedTask.getAttribute('data-task-id'));

                if (sourceColumn !== targetColumn) {
                    // Move task between columns
                    const task = projects[currentProject].tasks[sourceColumn][taskIndex];
                    projects[currentProject].tasks[sourceColumn].splice(taskIndex, 1);
                    projects[currentProject].tasks[targetColumn].push(task);

                    renderTasks();
                    saveData();
                }
            }
        }

        // Board title editing
        document.getElementById('boardTitle').addEventListener('input', function() {
            projects[currentProject].title = this.value;
            saveData();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl+N to create new task in TODO column
            if (e.ctrlKey && e.key === 'n') {
                e.preventDefault();
                showAddTaskModal('todo');
                return;
            }

            if (e.key === 'Escape') {
                closeModal();
                closeProjectModal();
            } else if (e.key === 'Enter' && document.getElementById('taskModal').style.display === 'flex') {
                addTask();
            } else if (e.key === 'Enter' && document.getElementById('projectModal').style.display === 'flex') {
                addProject();
            }
        });

        // Project name editing functions
        function startEditingProjectName(input, projectId) {
            input.readOnly = false;
            input.focus();
            input.select();
            input.setAttribute('data-original-value', input.value);
        }

        function finishEditingProjectName(input, projectId) {
            const newName = input.value.trim().toUpperCase();
            if (newName && newName !== '') {
                projects[projectId].name = newName;
                document.getElementById('currentProject').textContent = projects[currentProject].name;
                saveData();
            } else {
                // Revert to original value if empty
                input.value = input.getAttribute('data-original-value');
            }
            input.readOnly = true;
            input.removeAttribute('data-original-value');
        }

        function cancelEditingProjectName(input, projectId) {
            input.value = input.getAttribute('data-original-value');
            input.readOnly = true;
            input.removeAttribute('data-original-value');
        }

        // Auto-refresh functionality
        function refreshData() {
            loadData().then(() => {
                console.log('Data refreshed automatically');
            }).catch(error => {
                console.error('Auto-refresh failed:', error);
            });
        }

        // Refresh data when page becomes visible (tab switching)
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                refreshData();
            }
        });

        // Refresh data when window gains focus
        window.addEventListener('focus', function() {
            refreshData();
        });

        // Function to make URLs clickable
        function makeURLsClickable(text) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
        }

        // Periodic refresh every 2 minutes (in case of multi-device usage)
        setInterval(refreshData, 2 * 60 * 1000);

        // Force refresh on page load to ensure latest data
        window.addEventListener('load', function() {
            setTimeout(refreshData, 500); // Small delay to ensure everything is loaded
        });

        // Workspace Management System
        let currentWorkspace = 'personal';
        let userWorkspaces = {};

        // Initialize workspace system
        function initializeWorkspaces() {
            // Load user's workspaces from localStorage
            const savedWorkspaces = localStorage.getItem('userWorkspaces');
            if (savedWorkspaces) {
                userWorkspaces = JSON.parse(savedWorkspaces);
            } else {
                // Create default personal workspace
                userWorkspaces = {
                    'personal': {
                        id: 'personal',
                        name: 'üìÅ Main Workspace',
                        type: 'main',
                        owner: storage.userId,
                        created: new Date().toISOString()
                    }
                };
                localStorage.setItem('userWorkspaces', JSON.stringify(userWorkspaces));
            }
            
            // Migration: Update existing personal workspace name if it's still the old name
            if (userWorkspaces['personal'] && 
                (userWorkspaces['personal'].name === 'üìÅ Personal Workspace' || 
                 userWorkspaces['personal'].name.includes('Personal Workspace'))) {
                console.log('üîÑ Migrating personal workspace name to Main Workspace');
                userWorkspaces['personal'].name = 'üìÅ Main Workspace';
                userWorkspaces['personal'].type = 'main';
                localStorage.setItem('userWorkspaces', JSON.stringify(userWorkspaces));
            }
            
            renderWorkspaceDropdown();
        }

        function renderWorkspaceDropdown() {
            const dropdown = document.getElementById('workspaceSelect');
            dropdown.innerHTML = '';
            
            Object.values(userWorkspaces).forEach(workspace => {
                const option = document.createElement('option');
                option.value = workspace.id;
                option.textContent = workspace.name;
                dropdown.appendChild(option);
            });
            
            dropdown.value = currentWorkspace;
            dropdown.addEventListener('change', switchWorkspace);
        }

        function showWorkspaceModal() {
            document.getElementById('workspaceModal').style.display = 'flex';
            refreshWorkspaceList();
        }
        
        function refreshWorkspaceList() {
            const container = document.getElementById('workspaceListContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            Object.keys(userWorkspaces).forEach(workspaceId => {
                const workspace = userWorkspaces[workspaceId];
                const isCurrentWorkspace = workspaceId === currentWorkspace;
                // Allow deletion of non-personal workspaces (more permissive)
                const canDelete = workspaceId !== 'personal' && (
                    !workspace.owner || // No owner set (legacy workspaces)
                    workspace.owner === storage.userId // User is owner
                );
                console.log('üîç Workspace delete check:', workspaceId, 'canDelete:', canDelete, 'owner:', workspace.owner, 'userId:', storage.userId);
                
                const workspaceDiv = document.createElement('div');
                workspaceDiv.style.cssText = `
                    display: flex; 
                    justify-content: space-between; 
                    align-items: center; 
                    padding: 8px 12px; 
                    margin: 5px 0; 
                    background: ${isCurrentWorkspace ? '#e0f2fe' : '#f9fafb'}; 
                    border: 1px solid ${isCurrentWorkspace ? '#0891b2' : '#e5e7eb'}; 
                    border-radius: 6px;
                `;
                
                const nameSpan = document.createElement('span');
                nameSpan.textContent = `${workspace.name}${isCurrentWorkspace ? ' (Actual)' : ''}`;
                nameSpan.style.cssText = `font-weight: ${isCurrentWorkspace ? 'bold' : 'normal'}; color: ${isCurrentWorkspace ? '#0891b2' : '#374151'};`;
                
                const actionsDiv = document.createElement('div');
                actionsDiv.style.display = 'flex';
                actionsDiv.style.gap = '8px';
                
                if (!isCurrentWorkspace) {
                    const switchBtn = document.createElement('button');
                    switchBtn.textContent = 'üìÇ Abrir';
                    switchBtn.style.cssText = 'background: #3b82f6; color: white; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;';
                    switchBtn.onclick = () => {
                        switchWorkspace({ target: { value: workspaceId } });
                        closeWorkspaceModal();
                    };
                    actionsDiv.appendChild(switchBtn);
                }
                
                if (canDelete) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'üóëÔ∏è Eliminar';
                    deleteBtn.style.cssText = 'background: #ef4444; color: white; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;';
                    deleteBtn.onclick = () => deleteWorkspace(workspaceId);
                    actionsDiv.appendChild(deleteBtn);
                }
                
                // Remove type indicator since we no longer distinguish workspace types
                
                workspaceDiv.appendChild(nameSpan);
                workspaceDiv.appendChild(actionsDiv);
                container.appendChild(workspaceDiv);
            });
            
            if (Object.keys(userWorkspaces).length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 20px;">No hay workspaces disponibles</div>';
            }
        }

        function closeWorkspaceModal() {
            document.getElementById('workspaceModal').style.display = 'none';
            document.getElementById('newWorkspaceName').value = '';
        }

        // Function to dynamically assign emoji based on workspace name
        function getWorkspaceEmoji(name) {
            const lowerName = name.toLowerCase();
            
            // Work/Business related
            if (lowerName.includes('work') || lowerName.includes('office') || lowerName.includes('business') || lowerName.includes('company')) return 'üíº';
            if (lowerName.includes('team') || lowerName.includes('group') || lowerName.includes('squad')) return 'üë•';
            if (lowerName.includes('project') || lowerName.includes('task') || lowerName.includes('plan')) return 'üìã';
            if (lowerName.includes('meeting') || lowerName.includes('agenda')) return 'üóìÔ∏è';
            
            // Personal/Family
            if (lowerName.includes('personal') || lowerName.includes('private') || lowerName.includes('my')) return 'üë§';
            if (lowerName.includes('family') || lowerName.includes('home') || lowerName.includes('house')) return 'üè†';
            if (lowerName.includes('kids') || lowerName.includes('children') || lowerName.includes('baby')) return 'üë∂';
            
            // Creative/Hobbies
            if (lowerName.includes('art') || lowerName.includes('design') || lowerName.includes('creative')) return 'üé®';
            if (lowerName.includes('music') || lowerName.includes('song') || lowerName.includes('band')) return 'üéµ';
            if (lowerName.includes('photo') || lowerName.includes('picture') || lowerName.includes('camera')) return 'üì∏';
            if (lowerName.includes('book') || lowerName.includes('read') || lowerName.includes('library')) return 'üìö';
            if (lowerName.includes('game') || lowerName.includes('gaming') || lowerName.includes('play')) return 'üéÆ';
            
            // Health/Fitness
            if (lowerName.includes('health') || lowerName.includes('fitness') || lowerName.includes('gym') || lowerName.includes('workout')) return 'üí™';
            if (lowerName.includes('diet') || lowerName.includes('food') || lowerName.includes('recipe') || lowerName.includes('cooking')) return 'üç≥';
            if (lowerName.includes('doctor') || lowerName.includes('medical') || lowerName.includes('hospital')) return 'üè•';
            
            // Education/Learning
            if (lowerName.includes('school') || lowerName.includes('university') || lowerName.includes('college') || lowerName.includes('study')) return 'üéì';
            if (lowerName.includes('learn') || lowerName.includes('course') || lowerName.includes('lesson') || lowerName.includes('tutorial')) return 'üìñ';
            
            // Travel/Adventure
            if (lowerName.includes('travel') || lowerName.includes('trip') || lowerName.includes('vacation') || lowerName.includes('holiday')) return '‚úàÔ∏è';
            if (lowerName.includes('adventure') || lowerName.includes('explore') || lowerName.includes('journey')) return 'üó∫Ô∏è';
            if (lowerName.includes('car') || lowerName.includes('drive') || lowerName.includes('road')) return 'üöó';
            
            // Technology
            if (lowerName.includes('tech') || lowerName.includes('code') || lowerName.includes('dev') || lowerName.includes('software')) return 'üíª';
            if (lowerName.includes('app') || lowerName.includes('mobile') || lowerName.includes('website')) return 'üì±';
            if (lowerName.includes('data') || lowerName.includes('database') || lowerName.includes('server')) return 'üîß';
            
            // Finance/Money
            if (lowerName.includes('money') || lowerName.includes('budget') || lowerName.includes('finance') || lowerName.includes('bank')) return 'üí∞';
            if (lowerName.includes('investment') || lowerName.includes('stock') || lowerName.includes('trading')) return 'üìà';
            if (lowerName.includes('shopping') || lowerName.includes('buy') || lowerName.includes('purchase')) return 'üõí';
            
            // Nature/Garden
            if (lowerName.includes('garden') || lowerName.includes('plant') || lowerName.includes('flower') || lowerName.includes('green')) return 'üå±';
            if (lowerName.includes('nature') || lowerName.includes('forest') || lowerName.includes('tree')) return 'üå≥';
            if (lowerName.includes('beach') || lowerName.includes('ocean') || lowerName.includes('sea')) return 'üèñÔ∏è';
            
            // Special occasions
            if (lowerName.includes('birthday') || lowerName.includes('party') || lowerName.includes('celebration')) return 'üéâ';
            if (lowerName.includes('wedding') || lowerName.includes('marriage')) return 'üíç';
            if (lowerName.includes('christmas') || lowerName.includes('holiday')) return 'üéÑ';
            
            // Default emojis by first letter
            const firstLetter = name.charAt(0).toLowerCase();
            const letterEmojis = {
                'a': 'üÖ∞Ô∏è', 'b': 'üÖ±Ô∏è', 'c': 'üåô', 'd': 'üíé', 'e': '‚ö°', 'f': 'üî•', 'g': 'üéØ', 'h': '‚ù§Ô∏è', 'i': 'üí°',
                'j': 'üé™', 'k': 'üîë', 'l': 'üíù', 'm': '‚≠ê', 'n': 'üéµ', 'o': 'üåü', 'p': 'üéØ', 'q': 'üëë', 'r': 'üåà',
                's': '‚ú®', 't': 'üåç', 'u': 'ü¶Ñ', 'v': '‚úÖ', 'w': 'üåä', 'x': '‚ùå', 'y': 'üíõ', 'z': '‚ö°'
            };
            
            return letterEmojis[firstLetter] || 'üìÅ';
        }

        async function createWorkspace() {
            const name = document.getElementById('newWorkspaceName').value.trim();
            
            if (!name) {
                alert('Por favor ingresa un nombre para el workspace');
                return;
            }
            
            console.log('üèóÔ∏è Creating new workspace:', name);
            
            try {
                const workspaceId = `workspace_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const emoji = getWorkspaceEmoji(name);
                
                const workspace = {
                    id: workspaceId,
                    name: `${emoji} ${name}`,
                    type: 'workspace',
                    owner: storage.userId,
                    created: new Date().toISOString()
                };
                
                // Add to local workspaces
                userWorkspaces[workspaceId] = workspace;
                
                // Save to localStorage
                localStorage.setItem('userWorkspaces', JSON.stringify(userWorkspaces));
                
                // Save to user's Firebase workspace list
                if (userAuth.getCurrentUser().isLoggedIn) {
                    const userHash = userAuth.getCurrentUser().userHash;
                    const userWorkspaceRef = window.firebaseRef(window.database, `userWorkspaces/${userHash}/workspaces/${workspaceId}`);
                    await window.firebaseSet(userWorkspaceRef, workspace);
                    console.log('üíæ Workspace saved to Firebase');
                }
                
                // Refresh dropdown and switch to new workspace
                renderWorkspaceDropdown();
                switchWorkspace({ target: { value: workspaceId } });
                closeWorkspaceModal();
                
                console.log('‚úÖ Workspace created successfully:', workspaceId);
                
            } catch (error) {
                console.error('‚ùå Error creating workspace:', error);
                alert('Error creando workspace. Intenta nuevamente.');
            }
        }
        
        async function deleteWorkspace(workspaceId) {
            console.log('üóëÔ∏è Delete workspace requested:', workspaceId);
            
            if (!workspaceId || workspaceId === 'personal') {
                alert('No puedes eliminar el workspace principal');
                return;
            }
            
            const workspace = userWorkspaces[workspaceId];
            if (!workspace) {
                alert('Workspace no encontrado');
                return;
            }
            
            const confirmDelete = confirm(`¬øEst√°s seguro de eliminar "${workspace.name}"?\n\nEsta acci√≥n no se puede deshacer y eliminar√° todos los proyectos del workspace.`);
            if (!confirmDelete) return;
            
            try {
                console.log('üóëÔ∏è Proceeding with workspace deletion:', workspaceId);
                
                // Remove from local storage
                delete userWorkspaces[workspaceId];
                localStorage.setItem('userWorkspaces', JSON.stringify(userWorkspaces));
                
                // Remove from Firebase
                if (userAuth.getCurrentUser().isLoggedIn) {
                    const userHash = userAuth.getCurrentUser().userHash;
                    const userWorkspaceRef = window.firebaseRef(window.database, `userWorkspaces/${userHash}/workspaces/${workspaceId}`);
                    await window.firebaseRemove(userWorkspaceRef);
                    
                    // Also remove workspace data
                    const workspaceDataRef = window.firebaseRef(window.database, `workspaces/${workspaceId}`);
                    await window.firebaseRemove(workspaceDataRef);
                    console.log('üóëÔ∏è Workspace data removed from Firebase');
                }
                
                // If currently in deleted workspace, switch to personal
                if (currentWorkspace === workspaceId) {
                    currentWorkspace = 'personal';
                    switchWorkspace({ target: { value: 'personal' } });
                }
                
                renderWorkspaceDropdown();
                console.log('‚úÖ Workspace deleted successfully');
                
            } catch (error) {
                console.error('‚ùå Error deleting workspace:', error);
                alert('Error eliminando workspace. Intenta nuevamente.');
            }
        }

        function clearAllTasks() {
            // Debug: Check current board title before clearing
            const boardTitle = document.getElementById('boardTitle');
            if (boardTitle) {
                console.log('üîç Current board title before clearing:', boardTitle.value);
            }
            
            // Clear all task lists immediately and thoroughly
            const columns = ['todo', 'doing', 'done'];
            
            columns.forEach(column => {
                const taskList = document.getElementById(column + 'List');
                if (taskList) {
                    // Clear all children including tasks and drop indicators
                    while (taskList.firstChild) {
                        taskList.removeChild(taskList.firstChild);
                    }
                    // Double-check with innerHTML clear
                    taskList.innerHTML = '';
                }
            });
            
            // Clear project info
            const currentProjectSpan = document.getElementById('currentProject');
            if (currentProjectSpan) currentProjectSpan.textContent = 'No board';
            
            // Clear board title (text will be set appropriately after loading)
            const boardTitleEl = document.getElementById('boardTitle');
            if (boardTitleEl) {
                console.log('üßπ Clearing board title, was:', boardTitleEl.value);
                boardTitleEl.value = '';
                boardTitleEl.disabled = false; // Reset disabled state
                boardTitleEl.style.color = '#1f2937'; // Reset color
                boardTitleEl.style.fontStyle = 'normal'; // Reset italic
                console.log('üßπ Board title cleared and reset');
            }
            
            console.log('üßπ All tasks and UI elements cleared thoroughly');
        }

        async function switchWorkspace(event) {
            const newWorkspaceId = event.target.value;
            console.log('üè¢ Switching workspace from', currentWorkspace, 'to', newWorkspaceId);
            
            if (newWorkspaceId === currentWorkspace) {
                console.log('üè¢ Same workspace selected, no change needed');
                return;
            }
            
            try {
                // Save current workspace data
                console.log('üíæ Saving current workspace data...');
                await saveData();
                
                // Switch to new workspace
                currentWorkspace = newWorkspaceId;
                
                // Update storage to use workspace-specific data
                storage.workspaceId = currentWorkspace;
                
                // Create new storage manager for new workspace (if using legacy system)
                if (storage instanceof StorageManager) {
                    storage = new StorageManager(currentWorkspace);
                }
                
                // Clear current data and UI immediately
                console.log('üóëÔ∏è Clearing current data and UI...');
                projects = {};
                currentProject = null;
                projectTrash = [];
                
                // Clear all tasks from UI immediately
                clearAllTasks();
                
                // Load new workspace data
                console.log('üì• Loading new workspace data...');
                await loadData();
                
                // Force UI refresh
                console.log('üîÑ Refreshing UI...');
                renderProjects();
                
                // Switch to first available project or handle empty workspace
                if (Object.keys(projects).length > 0) {
                    const firstProject = Object.keys(projects)[0];
                    console.log('üéØ Switching to board:', firstProject);
                    switchProject(firstProject);
                } else {
                    console.log('üìù Empty workspace - showing create board message');
                    // Set appropriate message for empty workspace
                    const boardTitleEl2 = document.getElementById('boardTitle');
                    if (boardTitleEl2) {
                        boardTitleEl2.value = 'Please, create a Board';
                        boardTitleEl2.disabled = true;
                        boardTitleEl2.style.color = '#6b7280';
                        boardTitleEl2.style.fontStyle = 'italic';
                        console.log('‚úÖ Empty workspace - Board title set to:', boardTitleEl2.value);
                    }
                }
                
                console.log('‚úÖ Workspace switch completed');
                
                console.log(`‚úÖ Switched to workspace: ${userWorkspaces[currentWorkspace]?.name}`);
                
            } catch (error) {
                console.error('‚ùå Error switching workspace:', error);
                // Revert dropdown selection
                document.getElementById('workspaceSelect').value = currentWorkspace;
            }
        }

        // Add event listener for workspace dropdown
        document.getElementById('workspaceSelect').addEventListener('change', switchWorkspace);
        console.log('üéØ Workspace dropdown event listener added');

        // Initialize the application with password protection
        console.log('üöÄ Starting app initialization...');
        
        // Check for workspace in URL
        const urlParams = new URLSearchParams(window.location.search);
        const workspaceFromUrl = urlParams.get('workspace');
        if (workspaceFromUrl) {
            currentWorkspace = workspaceFromUrl;
            storage.workspaceId = currentWorkspace;
            
            // Add workspace to user's list if not already there
            if (!userWorkspaces[workspaceFromUrl]) {
                const emoji = getWorkspaceEmoji('Workspace');
                userWorkspaces[workspaceFromUrl] = {
                    id: workspaceFromUrl,
                    name: `${emoji} Workspace`,
                    type: 'workspace',
                    owner: storage.userId,
                    joined: new Date().toISOString()
                };
                localStorage.setItem('userWorkspaces', JSON.stringify(userWorkspaces));
                renderWorkspaceDropdown();
            }
        }
        
        // Wait for Firebase to be properly initialized
        function waitForFirebase() {
            if (window.database && window.firebaseGet && window.firebaseSet && window.firebaseUpdate) {
                console.log('üî• Firebase fully ready, initializing authentication...');
                initializePasswordProtection();
            } else {
                console.log('‚è≥ Waiting for Firebase initialization...');
                setTimeout(waitForFirebase, 500);
            }
        }
        
        // Start checking for Firebase readiness
        setTimeout(waitForFirebase, 100);
    </script>
</body>
</html>
