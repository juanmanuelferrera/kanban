<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanban Board</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, get, onValue, push, remove } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAAOyqnAE-9lFAsni2_AoDXK0Y7Aekg-t4",
            authDomain: "ultra-kanban.firebaseapp.com",
            databaseURL: "https://ultra-kanban-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "ultra-kanban",
            storageBucket: "ultra-kanban.firebasestorage.app",
            messagingSenderId: "190342751802",
            appId: "1:190342751802:web:5eb977207734bd6f187703"
        };
        
        // Initialize Firebase
        window.firebaseApp = initializeApp(firebaseConfig);
        window.database = getDatabase(window.firebaseApp);
        window.firebaseRef = ref;
        window.firebaseSet = set;
        window.firebaseGet = get;
        window.firebaseOnValue = onValue;
        window.firebasePush = push;
        window.firebaseRemove = remove;
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #ffffff;
            min-height: 100vh;
            display: flex;
            color: #1f2937;
        }

        .sidebar {
            width: 200px;
            background: #f8fafc;
            border-right: 1px solid #e5e7eb;
            padding: 14px;
            display: flex;
            flex-direction: column;
        }

        .sidebar h2 {
            color: #1f2937;
            margin-bottom: 20px;
            font-size: 20px;
            font-family: 'Playfair Display', serif;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .project-list {
            flex: 1;
            overflow-y: auto;
            min-height: 200px;
        }

        .project-item {
            background: #ffffff !important;
            border-radius: 6px;
            padding: 4px 7px;
            margin-bottom: 3px;
            cursor: grab;
            transition: all 0.3s ease;
            color: #000000 !important;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            text-transform: uppercase !important;
            font-weight: 700 !important;
            letter-spacing: -0.6px;
            font-size: 10px !important;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif !important;
            text-shadow: none !important;
            -webkit-text-fill-color: #000000 !important;
            opacity: 1 !important;
            font-stretch: condensed;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .project-item:active {
            cursor: grabbing;
        }

        .project-item.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .project-item.drag-over {
            border-top: 3px solid #3b82f6;
        }

        .project-item:hover {
            background: #f9fafb;
            border-color: #d1d5db;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            color: #111827;
        }

        .project-item.active {
            background: #f3f4f6;
            border-color: #9ca3af;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            color: #000000;
        }

        .add-project {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            color: #374151;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            margin-top: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .add-project:hover {
            background: #f9fafb;
            border-color: #d1d5db;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .main-content {
            flex: 1;
            padding: 5px 30px;
            display: flex;
            flex-direction: column;
            min-width: 0;
            width: 100%;
            height: 100vh;
            box-sizing: border-box;
            overflow-x: auto;
        }

        .header {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .board-title {
            font-size: 28px;
            font-weight: bold;
            color: white;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            padding: 8px 0;
            margin-right: 15px;
            min-width: 200px;
            outline: none;
        }

        .board-title:hover,
        .board-title:focus {
            border-bottom-color: rgba(255, 255, 255, 0.5);
        }

        .project-info {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            margin-left: auto;
        }

        .kanban-board {
            display: grid;
            grid-template-columns: repeat(3, minmax(320px, 400px));
            gap: 20px;
            flex: 1;
            width: 100%;
            max-width: 1300px;
            margin: 0 auto;
            align-items: stretch;
            justify-content: center;
            padding: 0 20px;
            box-sizing: border-box;
            height: 100%;
        }

        .column {
            background: #ffffff;
            border-radius: 12px;
            padding: 24px;
            height: 100%;
            width: 100%;
            border: 1px solid #e5e7eb;
            position: relative;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .column.todo {
            background: linear-gradient(to bottom, #ffffff 0%, #eff6ff 100%);
            border-left: 4px solid #3b82f6;
        }

        .column.doing {
            background: linear-gradient(to bottom, #ffffff 0%, #fef2f2 100%);
            border-left: 4px solid #ef4444;
        }

        .column.done {
            background: linear-gradient(to bottom, #ffffff 0%, #f3f4f6 100%);
            border-left: 4px solid #8b5cf6;
        }


        .column-header {
            font-size: 16px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 20px;
            text-align: left;
            padding: 0;
            background: transparent;
            position: relative;
        }

        .column.todo .column-header {
            color: #1d4ed8;
        }

        .column.doing .column-header {
            color: #dc2626;
        }

        .column.done .column-header {
            color: #7c3aed;
        }

        .sorting-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
        }

        .sort-btn {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 4px 8px;
            color: #374151;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .sort-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        .sort-btn.active {
            background: #f3f4f6;
            border-color: #6b7280;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .project-sorting {
            margin-top: 10px;
            padding: 8px;
            background: #ffffff;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .project-sorting select {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 4px 8px;
            color: #374151;
            font-size: 12px;
            outline: none;
        }

        .project-sorting select option {
            background: #ffffff;
            color: #374151;
        }


        .task-list {
            min-height: 300px;
            padding: 10px 0;
            flex: 1;
            width: 100%;
        }

        .task-item {
            background: #ffffff;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: move;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08), 0 1px 2px rgba(0, 0, 0, 0.04);
            user-select: none;
            border: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
            min-height: 40px;
        }

        .task-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12), 0 2px 4px rgba(0, 0, 0, 0.08);
        }

        .task-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .task-content {
            flex: 1;
            background: transparent;
            border: none;
            font-size: 14px;
            line-height: 1.4;
            outline: none;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 6px;
            transition: all 0.2s ease;
            min-height: 22px;
            color: #374151;
            font-weight: 400;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            word-break: break-word;
            max-height: 2.8em;
        }

        .task-content:hover {
            overflow: visible;
            display: block;
            max-height: none;
            -webkit-line-clamp: none;
            background: rgba(0, 0, 0, 0.03);
            z-index: 10;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            white-space: pre-wrap;
        }

        .task-content a {
            color: #3b82f6;
            text-decoration: underline;
            cursor: pointer;
        }

        .task-content a:hover {
            color: #1d4ed8;
            text-decoration: none;
        }


        .task-content:focus {
            background: #f3f4f6;
            cursor: text;
            border: 1px solid #3b82f6;
        }

        .task-item-wrapper {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            width: 100%;
        }

        .task-item.reordering {
            opacity: 0.3;
            transform: scale(0.95);
        }

        .task-list.drag-over-reorder {
            background: rgba(33, 150, 243, 0.1);
            border: 2px dashed rgba(33, 150, 243, 0.5);
        }

        .drop-indicator {
            height: 3px;
            background: #007bff;
            margin: 2px 0;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .drop-indicator.active {
            opacity: 1;
        }

        .task-content.copied {
            background: #dcfce7;
            transform: scale(1.02);
        }

        .copy-feedback {
            position: absolute;
            background: #16a34a;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }

        .copy-feedback.show {
            opacity: 1;
            transform: translateY(-20px);
        }

        .task-checkbox {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            cursor: pointer;
            accent-color: #007bff;
        }

        .task-item.selected {
            background: rgba(33, 150, 243, 0.1);
            border: 2px solid rgba(33, 150, 243, 0.5);
        }

        .multi-select-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px 20px;
            display: none;
            gap: 10px;
            align-items: center;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .multi-select-controls.show {
            display: flex;
        }

        .multi-select-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            margin: 0 2px;
        }

        .multi-select-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .multi-select-btn.danger {
            background: rgba(244, 67, 54, 0.8);
            border-color: rgba(244, 67, 54, 1);
        }

        .multi-select-btn.danger:hover {
            background: rgba(244, 67, 54, 1);
        }

        .multi-select-info {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            margin-right: 10px;
        }

        .column-header {
            position: relative;
        }

        .select-all-checkbox {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: white;
        }

        .column.drag-over {
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .todo-column.drag-over {
            background: linear-gradient(to bottom,
                rgba(244, 67, 54, 0.25) 0%,
                rgba(255, 152, 0, 0.2) 100%);
        }

        .doing-column.drag-over {
            background: linear-gradient(to bottom,
                rgba(255, 193, 7, 0.25) 0%,
                rgba(255, 235, 59, 0.2) 100%);
        }

        .done-column.drag-over {
            background: linear-gradient(to bottom,
                rgba(76, 175, 80, 0.25) 0%,
                rgba(139, 195, 74, 0.2) 100%);
        }

        .add-task {
            background: transparent;
            border: 2px dashed #d1d5db;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            cursor: pointer;
            color: #6b7280;
            transition: all 0.2s ease;
            margin-top: 12px;
            font-size: 14px;
            font-weight: 500;
        }

        .add-task:hover {
            background: #f9fafb;
            border-color: #9ca3af;
            color: #374151;
        }

        .task-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: #ffffff;
            margin-bottom: 10px;
            outline: none;
            color: #374151;
            font-size: 14px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .task-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn:hover {
            transform: translateY(-1px);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        .modal input {
            width: 100%;
            padding: 12px;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
        }

        .delete-task {
            background: transparent;
            border: none;
            border-radius: 6px;
            padding: 4px 6px;
            color: #9ca3af;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
            opacity: 0;
        }

        .task-item:hover .delete-task {
            opacity: 1;
        }

        .delete-task:hover {
            background: #fef2f2;
            color: #ef4444;
        }

        .project-name {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            font-size: 14px;
            outline: none;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 4px;
            transition: all 0.3s ease;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .project-name:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .project-name:focus {
            background: rgba(255, 255, 255, 0.2);
            cursor: text;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .project-item-content {
            display: flex;
            align-items: center;
            gap: 4px;
            justify-content: space-between;
            width: 100%;
        }

        .project-context-menu {
            position: fixed;
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            padding: 4px 0;
            z-index: 1000;
            display: none;
            min-width: 150px;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #374151;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #f3f4f6;
        }

        .context-menu-item.duplicate {
            color: #059669;
        }

        .context-menu-item.delete {
            color: #dc2626;
        }

        .context-menu-item.delete:hover {
            background: #fef2f2;
        }

        .trash-item {
            background: #fef2f2;
            border-radius: 6px;
            padding: 6px;
            margin-bottom: 3px;
            font-size: 11px;
            color: #6b7280;
            border: 1px solid #fca5a5;
            cursor: pointer;
        }

        .trash-item:hover {
            background: #fee2e2;
            color: #dc2626;
        }

        .trash-item-name {
            font-weight: 600;
            color: #dc2626;
        }


        .task-count {
            background: #ef4444 !important;
            color: white !important;
            border-radius: 12px;
            padding: 2px 6px;
            font-size: 10px;
            font-weight: bold;
            min-width: 18px;
            text-align: center;
            margin-left: auto;
            flex-shrink: 0;
            display: inline-block;
            line-height: 1.2;
        }

        .task-count.zero {
            background: #10b981 !important;
            color: white !important;
        }

        .backup-controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e5e7eb;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }

        .backup-btn {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 8px 6px;
            color: #374151;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 4px;
            min-height: 32px;
            text-align: center;
            font-weight: 500;
        }

        .backup-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        .backup-status {
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            margin-top: 5px;
            text-align: center;
        }

        .import-input {
            display: none;
        }

        .password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
        }

        .password-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .password-container h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 24px;
        }

        .password-container p {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .password-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 20px;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .password-input:focus {
            border-color: #667eea;
        }

        .password-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            padding: 15px 30px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .password-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }

        .password-error {
            color: #e74c3c;
            margin-top: 15px;
            font-size: 14px;
            display: none;
        }

        .password-setup {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .password-setup h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .app-content {
            display: none;
            height: 100vh;
            overflow: hidden;
        }

        .app-content.unlocked {
            display: flex;
            height: 100vh;
        }

        @media (max-width: 1200px) {
            .kanban-board {
                grid-template-columns: repeat(3, 1fr);
                gap: 16px;
                padding: 0 12px;
            }
        }

        @media (max-width: 968px) {
            .kanban-board {
                grid-template-columns: repeat(3, 1fr);
                gap: 12px;
            }
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: auto;
                max-height: 200px;
            }

            .kanban-board {
                grid-template-columns: 1fr;
                gap: 16px;
                padding: 0 12px;
            }

            .main-content {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <!-- Password Protection Overlay -->
    <div class="password-overlay" id="passwordOverlay">
        <div class="password-container">
            <h1>üîí Ultra Kanban</h1>
            <p>Ingresa la contrase√±a para acceder a tus proyectos</p>

            <div id="loginForm">
                <input type="password" class="password-input" id="passwordInput" placeholder="Contrase√±a" autocomplete="current-password">
                <button class="password-btn" onclick="checkPassword()">Ingresar</button>
                <div class="password-error" id="passwordError">Contrase√±a incorrecta</div>
            </div>

            <div class="password-setup" id="setupForm" style="display: none;">
                <h3>Configurar Contrase√±a</h3>
                <p>Es la primera vez que accedes. Establece una contrase√±a:</p>
                <input type="password" class="password-input" id="newPasswordInput" placeholder="Nueva contrase√±a" autocomplete="new-password">
                <input type="password" class="password-input" id="confirmPasswordInput" placeholder="Confirmar contrase√±a" autocomplete="new-password">
                <button class="password-btn" onclick="setupPassword()">Establecer Contrase√±a</button>
                <div class="password-error" id="setupError">Las contrase√±as no coinciden</div>
            </div>
        </div>
    </div>

    <!-- Main Application Content -->
    <div class="app-content" id="appContent">
        <div class="sidebar">
        <h2>Ultra Kanban</h2>
        <div class="project-list" id="projectList">
            <div class="project-item active" data-project="default">
                Default Project
            </div>
        </div>
        <button class="add-project" onclick="createProject()">+ Add Project</button>

        <div class="trash-section" id="trashSection" style="display: none;">
            <h3 style="color: #6b7280; font-size: 12px; margin: 10px 0 5px 0; text-transform: uppercase;">Trash</h3>
            <div class="trash-list" id="trashList"></div>
            <button class="empty-trash-btn" onclick="emptyTrash()" style="background: #fef2f2; border: 1px solid #fca5a5; color: #dc2626; padding: 6px 12px; border-radius: 6px; font-size: 11px; width: 100%; margin-top: 5px;">Empty Trash</button>
        </div>

        <div class="backup-controls">
            <button class="backup-btn" onclick="exportData()">
                <span style="font-size: 12px;">üì•</span>
                Export
            </button>
            <button class="backup-btn" onclick="document.getElementById('importInput').click()">
                <span style="font-size: 12px;">üì§</span>
                Import
            </button>
            <button class="backup-btn" onclick="document.getElementById('tasksImportInput').click()">
                <span style="font-size: 12px;">üìù</span>
                Tasks
            </button>
            <button class="backup-btn" onclick="createBackup()">
                <span style="font-size: 12px;">üíæ</span>
                Backup
            </button>
            <div class="backup-status" id="backupStatus" style="grid-column: 1 / -1; text-align: center; margin-top: 4px; color: #6b7280; font-size: 9px;">Auto-saving...</div>
            <input type="file" id="importInput" class="import-input" accept=".json" onchange="importData(event)">
            <input type="file" id="tasksImportInput" class="import-input" accept=".txt,.md" onchange="importTasksFromFile(event)">
            <button class="backup-btn" onclick="lockApp()" style="background: #fef2f2; border-color: #fca5a5; color: #dc2626; grid-column: 1 / -1; margin-top: 4px;">
                <span style="font-size: 12px;">üîí</span>
                Logout
            </button>
        </div>
    </div>

    <div class="main-content">
        <div class="header">
            <input type="text" class="board-title" id="boardTitle" value="My Kanban Board" placeholder="Enter board title...">
            <div class="project-info">
                Project: <span id="currentProject">Default Project</span>
            </div>
        </div>

        <div class="kanban-board">
            <div class="column todo" data-column="todo">
                <div class="column-header">TO DO</div>
                <div class="task-list" id="todoList"></div>
                <div class="add-task" onclick="showAddTaskModal('todo')">+ Add Task</div>
            </div>

            <div class="column doing" data-column="doing">
                <div class="column-header">DOING</div>
                <div class="task-list" id="doingList"></div>
            </div>

            <div class="column done" data-column="done">
                <div class="column-header">DONE</div>
                <div class="task-list" id="doneList"></div>
            </div>
        </div>
    </div>

    <!-- Context Menu for Projects -->
    <div class="project-context-menu" id="projectContextMenu">
        <div class="context-menu-item duplicate" onclick="duplicateProjectFromMenu()">
            <span>üìÑ</span> Duplicate Project
        </div>
        <div class="context-menu-item delete" onclick="deleteProjectFromMenu()">
            <span>üóëÔ∏è</span> Move to Trash
        </div>
    </div>

    <!-- Context Menu for Trash Items -->
    <div class="project-context-menu" id="trashContextMenu">
        <div class="context-menu-item" onclick="restoreProjectFromMenu()">
            <span>‚Ü©Ô∏è</span> Restore Project
        </div>
        <div class="context-menu-item delete" onclick="permanentDeleteFromMenu()">
            <span>‚ùå</span> Delete Permanently
        </div>
    </div>

    <div class="modal" id="taskModal">
        <div class="modal-content">
            <h3>Add New Task</h3>
            <input type="text" id="taskInput" placeholder="Enter task description...">
            <div class="task-actions">
                <button class="btn btn-primary" onclick="addTask()">Add Task</button>
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="projectModal">
        <div class="modal-content">
            <h3>Create New Project</h3>
            <input type="text" id="projectInput" placeholder="Enter project name...">
            <div class="task-actions">
                <button class="btn btn-primary" onclick="addProject()">Create Project</button>
                <button class="btn btn-secondary" onclick="closeProjectModal()">Cancel</button>
            </div>
        </div>
    </div>
    </div> <!-- Close app-content -->

    <script>
        let currentProject = 'default';
        let currentColumn = '';
        let draggedTask = null;

        // Data version for migration support
        const DATA_VERSION = '1.1.0';
        const BACKUP_PREFIX = 'kanban_backup_';
        const MAX_BACKUPS = 10;

        let projects = {
            'default': {
                name: 'Default Project',
                title: 'My Kanban Board',
                sortingMode: 'free', // free, alphabetical, newest-first, oldest-first
                tasks: {
                    todo: [],
                    doing: [],
                    done: []
                },
                taskMetadata: {
                    todo: [],
                    doing: [],
                    done: []
                }
            }
        };

        // Project trash for recovery
        let projectTrash = [];

        // Firebase Storage Management System
        class FirebaseStorageManager {
            constructor() {
                this.userId = 'user_' + this.generateUserId(); // Simple user ID for demo
                this.isOnline = navigator.onLine;
                this.initializeOfflineSupport();
            }

            generateUserId() {
                // Check URL for shared user ID first
                const urlParams = new URLSearchParams(window.location.search);
                const sharedUserId = urlParams.get('user');
                
                if (sharedUserId) {
                    localStorage.setItem('kanbanUserId', sharedUserId);
                    return sharedUserId;
                }
                
                // Check localStorage
                let userId = localStorage.getItem('kanbanUserId');
                if (!userId) {
                    // Generate new user ID
                    userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('kanbanUserId', userId);
                    
                    // Show sharing info
                    this.showSharingInfo(userId);
                }
                return userId;
            }
            
            showSharingInfo(userId) {
                const shareUrl = window.location.origin + window.location.pathname + '?user=' + userId;
                console.log('üîó Share this URL to sync across devices:', shareUrl);
                
                // Show notification with share URL
                setTimeout(() => {
                    const notification = document.createElement('div');
                    notification.innerHTML = `
                        üîó <strong>Share URL:</strong><br>
                        <input type="text" value="${shareUrl}" readonly style="width: 100%; margin-top: 5px; padding: 5px; font-size: 10px; border: 1px solid #ccc; border-radius: 4px;" onclick="this.select()">
                        <br><small>Copy this URL to sync the same data on other devices</small>
                    `;
                    notification.style.cssText = `
                        position: fixed;
                        top: 70px;
                        right: 20px;
                        background: #3b82f6;
                        color: white;
                        padding: 15px;
                        border-radius: 8px;
                        font-size: 12px;
                        z-index: 10000;
                        max-width: 300px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    `;
                    
                    document.body.appendChild(notification);
                    
                    // Auto-hide after 10 seconds
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 10000);
                }, 2000);
            }

            initializeOfflineSupport() {
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    this.syncOfflineChanges();
                });
                window.addEventListener('offline', () => {
                    this.isOnline = false;
                });
            }

            async save() {
                const data = {
                    version: '1.0.0',
                    projects: projects,
                    currentProject: currentProject,
                    projectTrash: projectTrash || [],
                    timestamp: new Date().toISOString()
                };

                const success = { firebase: false, localStorage: false };

                // Always save to localStorage as backup
                try {
                    localStorage.setItem('kanbanProjects', JSON.stringify(data.projects));
                    localStorage.setItem('currentProject', data.currentProject);
                    localStorage.setItem('kanbanVersion', data.version);
                    localStorage.setItem('projectTrash', JSON.stringify(data.projectTrash));
                    success.localStorage = true;
                } catch (error) {
                    console.error('localStorage save failed:', error);
                }

                // Save to Firebase if online
                if (this.isOnline && window.database) {
                    try {
                        const userRef = window.firebaseRef(window.database, `users/${this.userId}`);
                        await window.firebaseSet(userRef, data);
                        success.firebase = true;
                        console.log('Data saved to Firebase successfully');
                    } catch (error) {
                        console.error('Firebase save failed:', error);
                        // Mark for offline sync
                        localStorage.setItem('kanbanPendingSync', 'true');
                    }
                }

                this.updateBackupStatus(success);
                return success;
            }

            async load() {
                let data = null;

                // Try to load from Firebase first if online
                if (this.isOnline && window.database) {
                    try {
                        const userRef = window.firebaseRef(window.database, `users/${this.userId}`);
                        const snapshot = await window.firebaseGet(userRef);
                        if (snapshot.exists()) {
                            data = snapshot.val();
                            console.log('Data loaded from Firebase successfully');
                            
                            // Setup real-time listener
                            this.setupRealtimeListener();
                        }
                    } catch (error) {
                        console.error('Firebase load failed:', error);
                    }
                }

                // Fallback to localStorage
                if (!data) {
                    try {
                        const savedProjects = localStorage.getItem('kanbanProjects');
                        const savedCurrentProject = localStorage.getItem('currentProject');
                        const savedVersion = localStorage.getItem('kanbanVersion');
                        const savedTrash = localStorage.getItem('projectTrash');

                        if (savedProjects) {
                            data = {
                                version: savedVersion || '1.0.0',
                                projects: JSON.parse(savedProjects),
                                currentProject: savedCurrentProject || 'default',
                                projectTrash: savedTrash ? JSON.parse(savedTrash) : [],
                                timestamp: new Date().toISOString()
                            };
                            console.log('Data loaded from localStorage');
                        }
                    } catch (error) {
                        console.error('localStorage load failed:', error);
                        data = null;
                    }
                }

                return data;
            }

            setupRealtimeListener() {
                if (!window.database) return;

                const userRef = window.firebaseRef(window.database, `users/${this.userId}`);
                window.firebaseOnValue(userRef, (snapshot) => {
                    if (snapshot.exists()) {
                        const data = snapshot.val();
                        // Only update if the data is newer
                        const localTimestamp = localStorage.getItem('lastSyncTimestamp') || '0';
                        if (data.timestamp > localTimestamp) {
                            projects = data.projects;
                            currentProject = data.currentProject;
                            projectTrash = data.projectTrash || [];
                            
                            // Ensure all projects have proper structure
                            Object.keys(projects).forEach(projectId => {
                                projects[projectId] = ensureProjectStructure(projects[projectId]);
                            });
                            
                            // Update UI
                            renderProjects();
                            renderTasks();
                            
                            localStorage.setItem('lastSyncTimestamp', data.timestamp);
                            console.log('Real-time update received from Firebase');
                            
                            // Show sync notification
                            this.showSyncNotification('Data synced from cloud');
                        }
                    }
                });
            }

            async syncOfflineChanges() {
                const hasPendingSync = localStorage.getItem('kanbanPendingSync');
                if (hasPendingSync && window.database) {
                    try {
                        await this.save();
                        localStorage.removeItem('kanbanPendingSync');
                        this.showSyncNotification('Offline changes synced');
                    } catch (error) {
                        console.error('Failed to sync offline changes:', error);
                    }
                }
            }

            showSyncNotification(message) {
                const notification = document.createElement('div');
                notification.textContent = `üîÑ ${message}`;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #3b82f6;
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-size: 14px;
                    z-index: 10000;
                    opacity: 0;
                    transform: translateY(-10px);
                    transition: all 0.3s ease;
                `;
                
                document.body.appendChild(notification);
                
                // Animate in
                setTimeout(() => {
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateY(0)';
                }, 100);
                
                // Remove after 3 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateY(-10px)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }

            updateBackupStatus(success) {
                const statusEl = document.getElementById('backupStatus');
                if (!statusEl) return;

                const now = new Date().toLocaleTimeString();

                if (success.firebase && success.localStorage) {
                    statusEl.textContent = `‚òÅÔ∏è Synced at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.firebase) {
                    statusEl.textContent = `‚òÅÔ∏è Cloud saved at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.localStorage) {
                    statusEl.textContent = `üíæ Local saved at ${now}`;
                    statusEl.style.color = 'rgba(255, 193, 7, 0.8)';
                } else {
                    statusEl.textContent = `‚ùå Save failed at ${now}`;
                    statusEl.style.color = 'rgba(244, 67, 54, 0.8)';
                }

                setTimeout(() => {
                    if (this.isOnline) {
                        statusEl.textContent = '‚òÅÔ∏è Auto-syncing...';
                    } else {
                        statusEl.textContent = 'üíæ Offline mode...';
                    }
                    statusEl.style.color = 'rgba(255, 255, 255, 0.7)';
                }, 3000);
            }

            // Export data to JSON file
            exportData() {
                const data = {
                    version: '1.0.0',
                    projects: projects,
                    currentProject: currentProject,
                    projectTrash: projectTrash || [],
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ultra-kanban-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.updateBackupStatus({ export: true, import: false });
            }

            // Import data from JSON file
            async importData(file) {
                try {
                    const text = await file.text();
                    const importedData = JSON.parse(text);

                    if (!this.validateData(importedData)) {
                        throw new Error('Invalid data format');
                    }

                    // Update global variables
                    projects = importedData.projects;
                    currentProject = importedData.currentProject;
                    projectTrash = importedData.projectTrash || [];

                    // Ensure all projects have proper structure
                    Object.keys(projects).forEach(projectId => {
                        projects[projectId] = ensureProjectStructure(projects[projectId]);
                    });

                    // Save to Firebase and localStorage
                    await this.save();

                    // Update UI
                    renderProjects();
                    renderTasks();
                    renderTrash();
                    switchProject(currentProject);

                    this.updateBackupStatus({ export: false, import: true });
                    this.showSyncNotification('Data imported successfully');

                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Import failed: ' + error.message);
                }
            }

            // Validate imported data structure
            validateData(data) {
                if (!data || typeof data !== 'object') return false;
                if (!data.version || !data.projects || !data.currentProject) return false;

                for (const [projectId, project] of Object.entries(data.projects)) {
                    if (!project.name || !project.title) return false;
                    // Don't require tasks structure as we can fix it with ensureProjectStructure
                }

                return true;
            }
        }

        // Legacy Storage Manager (keeping for backward compatibility)
        class StorageManager {
            constructor() {
                this.storageKey = 'kanbanProjects';
                this.currentProjectKey = 'currentProject';
                this.versionKey = 'kanbanVersion';
                this.lastBackupKey = 'lastBackup';
                this.initIndexedDB();
            }

            // Initialize IndexedDB for robust storage
            async initIndexedDB() {
                try {
                    this.db = await new Promise((resolve, reject) => {
                        const request = indexedDB.open('UltraKanbanDB', 1);
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(request.result);
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('projects')) {
                                db.createObjectStore('projects', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('backups')) {
                                const backupStore = db.createObjectStore('backups', { keyPath: 'id' });
                                backupStore.createIndex('timestamp', 'timestamp', { unique: false });
                            }
                        };
                    });
                } catch (error) {
                    console.warn('IndexedDB not available, using localStorage only:', error);
                }
            }

            // Validate data integrity
            validateData(data) {
                if (!data || typeof data !== 'object') return false;
                if (!data.version || !data.projects || !data.currentProject) return false;

                for (const [projectId, project] of Object.entries(data.projects)) {
                    if (!project.name || !project.title || !project.tasks) return false;
                    if (!project.tasks.todo || !project.tasks.doing || !project.tasks.done) return false;
                    if (!Array.isArray(project.tasks.todo) || !Array.isArray(project.tasks.doing) || !Array.isArray(project.tasks.done)) return false;
                }
                return true;
            }

            // Create timestamped data package
            createDataPackage() {
                return {
                    version: DATA_VERSION,
                    timestamp: new Date().toISOString(),
                    projects: structuredClone(projects),
                    currentProject: currentProject,
                    projectTrash: structuredClone(projectTrash),
                    metadata: {
                        totalProjects: Object.keys(projects).length,
                        totalTasks: Object.values(projects).reduce((sum, p) =>
                            sum + p.tasks.todo.length + p.tasks.doing.length + p.tasks.done.length, 0),
                        trashedProjects: projectTrash.length
                    }
                };
            }

            // Save to multiple storage backends
            async save() {
                const data = this.createDataPackage();
                const success = { localStorage: false, indexedDB: false };

                // Save to localStorage
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(data.projects));
                    localStorage.setItem(this.currentProjectKey, data.currentProject);
                    localStorage.setItem(this.versionKey, data.version);
                    localStorage.setItem(this.lastBackupKey, data.timestamp);
                    success.localStorage = true;
                } catch (error) {
                    console.error('localStorage save failed:', error);
                }

                // Save to IndexedDB
                if (this.db) {
                    try {
                        const transaction = this.db.transaction(['projects'], 'readwrite');
                        const store = transaction.objectStore('projects');
                        await store.put({ id: 'main', data: data });
                        success.indexedDB = true;
                    } catch (error) {
                        console.error('IndexedDB save failed:', error);
                    }
                }

                this.updateBackupStatus(success);
                return success;
            }

            // Load from storage with fallback
            async load() {
                let data = null;

                // Try IndexedDB first
                if (this.db) {
                    try {
                        const transaction = this.db.transaction(['projects'], 'readonly');
                        const store = transaction.objectStore('projects');
                        const result = await store.get('main');
                        if (result && result.data && this.validateData(result.data)) {
                            data = result.data;
                        }
                    } catch (error) {
                        console.warn('IndexedDB load failed:', error);
                    }
                }

                // Fallback to localStorage
                if (!data) {
                    try {
                        const savedProjects = localStorage.getItem(this.storageKey);
                        const savedCurrentProject = localStorage.getItem(this.currentProjectKey);
                        const savedVersion = localStorage.getItem(this.versionKey);

                        if (savedProjects) {
                            data = {
                                version: savedVersion || '1.0.0',
                                projects: JSON.parse(savedProjects),
                                currentProject: savedCurrentProject || 'default',
                                timestamp: localStorage.getItem(this.lastBackupKey) || new Date().toISOString()
                            };

                            if (!this.validateData(data)) {
                                throw new Error('Data validation failed');
                            }
                        }
                    } catch (error) {
                        console.error('localStorage load failed:', error);
                        data = null;
                    }
                }

                return data;
            }

            // Create backup in IndexedDB
            async createBackup() {
                if (!this.db) return false;

                try {
                    const data = this.createDataPackage();
                    const transaction = this.db.transaction(['backups'], 'readwrite');
                    const store = transaction.objectStore('backups');

                    const backupId = `backup_${Date.now()}`;
                    await store.put({
                        id: backupId,
                        timestamp: data.timestamp,
                        data: data
                    });

                    // Clean old backups
                    await this.cleanOldBackups();
                    return true;
                } catch (error) {
                    console.error('Backup creation failed:', error);
                    return false;
                }
            }

            // Clean old backups (keep only MAX_BACKUPS)
            async cleanOldBackups() {
                if (!this.db) return;

                try {
                    const transaction = this.db.transaction(['backups'], 'readwrite');
                    const store = transaction.objectStore('backups');
                    const index = store.index('timestamp');

                    const allBackups = await index.getAll();
                    if (allBackups.length > MAX_BACKUPS) {
                        const toDelete = allBackups
                            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
                            .slice(0, allBackups.length - MAX_BACKUPS);

                        for (const backup of toDelete) {
                            await store.delete(backup.id);
                        }
                    }
                } catch (error) {
                    console.error('Backup cleanup failed:', error);
                }
            }

            // Export data as JSON file
            exportData() {
                const data = this.createDataPackage();
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ultra-kanban-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.updateBackupStatus({ export: true });
            }

            // Import data from JSON file
            async importData(file) {
                try {
                    const text = await file.text();
                    const importedData = JSON.parse(text);

                    if (!this.validateData(importedData)) {
                        throw new Error('Invalid data format');
                    }

                    // Create backup before import
                    await this.createBackup();

                    // Apply imported data
                    projects = importedData.projects;
                    currentProject = importedData.currentProject || 'default';

                    // Save and render
                    await this.save();
                    renderProjects();
                    switchProject(currentProject);

                    this.updateBackupStatus({ import: true });
                    return true;
                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Import failed: ' + error.message);
                    return false;
                }
            }

            // Update backup status display
            updateBackupStatus(success) {
                const statusEl = document.getElementById('backupStatus');
                const now = new Date().toLocaleTimeString();

                if (success.export) {
                    statusEl.textContent = `Exported at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.import) {
                    statusEl.textContent = `Imported at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.localStorage && success.indexedDB) {
                    statusEl.textContent = `All saved at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.localStorage || success.indexedDB) {
                    statusEl.textContent = `Partial save at ${now}`;
                    statusEl.style.color = 'rgba(255, 193, 7, 0.8)';
                } else {
                    statusEl.textContent = `Save failed at ${now}`;
                    statusEl.style.color = 'rgba(244, 67, 54, 0.8)';
                }

                setTimeout(() => {
                    statusEl.textContent = 'Auto-saving...';
                    statusEl.style.color = 'rgba(255, 255, 255, 0.7)';
                }, 3000);
            }
        }

        // Initialize storage manager
        const storage = new FirebaseStorageManager();

        // Password Protection System
        class PasswordManager {
            constructor() {
                this.passwordKey = 'ultraKanbanPassword';
                this.sessionKey = 'ultraKanbanSession';
                this.sessionDuration = 365 * 24 * 60 * 60 * 1000; // 1 year
                this.userId = storage.userId; // Use same user ID as storage
            }

            async hashPassword(password) {
                const encoder = new TextEncoder();
                const data = encoder.encode(password + 'ultrakanban_salt');
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            async setPassword(password) {
                const hashedPassword = await this.hashPassword(password);
                
                // Save to both localStorage (for offline) and Firebase (for sync)
                localStorage.setItem(this.passwordKey, hashedPassword);
                
                if (window.database) {
                    try {
                        const passwordRef = window.firebaseRef(window.database, `passwords/${this.userId}`);
                        await window.firebaseSet(passwordRef, {
                            hash: hashedPassword,
                            created: new Date().toISOString()
                        });
                    } catch (error) {
                        console.error('Failed to save password to Firebase:', error);
                    }
                }
            }

            async checkPassword(password) {
                const hashedPassword = await this.hashPassword(password);
                
                // Check Firebase first (for cross-device sync)
                if (window.database) {
                    try {
                        const passwordRef = window.firebaseRef(window.database, `passwords/${this.userId}`);
                        const snapshot = await window.firebaseGet(passwordRef);
                        if (snapshot.exists()) {
                            const data = snapshot.val();
                            return data.hash === hashedPassword;
                        }
                    } catch (error) {
                        console.error('Failed to check password in Firebase:', error);
                    }
                }
                
                // Fallback to localStorage
                const storedHash = localStorage.getItem(this.passwordKey);
                return storedHash === hashedPassword;
            }

            async isPasswordSet() {
                console.log('üîç Checking password for user ID:', this.userId);
                
                // Check Firebase first
                if (window.database) {
                    try {
                        const passwordRef = window.firebaseRef(window.database, `passwords/${this.userId}`);
                        const snapshot = await window.firebaseGet(passwordRef);
                        console.log('üîç Firebase password check:', snapshot.exists() ? 'Password found' : 'No password found');
                        if (snapshot.exists()) {
                            return true;
                        }
                    } catch (error) {
                        console.error('Failed to check if password is set in Firebase:', error);
                    }
                }
                
                // Fallback to localStorage
                const localPassword = localStorage.getItem(this.passwordKey) !== null;
                console.log('üîç Local password check:', localPassword ? 'Password found' : 'No password found');
                return localPassword;
            }

            createSession() {
                const sessionData = {
                    timestamp: Date.now(),
                    expires: Date.now() + this.sessionDuration
                };
                sessionStorage.setItem(this.sessionKey, JSON.stringify(sessionData));
            }

            isSessionValid() {
                const sessionData = sessionStorage.getItem(this.sessionKey);
                if (!sessionData) return false;

                try {
                    const session = JSON.parse(sessionData);
                    return Date.now() < session.expires;
                } catch {
                    return false;
                }
            }

            clearSession() {
                sessionStorage.removeItem(this.sessionKey);
            }
        }

        const passwordManager = new PasswordManager();

        // Password UI Functions
        async function checkPassword() {
            const password = document.getElementById('passwordInput').value;
            const errorDiv = document.getElementById('passwordError');

            if (!password) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Ingresa una contrase√±a';
                return;
            }

            const isValid = await passwordManager.checkPassword(password);
            if (isValid) {
                passwordManager.createSession();
                unlockApp();
            } else {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Contrase√±a incorrecta';
                document.getElementById('passwordInput').value = '';
                document.getElementById('passwordInput').focus();
            }
        }

        async function setupPassword() {
            const newPassword = document.getElementById('newPasswordInput').value;
            const confirmPassword = document.getElementById('confirmPasswordInput').value;
            const errorDiv = document.getElementById('setupError');

            if (!newPassword || newPassword.length < 4) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'La contrase√±a debe tener al menos 4 caracteres';
                return;
            }

            if (newPassword !== confirmPassword) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Las contrase√±as no coinciden';
                return;
            }

            await passwordManager.setPassword(newPassword);
            passwordManager.createSession();
            unlockApp();
        }

        function unlockApp() {
            document.getElementById('passwordOverlay').style.display = 'none';
            document.getElementById('appContent').classList.add('unlocked');
            loadData(); // Load the application data
        }

        function lockApp() {
            passwordManager.clearSession();
            document.getElementById('passwordOverlay').style.display = 'flex';
            document.getElementById('appContent').classList.remove('unlocked');
            document.getElementById('passwordInput').value = '';
            document.getElementById('passwordError').style.display = 'none';
        }

        // Initialize password protection
        async function initializePasswordProtection() {
            if (passwordManager.isSessionValid()) {
                unlockApp();
            } else if (await passwordManager.isPasswordSet()) {
                // Show login form
                document.getElementById('loginForm').style.display = 'block';
                document.getElementById('setupForm').style.display = 'none';
                document.getElementById('passwordInput').focus();
            } else {
                // Show setup form for first-time users
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('setupForm').style.display = 'block';
                document.getElementById('newPasswordInput').focus();
            }
        }

        // Handle Enter key in password inputs
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                if (document.getElementById('passwordInput') === document.activeElement) {
                    checkPassword();
                } else if (document.getElementById('confirmPasswordInput') === document.activeElement ||
                          document.getElementById('newPasswordInput') === document.activeElement) {
                    setupPassword();
                }
            }
        });

        // Load data with enhanced persistence
        // Ensure project has proper structure
        function ensureProjectStructure(project) {
            if (!project.tasks) {
                project.tasks = {
                    todo: [],
                    doing: [],
                    done: []
                };
            }
            if (!project.tasks.todo) project.tasks.todo = [];
            if (!project.tasks.doing) project.tasks.doing = [];
            if (!project.tasks.done) project.tasks.done = [];
            return project;
        }

        async function loadData() {
            try {
                const data = await storage.load();
                if (data) {
                    projects = data.projects;
                    currentProject = data.currentProject;
                    projectTrash = data.projectTrash || [];
                    
                    // Ensure all projects have proper structure
                    Object.keys(projects).forEach(projectId => {
                        projects[projectId] = ensureProjectStructure(projects[projectId]);
                    });
                }
            } catch (error) {
                console.error('Failed to load data:', error);
            }

            renderProjects();
            renderTrash();
            switchProject(currentProject);
        }

        // Save data with enhanced persistence
        async function saveData() {
            try {
                await storage.save();
            } catch (error) {
                console.error('Failed to save data:', error);
            }
        }

        // Auto-save every 30 seconds
        setInterval(saveData, 30000);

        // Save before page unload
        window.addEventListener('beforeunload', saveData);

        // Periodic backup (every 5 minutes)
        setInterval(async () => {
            try {
                await storage.createBackup();
            } catch (error) {
                console.error('Auto-backup failed:', error);
            }
        }, 5 * 60 * 1000);

        // Global functions for UI
        function exportData() {
            storage.exportData();
        }

        function createBackup() {
            storage.createBackup().then(success => {
                if (success) {
                    storage.updateBackupStatus({ export: false, import: false });
                } else {
                    alert('Backup creation failed. Check console for details.');
                }
            });
        }

        function importData(event) {
            const file = event.target.files[0];
            if (file) {
                storage.importData(file);
                event.target.value = ''; // Reset input
            }
        }

        // Import tasks from text file
        async function importTasksFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const lines = text.split(/\r?\n/)
                    .map(line => line.trim())
                    .filter(line => line.length > 0); // Remove empty lines

                if (lines.length === 0) {
                    alert('No valid tasks found in the file.');
                    return;
                }

                // Add tasks to the current project's TODO column
                const addedTasks = [];
                lines.forEach(line => {
                    if (line.length > 0) {
                        projects[currentProject].tasks.todo.push(line);
                        addedTasks.push(line);
                    }
                });

                // Save and refresh the UI
                await saveData();
                renderTasks();

                // Show success feedback
                showTaskImportFeedback(addedTasks.length, file.name);

                // Reset input
                event.target.value = '';

            } catch (error) {
                console.error('Task import failed:', error);
                alert('Failed to import tasks: ' + error.message);
                event.target.value = '';
            }
        }

        // Show feedback for task import
        function showTaskImportFeedback(count, filename) {
            const statusEl = document.getElementById('backupStatus');
            const originalText = statusEl.textContent;
            const originalColor = statusEl.style.color;

            statusEl.textContent = `Imported ${count} tasks from ${filename}`;
            statusEl.style.color = 'rgba(76, 175, 80, 0.8)';

            setTimeout(() => {
                statusEl.textContent = originalText;
                statusEl.style.color = originalColor;
            }, 4000);
        }

        // Render projects in sidebar
        function renderProjects() {
            const projectList = document.getElementById('projectList');
            projectList.innerHTML = '';

            Object.keys(projects).forEach(projectId => {
                const projectDiv = document.createElement('div');
                projectDiv.className = `project-item ${projectId === currentProject ? 'active' : ''}`;
                projectDiv.setAttribute('data-project', projectId);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'project-item-content';

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'project-name';
                nameInput.value = projects[projectId].name;
                nameInput.readOnly = true;
                nameInput.setAttribute('data-project-id', projectId);

                // Double-click to edit
                nameInput.addEventListener('dblclick', () => startEditingProjectName(nameInput, projectId));

                // Handle enter/escape keys
                nameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        finishEditingProjectName(nameInput, projectId);
                    } else if (e.key === 'Escape') {
                        cancelEditingProjectName(nameInput, projectId);
                    }
                });

                // Handle blur (clicking outside)
                nameInput.addEventListener('blur', () => {
                    if (!nameInput.readOnly) {
                        finishEditingProjectName(nameInput, projectId);
                    }
                });

                contentDiv.appendChild(nameInput);

                // Add task count badge
                const taskCount = projects[projectId].tasks?.todo?.length || 0;
                const countBadge = document.createElement('span');
                countBadge.className = `task-count ${taskCount === 0 ? 'zero' : ''}`;
                countBadge.textContent = taskCount;
                countBadge.title = `${taskCount} tareas pendientes`;
                contentDiv.appendChild(countBadge);

                // Add right-click context menu
                projectDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showProjectContextMenu(e, projectId);
                });

                projectDiv.appendChild(contentDiv);

                // Click to switch project (but not when editing)
                // Add drag and drop functionality
                projectDiv.draggable = true;
                projectDiv.addEventListener('dragstart', handleProjectDragStart);
                projectDiv.addEventListener('dragover', handleProjectDragOver);
                projectDiv.addEventListener('drop', handleProjectDrop);
                projectDiv.addEventListener('dragend', handleProjectDragEnd);

                projectDiv.onclick = (e) => {
                    if (e.target === nameInput && !nameInput.readOnly) {
                        return; // Don't switch if editing
                    }
                    if (e.target.className !== 'delete-task') {
                        switchProject(projectId);
                    }
                };

                projectList.appendChild(projectDiv);
            });
        }

        // Project drag and drop functionality
        let draggedProject = null;

        function handleProjectDragStart(e) {
            draggedProject = e.target.getAttribute('data-project');
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleProjectDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            // Remove existing drag-over classes
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('drag-over');
            });

            // Add drag-over class to current target
            const targetProject = e.target.closest('.project-item');
            if (targetProject && targetProject !== e.currentTarget) {
                targetProject.classList.add('drag-over');
            }
        }

        function handleProjectDrop(e) {
            e.preventDefault();
            const targetProjectId = e.target.closest('.project-item').getAttribute('data-project');

            if (draggedProject && targetProjectId && draggedProject !== targetProjectId) {
                reorderProjects(draggedProject, targetProjectId);
            }

            // Clean up
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        function handleProjectDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            draggedProject = null;
        }

        function reorderProjects(draggedId, targetId) {
            const projectKeys = Object.keys(projects);
            const draggedIndex = projectKeys.indexOf(draggedId);
            const targetIndex = projectKeys.indexOf(targetId);

            if (draggedIndex !== -1 && targetIndex !== -1) {
                // Remove dragged project from array
                projectKeys.splice(draggedIndex, 1);
                // Insert at target position
                projectKeys.splice(targetIndex, 0, draggedId);

                // Rebuild projects object in new order
                const reorderedProjects = {};
                projectKeys.forEach(key => {
                    reorderedProjects[key] = projects[key];
                });
                projects = reorderedProjects;

                saveData();
                renderProjects();
            }
        }

        // Switch between projects
        function switchProject(projectId) {
            currentProject = projectId;
            document.getElementById('currentProject').textContent = projects[projectId].name;
            document.getElementById('boardTitle').value = projects[projectId].title;

            // Update active project in sidebar
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelector(`[data-project="${projectId}"]`).classList.add('active');

            // Render tasks for current project
            renderTasks();
            saveData();
        }

        // Render tasks for current project
        function renderTasks() {
            const columns = ['todo', 'doing', 'done'];
            columns.forEach(column => {
                const taskList = document.getElementById(column + 'List');
                taskList.innerHTML = '';

                projects[currentProject].tasks[column].forEach((task, index) => {
                    // Create drop indicator
                    const dropIndicator = document.createElement('div');
                    dropIndicator.className = 'drop-indicator';
                    dropIndicator.setAttribute('data-drop-index', index);
                    dropIndicator.setAttribute('data-column', column);
                    taskList.appendChild(dropIndicator);

                    // Create task item
                    const taskDiv = document.createElement('div');
                    taskDiv.className = 'task-item';
                    taskDiv.draggable = true;
                    taskDiv.setAttribute('data-task-id', index);
                    taskDiv.setAttribute('data-column', column);

                    // Create task wrapper
                    const wrapperDiv = document.createElement('div');
                    wrapperDiv.className = 'task-item-wrapper';

                    // Create editable task content
                    const taskContent = document.createElement('div');
                    taskContent.className = 'task-content';
                    taskContent.contentEditable = false;
                    taskContent.innerHTML = makeURLsClickable(task);
                    taskContent.setAttribute('data-task-id', index);
                    taskContent.setAttribute('data-column', column);

                    // Add single-click to edit and double-click to copy
                    let clickTimer = null;
                    taskContent.addEventListener('click', (e) => {
                        // Prevent editing when dragging
                        if (e.target.closest('.task-item').classList.contains('dragging')) return;

                        if (clickTimer) {
                            // This is a double-click
                            clearTimeout(clickTimer);
                            clickTimer = null;
                            copyTaskText(taskContent);
                        } else {
                            // This might be a single-click, wait to see if double-click follows
                            clickTimer = setTimeout(() => {
                                clickTimer = null;
                                if (taskContent.contentEditable !== 'true') {
                                    startEditingTask(taskContent, column, index);
                                }
                            }, 250);
                        }
                    });

                    // Handle enter/escape keys
                    taskContent.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            finishEditingTask(taskContent, column, index);
                        } else if (e.key === 'Escape') {
                            cancelEditingTask(taskContent, column, index);
                        }
                    });

                    // Handle blur (clicking outside)
                    taskContent.addEventListener('blur', () => {
                        if (taskContent.contentEditable === 'true') {
                            finishEditingTask(taskContent, column, index);
                        }
                    });

                    // Create delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-task';
                    deleteBtn.textContent = '√ó';
                    deleteBtn.onclick = () => deleteTask(column, index);

                    wrapperDiv.appendChild(taskContent);
                    wrapperDiv.appendChild(deleteBtn);
                    taskDiv.appendChild(wrapperDiv);

                    // Add drag event listeners
                    taskDiv.addEventListener('dragstart', handleTaskDragStart);
                    taskDiv.addEventListener('dragend', handleTaskDragEnd);
                    taskDiv.addEventListener('dragover', handleTaskDragOver);
                    taskDiv.addEventListener('drop', handleTaskDrop);

                    taskList.appendChild(taskDiv);
                });

                // Add final drop indicator
                const finalDropIndicator = document.createElement('div');
                finalDropIndicator.className = 'drop-indicator';
                finalDropIndicator.setAttribute('data-drop-index', projects[currentProject].tasks[column].length);
                finalDropIndicator.setAttribute('data-column', column);
                taskList.appendChild(finalDropIndicator);
            });
        }

        // Create new project
        function createProject() {
            document.getElementById('projectModal').style.display = 'flex';
            document.getElementById('projectInput').focus();
        }

        function addProject() {
            const projectName = document.getElementById('projectInput').value.trim().toUpperCase();
            if (projectName) {
                const projectId = 'project_' + Date.now();
                projects[projectId] = {
                    name: projectName,
                    title: projectName + ' Board',
                    tasks: {
                        todo: [],
                        doing: [],
                        done: []
                    }
                };
                renderProjects();
                switchProject(projectId);
                closeProjectModal();
            }
        }

        function deleteProject(projectId, event) {
            event.stopPropagation();
            if (confirm('Move this project to trash? You can restore it later.')) {
                // Move project to trash
                const trashedProject = {
                    ...projects[projectId],
                    originalId: projectId,
                    trashedAt: Date.now()
                };
                projectTrash.push(trashedProject);

                // Remove from active projects
                delete projects[projectId];
                if (currentProject === projectId) {
                    switchProject('default');
                }

                renderProjects();
                renderTrash();
                saveData();

                // Show success message
                showNotification(`Project "${trashedProject.name}" moved to trash`, '#dc2626');
            }
        }

        function duplicateProject(projectId, event) {
            event.stopPropagation();
            const originalProject = projects[projectId];
            const newProjectId = 'project_' + Date.now();
            const newProjectName = originalProject.name + ' COPY';

            projects[newProjectId] = {
                name: newProjectName,
                title: originalProject.title + ' Copy',
                tasks: {
                    todo: [...originalProject.tasks.todo],
                    doing: [...originalProject.tasks.doing],
                    done: [...originalProject.tasks.done]
                }
            };

            renderProjects();
            saveData();

            // Show feedback
            const notification = document.createElement('div');
            notification.textContent = `Project "${newProjectName}" created successfully!`;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                z-index: 1000;
                font-size: 14px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Context menu functionality
        let contextMenuProjectId = null;

        function showProjectContextMenu(event, projectId) {
            const contextMenu = document.getElementById('projectContextMenu');
            contextMenuProjectId = projectId;

            // Show/hide delete option for default project
            const deleteItem = contextMenu.querySelector('.delete');
            if (projectId === 'default') {
                deleteItem.style.display = 'none';
            } else {
                deleteItem.style.display = 'flex';
            }

            // Position and show context menu
            contextMenu.style.left = event.clientX + 'px';
            contextMenu.style.top = event.clientY + 'px';
            contextMenu.style.display = 'block';

            // Close context menu when clicking elsewhere
            document.addEventListener('click', hideProjectContextMenu);
        }

        function hideProjectContextMenu() {
            const contextMenu = document.getElementById('projectContextMenu');
            contextMenu.style.display = 'none';
            document.removeEventListener('click', hideProjectContextMenu);
        }

        function duplicateProjectFromMenu() {
            if (contextMenuProjectId) {
                duplicateProject(contextMenuProjectId, { stopPropagation: () => {} });
                hideProjectContextMenu();
            }
        }

        function deleteProjectFromMenu() {
            if (contextMenuProjectId && contextMenuProjectId !== 'default') {
                deleteProject(contextMenuProjectId, { stopPropagation: () => {} });
                hideProjectContextMenu();
            }
        }

        // Trash context menu functionality
        let contextMenuTrashIndex = null;

        function showTrashContextMenu(event, trashIndex) {
            const contextMenu = document.getElementById('trashContextMenu');
            contextMenuTrashIndex = trashIndex;

            contextMenu.style.left = event.clientX + 'px';
            contextMenu.style.top = event.clientY + 'px';
            contextMenu.style.display = 'block';

            document.addEventListener('click', hideTrashContextMenu);
        }

        function hideTrashContextMenu() {
            const contextMenu = document.getElementById('trashContextMenu');
            contextMenu.style.display = 'none';
            document.removeEventListener('click', hideTrashContextMenu);
        }

        function restoreProjectFromMenu() {
            if (contextMenuTrashIndex !== null) {
                restoreProject(contextMenuTrashIndex);
                hideTrashContextMenu();
            }
        }

        function permanentDeleteFromMenu() {
            if (contextMenuTrashIndex !== null) {
                permanentDelete(contextMenuTrashIndex);
                hideTrashContextMenu();
            }
        }

        // Trash management functions
        function renderTrash() {
            const trashList = document.getElementById('trashList');
            const trashSection = document.getElementById('trashSection');

            if (projectTrash.length === 0) {
                trashSection.style.display = 'none';
                return;
            }

            trashSection.style.display = 'block';
            trashList.innerHTML = '';

            projectTrash.forEach((trashedProject, index) => {
                const trashItem = document.createElement('div');
                trashItem.className = 'trash-item';
                trashItem.setAttribute('data-trash-index', index);

                const daysAgo = Math.floor((Date.now() - trashedProject.trashedAt) / (1000 * 60 * 60 * 24));
                const timeText = daysAgo === 0 ? 'Today' : `${daysAgo} days ago`;

                trashItem.innerHTML = `
                    <div class="trash-item-name">${trashedProject.name}</div>
                    <div style="font-size: 10px; color: #9ca3af;">${timeText}</div>
                `;

                // Add right-click context menu for trash items
                trashItem.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showTrashContextMenu(e, index);
                });

                trashList.appendChild(trashItem);
            });
        }

        function restoreProject(trashIndex) {
            const trashedProject = projectTrash[trashIndex];
            if (!trashedProject) return;

            // Generate new ID if original ID exists
            let newId = trashedProject.originalId;
            if (projects[newId]) {
                newId = 'project_' + Date.now();
            }

            // Restore project
            projects[newId] = {
                name: trashedProject.name,
                title: trashedProject.title,
                sortingMode: trashedProject.sortingMode || 'free',
                tasks: trashedProject.tasks,
                taskMetadata: trashedProject.taskMetadata || {}
            };

            // Remove from trash
            projectTrash.splice(trashIndex, 1);

            renderProjects();
            renderTrash();
            saveData();

            showNotification(`Project "${trashedProject.name}" restored successfully!`, '#10b981');
        }

        function permanentDelete(trashIndex) {
            const trashedProject = projectTrash[trashIndex];
            if (!trashedProject) return;

            if (confirm(`Permanently delete "${trashedProject.name}"? This cannot be undone.`)) {
                projectTrash.splice(trashIndex, 1);
                renderTrash();
                saveData();
                showNotification(`Project "${trashedProject.name}" permanently deleted`, '#dc2626');
            }
        }

        function emptyTrash() {
            if (projectTrash.length === 0) return;

            if (confirm(`Permanently delete all ${projectTrash.length} projects in trash? This cannot be undone.`)) {
                projectTrash = [];
                renderTrash();
                saveData();
                showNotification('Trash emptied successfully', '#dc2626');
            }
        }

        // Notification function
        function showNotification(message, color = '#10b981') {
            const notification = document.createElement('div');
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${color};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                z-index: 1000;
                font-size: 14px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function closeProjectModal() {
            document.getElementById('projectModal').style.display = 'none';
            document.getElementById('projectInput').value = '';
        }

        // Task management
        function showAddTaskModal(column) {
            currentColumn = column;
            document.getElementById('taskModal').style.display = 'flex';
            document.getElementById('taskInput').focus();
        }

        function addTask() {
            const taskText = document.getElementById('taskInput').value.trim();
            if (taskText) {
                projects[currentProject].tasks[currentColumn].push(taskText);
                renderTasks();
                renderProjects(); // Update task counts
                closeModal();
                saveData();
            }
        }

        function deleteTask(column, index) {
            projects[currentProject].tasks[column].splice(index, 1);
            renderTasks();
            saveData();
        }

        function closeModal() {
            document.getElementById('taskModal').style.display = 'none';
            document.getElementById('taskInput').value = '';
        }

        // Task editing functions
        function startEditingTask(element, column, index) {
            element.contentEditable = true;
            element.focus();

            // Select all text
            const range = document.createRange();
            range.selectNodeContents(element);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);

            element.setAttribute('data-original-value', element.textContent);
        }

        function finishEditingTask(element, column, index) {
            const newText = element.textContent.trim();
            if (newText && newText !== '') {
                projects[currentProject].tasks[column][index] = newText;
                element.innerHTML = makeURLsClickable(newText);
                saveData();
            } else {
                // Revert to original value if empty
                element.textContent = element.getAttribute('data-original-value');
            }
            element.contentEditable = false;
            element.removeAttribute('data-original-value');
        }

        function cancelEditingTask(element, column, index) {
            element.textContent = element.getAttribute('data-original-value');
            element.contentEditable = false;
            element.removeAttribute('data-original-value');
        }

        // Copy task text to clipboard
        async function copyTaskText(element) {
            const text = element.textContent.trim();

            try {
                await navigator.clipboard.writeText(text);
                showCopyFeedback(element, 'Copied!');
            } catch (error) {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showCopyFeedback(element, 'Copied!');
            }
        }

        // Show copy feedback
        function showCopyFeedback(element, message) {
            // Add visual feedback to the task
            element.classList.add('copied');
            setTimeout(() => {
                element.classList.remove('copied');
            }, 300);

            // Create and show feedback tooltip
            const feedback = document.createElement('div');
            feedback.className = 'copy-feedback';
            feedback.textContent = message;

            const rect = element.getBoundingClientRect();
            feedback.style.left = rect.left + rect.width / 2 - 25 + 'px';
            feedback.style.top = rect.top - 10 + 'px';

            document.body.appendChild(feedback);

            // Animate in
            setTimeout(() => feedback.classList.add('show'), 10);

            // Remove after animation
            setTimeout(() => {
                feedback.classList.remove('show');
                setTimeout(() => {
                    if (feedback.parentNode) {
                        document.body.removeChild(feedback);
                    }
                }, 300);
            }, 1500);
        }

        // Enhanced drag and drop functionality
        let draggedTaskData = null;
        let isReordering = false;

        function handleTaskDragStart(e) {
            draggedTask = e.target;
            const taskId = parseInt(e.target.getAttribute('data-task-id'));
            const column = e.target.getAttribute('data-column');

            draggedTaskData = {
                taskId: taskId,
                column: column,
                content: projects[currentProject].tasks[column][taskId]
            };

            e.target.classList.add('dragging');

            // Determine if this is reordering within the same column or moving between columns
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleTaskDragEnd(e) {
            e.target.classList.remove('dragging', 'reordering');

            // Clear all drop indicators
            document.querySelectorAll('.drop-indicator').forEach(indicator => {
                indicator.classList.remove('active');
            });

            document.querySelectorAll('.task-list').forEach(list => {
                list.classList.remove('drag-over-reorder');
            });

            draggedTask = null;
            draggedTaskData = null;
            isReordering = false;
        }

        function handleTaskDragOver(e) {
            e.preventDefault();

            if (!draggedTask || !draggedTaskData) return;

            const rect = e.target.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const isAbove = e.clientY < midpoint;

            // Find the closest drop indicator
            const taskElement = e.target.closest('.task-item');
            if (taskElement) {
                const taskList = taskElement.parentElement;
                const indicators = taskList.querySelectorAll('.drop-indicator');

                // Clear all indicators first
                indicators.forEach(indicator => indicator.classList.remove('active'));

                const taskId = parseInt(taskElement.getAttribute('data-task-id'));
                const column = taskElement.getAttribute('data-column');

                // Activate appropriate indicator
                if (isAbove) {
                    const indicator = taskList.querySelector(`[data-drop-index="${taskId}"]`);
                    if (indicator) indicator.classList.add('active');
                } else {
                    const indicator = taskList.querySelector(`[data-drop-index="${taskId + 1}"]`);
                    if (indicator) indicator.classList.add('active');
                }

                // Add visual feedback for reordering vs moving
                if (column === draggedTaskData.column) {
                    taskList.classList.add('drag-over-reorder');
                    draggedTask.classList.add('reordering');
                    isReordering = true;
                } else {
                    taskList.classList.remove('drag-over-reorder');
                    draggedTask.classList.remove('reordering');
                    isReordering = false;
                }
            }
        }

        function handleTaskDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!draggedTask || !draggedTaskData) return;

            const targetElement = e.target.closest('.task-item');
            if (!targetElement) return;

            const targetTaskId = parseInt(targetElement.getAttribute('data-task-id'));
            const targetColumn = targetElement.getAttribute('data-column');

            const rect = targetElement.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const isAbove = e.clientY < midpoint;

            // Calculate drop position
            let dropIndex = isAbove ? targetTaskId : targetTaskId + 1;

            // Handle the drop
            const sourceColumn = draggedTaskData.column;
            const sourceIndex = draggedTaskData.taskId;

            if (sourceColumn === targetColumn) {
                // Reordering within the same column
                if (sourceIndex !== dropIndex && sourceIndex !== dropIndex - 1) {
                    const task = projects[currentProject].tasks[sourceColumn].splice(sourceIndex, 1)[0];

                    // Adjust drop index if we removed an item before it
                    if (sourceIndex < dropIndex) {
                        dropIndex--;
                    }

                    projects[currentProject].tasks[targetColumn].splice(dropIndex, 0, task);
                    renderTasks();
                    saveData();
                }
            } else {
                // Moving between columns
                const task = projects[currentProject].tasks[sourceColumn].splice(sourceIndex, 1)[0];
                projects[currentProject].tasks[targetColumn].splice(dropIndex, 0, task);
                renderTasks();
                saveData();
            }
        }

        // Legacy drag and drop for column-level drops (fallback)
        function handleDragStart(e) {
            if (!e.target.classList.contains('task-item')) return;
            handleTaskDragStart(e);
        }

        function handleDragEnd(e) {
            if (!e.target.classList.contains('task-item')) return;
            handleTaskDragEnd(e);
        }

        // Add drag and drop event listeners to columns
        document.querySelectorAll('.column').forEach(column => {
            column.addEventListener('dragover', handleDragOver);
            column.addEventListener('drop', handleDrop);
            column.addEventListener('dragenter', handleDragEnter);
            column.addEventListener('dragleave', handleDragLeave);
        });

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDragEnter(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            if (draggedTask) {
                const sourceColumn = draggedTask.getAttribute('data-column');
                const targetColumn = e.currentTarget.getAttribute('data-column');
                const taskIndex = parseInt(draggedTask.getAttribute('data-task-id'));

                if (sourceColumn !== targetColumn) {
                    // Move task between columns
                    const task = projects[currentProject].tasks[sourceColumn][taskIndex];
                    projects[currentProject].tasks[sourceColumn].splice(taskIndex, 1);
                    projects[currentProject].tasks[targetColumn].push(task);

                    renderTasks();
                    saveData();
                }
            }
        }

        // Board title editing
        document.getElementById('boardTitle').addEventListener('input', function() {
            projects[currentProject].title = this.value;
            saveData();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl+N to create new task in TODO column
            if (e.ctrlKey && e.key === 'n') {
                e.preventDefault();
                showAddTaskModal('todo');
                return;
            }

            if (e.key === 'Escape') {
                closeModal();
                closeProjectModal();
            } else if (e.key === 'Enter' && document.getElementById('taskModal').style.display === 'flex') {
                addTask();
            } else if (e.key === 'Enter' && document.getElementById('projectModal').style.display === 'flex') {
                addProject();
            }
        });

        // Project name editing functions
        function startEditingProjectName(input, projectId) {
            input.readOnly = false;
            input.focus();
            input.select();
            input.setAttribute('data-original-value', input.value);
        }

        function finishEditingProjectName(input, projectId) {
            const newName = input.value.trim().toUpperCase();
            if (newName && newName !== '') {
                projects[projectId].name = newName;
                document.getElementById('currentProject').textContent = projects[currentProject].name;
                saveData();
            } else {
                // Revert to original value if empty
                input.value = input.getAttribute('data-original-value');
            }
            input.readOnly = true;
            input.removeAttribute('data-original-value');
        }

        function cancelEditingProjectName(input, projectId) {
            input.value = input.getAttribute('data-original-value');
            input.readOnly = true;
            input.removeAttribute('data-original-value');
        }

        // Auto-refresh functionality
        function refreshData() {
            loadData().then(() => {
                console.log('Data refreshed automatically');
            }).catch(error => {
                console.error('Auto-refresh failed:', error);
            });
        }

        // Refresh data when page becomes visible (tab switching)
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                refreshData();
            }
        });

        // Refresh data when window gains focus
        window.addEventListener('focus', function() {
            refreshData();
        });

        // Function to make URLs clickable
        function makeURLsClickable(text) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
        }

        // Periodic refresh every 2 minutes (in case of multi-device usage)
        setInterval(refreshData, 2 * 60 * 1000);

        // Force refresh on page load to ensure latest data
        window.addEventListener('load', function() {
            setTimeout(refreshData, 500); // Small delay to ensure everything is loaded
        });

        // Initialize the application with password protection
        initializePasswordProtection();
    </script>
</body>
</html>
