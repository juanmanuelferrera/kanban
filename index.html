<!DOCTYPE html>
<!-- Version: 2025.07.22-sync-fix-v2 - Fixed renderKanbanBoard error -->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kanban Board</title>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import { getDatabase, ref, set, get, update, onValue, push, remove } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
        
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAAOyqnAE-9lFAsni2_AoDXK0Y7Aekg-t4",
            authDomain: "ultra-kanban.firebaseapp.com",
            databaseURL: "https://ultra-kanban-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "ultra-kanban",
            storageBucket: "ultra-kanban.firebasestorage.app",
            messagingSenderId: "190342751802",
            appId: "1:190342751802:web:5eb977207734bd6f187703"
        };
        
        // Initialize Firebase
        window.firebaseApp = initializeApp(firebaseConfig);
        window.database = getDatabase(window.firebaseApp);
        window.firebaseRef = ref;
        window.firebaseSet = set;
        window.firebaseGet = get;
        window.firebaseUpdate = update;
        window.firebaseOnValue = onValue;
        window.firebasePush = push;
        window.firebaseRemove = remove;
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            color: #1f2937;
        }

        .sidebar {
            width: 250px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(229, 231, 235, 0.5);
            padding: 14px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .sidebar h2 {
            color: #1f2937;
            margin-bottom: 20px;
            font-size: 20px;
            font-family: 'Playfair Display', serif;
            font-weight: 700;
            letter-spacing: -0.5px;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .project-list {
            flex: 1;
            overflow-y: auto;
            min-height: 200px;
        }

        .project-item {
            background: #ffffff !important;
            border-radius: 6px;
            padding: 4px 7px;
            margin-bottom: 3px;
            cursor: grab;
            transition: all 0.3s ease;
            color: #000000 !important;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            text-transform: uppercase !important;
            font-weight: 700 !important;
            letter-spacing: -0.2px;
            font-size: 11px !important;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif !important;
            text-shadow: none !important;
            -webkit-text-fill-color: #000000 !important;
            opacity: 1 !important;
            font-stretch: normal;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .project-item:active {
            cursor: grabbing;
        }

        .project-item.dragging {
            opacity: 0.5;
            transform: rotate(2deg);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .project-item.drag-over {
            border-top: 3px solid #3b82f6;
        }

        .project-item:hover {
            background: #f9fafb;
            border-color: #d1d5db;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            color: #111827;
        }

        .project-item.active {
            background: #3b82f6 !important;
            border-color: #2563eb !important;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4) !important;
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
            font-weight: 900 !important;
            transform: scale(1.02);
        }

        .add-project {
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 12px;
            color: #374151;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            margin-top: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .add-project:hover {
            background: #f9fafb;
            border-color: #d1d5db;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .main-content {
            flex: 1;
            padding: 5px 15px;
            display: flex;
            flex-direction: column;
            min-width: 0;
            width: 100%;
            height: 100vh;
            box-sizing: border-box;
            overflow-x: auto;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin: 10px;
            border-radius: 16px;
        }

        .header {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            gap: 20px;
        }

        .workspace-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .workspace-dropdown {
            padding: 6px 10px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            font-size: 16px;
            min-width: 180px;
            cursor: pointer;
        }

        .workspace-btn {
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .workspace-btn:hover {
            background: #2563eb;
        }

        .board-title {
            font-size: 28px;
            font-weight: bold;
            color: #1f2937;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            padding: 8px 0;
            margin-right: 15px;
            min-width: 200px;
            outline: none;
        }

        .board-title:hover:not(:disabled),
        .board-title:focus:not(:disabled) {
            border-bottom-color: rgba(31, 41, 55, 0.5);
        }

        .board-title:disabled {
            background-color: #f9fafb !important;
            color: #6b7280 !important;
            cursor: default !important;
            border-bottom-color: #e5e7eb !important;
            opacity: 1 !important; /* Override default disabled opacity */
        }

        .project-info {
            color: rgba(255, 255, 255, 0.8);
            font-size: 14px;
            margin-left: auto;
        }
        
        .user-info-bottom {
            position: sticky;
            bottom: 0;
            z-index: 100;
        }
        
        .user-info-bottom button:hover {
            background: #dc2626 !important;
            transform: translateY(-1px);
        }

        .kanban-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            flex: 1;
            width: 100%;
            margin: 0;
            align-items: stretch;
            justify-content: start;
            padding: 0 15px;
            box-sizing: border-box;
            height: 100%;
            min-width: 900px;
        }

        .column {
            background: #ffffff;
            border-radius: 12px;
            padding: 24px;
            height: 100%;
            width: 100%;
            border: 1px solid #e5e7eb;
            position: relative;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .column.todo {
            background: linear-gradient(to bottom, #ffffff 0%, #eff6ff 100%);
            border-left: 4px solid #3b82f6;
        }

        .column.doing {
            background: linear-gradient(to bottom, #ffffff 0%, #fef2f2 100%);
            border-left: 4px solid #ef4444;
        }

        .column.done {
            background: linear-gradient(to bottom, #ffffff 0%, #f3f4f6 100%);
            border-left: 4px solid #8b5cf6;
        }


        .column-header {
            font-size: 16px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 20px;
            text-align: left;
            padding: 0;
            background: transparent;
            position: relative;
        }

        .column.todo .column-header {
            color: #1d4ed8;
        }

        .column.doing .column-header {
            color: #dc2626;
        }

        .column.done .column-header {
            color: #7c3aed;
        }

        .sorting-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
        }

        .sort-btn {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 4px 8px;
            color: #374151;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }

        .sort-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        .sort-btn.active {
            background: #f3f4f6;
            border-color: #6b7280;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .project-sorting {
            margin-top: 10px;
            padding: 8px;
            background: #ffffff;
            border-radius: 6px;
            text-align: center;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .project-sorting select {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            padding: 4px 8px;
            color: #374151;
            font-size: 12px;
            outline: none;
        }

        .project-sorting select option {
            background: #ffffff;
            color: #374151;
        }


        .task-list {
            min-height: 300px;
            padding: 10px 0;
            flex: 1;
            width: 100%;
        }

        .task-item {
            background: #ffffff;
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 8px;
            cursor: move;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08), 0 1px 2px rgba(0, 0, 0, 0.04);
            user-select: none;
            border: 1px solid rgba(0, 0, 0, 0.05);
            position: relative;
            min-height: 40px;
        }

        .task-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12), 0 2px 4px rgba(0, 0, 0, 0.08);
        }

        .task-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .task-content {
            flex: 1;
            background: transparent;
            border: none;
            font-size: 14px;
            line-height: 1.4;
            outline: none;
            cursor: pointer;
            padding: 4px 6px;
            border-radius: 6px;
            transition: all 0.2s ease;
            min-height: 22px;
            color: #374151;
            font-weight: 400;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            word-break: break-word;
            max-height: 2.8em;
        }

        .task-content:hover {
            overflow: visible;
            display: block;
            max-height: none;
            -webkit-line-clamp: none;
            background: rgba(0, 0, 0, 0.03);
            z-index: 10;
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            white-space: pre-wrap;
        }

        .task-content a {
            color: #3b82f6;
            text-decoration: underline;
            cursor: pointer;
        }

        .task-content a:hover {
            color: #1d4ed8;
            text-decoration: none;
        }


        .task-content:focus {
            background: #f3f4f6;
            cursor: text;
            border: 1px solid #3b82f6;
        }

        .task-item-wrapper {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            width: 100%;
        }

        .task-item.reordering {
            opacity: 0.3;
            transform: scale(0.95);
        }

        .task-list.drag-over-reorder {
            background: rgba(33, 150, 243, 0.1);
            border: 2px dashed rgba(33, 150, 243, 0.5);
        }

        .drop-indicator {
            height: 3px;
            background: #007bff;
            margin: 2px 0;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .drop-indicator.active {
            opacity: 1;
        }

        .task-content.copied {
            background: #dcfce7;
            transform: scale(1.02);
        }

        .copy-feedback {
            position: absolute;
            background: #16a34a;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s ease;
        }

        .copy-feedback.show {
            opacity: 1;
            transform: translateY(-20px);
        }

        .task-checkbox {
            width: 16px;
            height: 16px;
            margin-right: 8px;
            cursor: pointer;
            accent-color: #007bff;
        }

        .task-item.selected {
            background: rgba(33, 150, 243, 0.1);
            border: 2px solid rgba(33, 150, 243, 0.5);
        }

        .multi-select-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px 20px;
            display: none;
            gap: 10px;
            align-items: center;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .multi-select-controls.show {
            display: flex;
        }

        .multi-select-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            padding: 8px 12px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
            margin: 0 2px;
        }

        .multi-select-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        .multi-select-btn.danger {
            background: rgba(244, 67, 54, 0.8);
            border-color: rgba(244, 67, 54, 1);
        }

        .multi-select-btn.danger:hover {
            background: rgba(244, 67, 54, 1);
        }

        .multi-select-info {
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            margin-right: 10px;
        }

        .column-header {
            position: relative;
        }

        .select-all-checkbox {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: white;
        }

        .column.drag-over {
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }

        .todo-column.drag-over {
            background: linear-gradient(to bottom,
                rgba(244, 67, 54, 0.25) 0%,
                rgba(255, 152, 0, 0.2) 100%);
        }

        .doing-column.drag-over {
            background: linear-gradient(to bottom,
                rgba(255, 193, 7, 0.25) 0%,
                rgba(255, 235, 59, 0.2) 100%);
        }

        .done-column.drag-over {
            background: linear-gradient(to bottom,
                rgba(76, 175, 80, 0.25) 0%,
                rgba(139, 195, 74, 0.2) 100%);
        }

        .add-task {
            background: transparent;
            border: 2px dashed #d1d5db;
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            cursor: pointer;
            color: #6b7280;
            transition: all 0.2s ease;
            margin-top: 12px;
            font-size: 14px;
            font-weight: 500;
        }

        .add-task:hover {
            background: #f9fafb;
            border-color: #9ca3af;
            color: #374151;
        }

        .task-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            background: #ffffff;
            margin-bottom: 10px;
            outline: none;
            color: #374151;
            font-size: 14px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        }

        .task-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn:hover {
            transform: translateY(-1px);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        .modal input {
            width: 100%;
            padding: 12px;
            margin: 15px 0;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 16px;
        }

        .task-actions-container {
            position: absolute;
            right: 8px;
            top: 8px;
            display: flex;
            gap: 4px;
            align-items: center;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .delete-task {
            background: transparent;
            border: none;
            border-radius: 6px;
            padding: 4px 6px;
            color: #9ca3af;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .attach-image-task {
            background: transparent;
            border: none;
            border-radius: 6px;
            padding: 6px 8px;
            color: #9ca3af;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s ease;
            min-width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .task-image-mark {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 12px;
            height: 12px;
            background: #ef4444;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            pointer-events: none;
            z-index: 1;
        }

        .task-item:hover .task-actions-container {
            opacity: 1;
        }

        .delete-task:hover {
            background: #fef2f2;
            color: #ef4444;
        }
        .attach-image-task:hover {
            background: #f0f9ff;
            color: #3b82f6;
            transform: scale(1.1);
        }

        .project-name {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            font-size: 14px;
            outline: none;
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 4px;
            transition: all 0.3s ease;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .project-name:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .project-name:focus {
            background: rgba(255, 255, 255, 0.2);
            cursor: text;
            border: 1px solid rgba(255, 255, 255, 0.5);
        }

        .project-item-content {
            display: flex;
            align-items: center;
            gap: 4px;
            justify-content: space-between;
            width: 100%;
        }

        .project-context-menu, .task-context-menu {
            position: fixed;
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            padding: 4px 0;
            z-index: 1000;
            display: none;
            min-width: 150px;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            color: #374151;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #f3f4f6;
        }

        .context-menu-item.duplicate {
            color: #059669;
        }

        .context-menu-item.delete {
            color: #dc2626;
        }

        .context-menu-item.delete:hover {
            background: #fef2f2;
        }

        .trash-item {
            background: #fef2f2;
            border-radius: 6px;
            padding: 6px;
            margin-bottom: 3px;
            font-size: 11px;
            color: #6b7280;
            border: 1px solid #fca5a5;
            cursor: pointer;
        }

        .trash-item:hover {
            background: #fee2e2;
            color: #dc2626;
        }

        .trash-item-name {
            font-weight: 600;
            color: #dc2626;
        }


        .task-count {
            background: #9ca3af !important;
            color: #ffffff !important;
            -webkit-text-fill-color: #ffffff !important;
            border-radius: 12px;
            padding: 3px 7px;
            font-size: 11px;
            font-weight: 900;
            min-width: 20px;
            text-align: center;
            margin-left: auto;
            flex-shrink: 0;
            display: inline-block;
            line-height: 1.2;
            border: 2px solid rgba(0, 0, 0, 0.3);
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        .task-count.zero {
            background: #fca5a5 !important;
            color: white !important;
        }

        .backup-controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e5e7eb;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }

        .backup-btn {
            background: #ffffff;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            padding: 8px 6px;
            color: #374151;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 4px;
            min-height: 32px;
            text-align: center;
            font-weight: 500;
        }

        .backup-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
            transform: translateY(-1px);
        }

        .backup-status {
            color: rgba(255, 255, 255, 0.7);
            font-size: 11px;
            margin-top: 5px;
            text-align: center;
        }

        .import-input {
            display: none;
        }

        .password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
        }

        .password-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .password-container h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 24px;
        }

        .password-container p {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .password-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 20px;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .password-input:focus {
            border-color: #667eea;
        }

        .password-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            padding: 15px 30px;
            color: white;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }

        .password-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }

        .password-error {
            color: #e74c3c;
            margin-top: 15px;
            font-size: 14px;
            display: none;
        }

        .password-setup {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .password-setup h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .app-content {
            display: none;
            height: 100vh;
            overflow: hidden;
        }

        .app-content.unlocked {
            display: flex;
            height: 100vh;
        }

        @media (max-width: 1200px) {
            .kanban-board {
                grid-template-columns: repeat(3, 1fr);
                gap: 16px;
                padding: 0 12px;
            }
        }

        @media (max-width: 968px) {
            .kanban-board {
                grid-template-columns: repeat(3, 1fr);
                gap: 12px;
            }
        }

        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: auto;
                max-height: 200px;
                overflow-y: auto;
                border-right: none;
                border-bottom: 1px solid rgba(229, 231, 235, 0.5);
                padding: 10px;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
            }

            .project-list {
                display: flex;
                flex-direction: column;
                gap: 6px;
                min-height: auto;
                max-height: 180px;
                overflow-y: auto;
            }

            .project-item {
                font-size: 12px !important;
                padding: 6px 8px;
                margin-bottom: 0;
                text-align: center;
            }

            .task-count {
                font-size: 9px;
                padding: 2px 4px;
                min-width: 16px;
            }

            .kanban-board {
                grid-template-columns: 1fr;
                gap: 16px;
                padding: 0 12px;
                min-width: auto;
            }

            .column {
                min-height: 300px;
            }

            .main-content {
                padding: 10px;
                height: calc(100vh - 200px);
                margin: 5px;
                border-radius: 12px;
            }

            .header {
                margin-bottom: 10px;
            }
            
            .header-top {
                margin-bottom: 10px !important;
            }
            
            .header-bottom {
                flex-direction: column !important;
                gap: 10px;
                text-align: center;
            }
            
            .header-bottom > div:last-child {
                justify-content: center !important;
            }

            .workspace-selector {
                width: 100%;
            }

            .workspace-dropdown {
                width: 100%;
            }

            .board-title {
                font-size: 16px;
                padding: 8px;
            }

            .add-project {
                font-size: 12px;
                padding: 8px;
            }

            .backup-controls {
                margin-top: 8px;
                padding-top: 8px;
            }

            .backup-btn {
                font-size: 11px;
                padding: 6px 8px;
            }
        }

        @media (max-width: 480px) {
            .sidebar {
                max-height: 150px;
                padding: 8px;
            }

            .project-list {
                display: flex;
                flex-direction: column;
                gap: 4px;
                max-height: 140px;
            }

            .project-item {
                font-size: 11px !important;
                padding: 5px 6px;
            }

            .task-count {
                font-size: 8px;
                padding: 1px 3px;
                min-width: 14px;
            }

            .main-content {
                padding: 8px;
                height: calc(100vh - 150px);
                margin: 3px;
                border-radius: 8px;
            }

            .column {
                min-height: 250px;
            }

            .column h3 {
                font-size: 14px;
                padding: 8px;
            }

            .task {
                font-size: 12px;
                padding: 12px;
                min-height: 44px;
                touch-action: pan-y;
            }

            .task-actions {
                gap: 12px;
            }

            .task-action {
                min-width: 44px;
                min-height: 44px;
                padding: 8px;
                font-size: 14px;
            }

            .board-title {
                font-size: 14px;
                padding: 6px;
            }

            .header {
                gap: 8px;
                margin-bottom: 8px;
            }
        }
    </style>
</head>
<body>
    <!-- Password Protection Overlay -->
    <div class="password-overlay" id="passwordOverlay">
        <div class="password-container">
            <h1>ğŸ”’ Ultra Kanban</h1>
            <p id="authFormDescription">Accede a tu cuenta personal</p>

            <!-- User Login Form -->
            <div id="userLoginForm">
                <input type="email" class="password-input" id="emailInput" placeholder="Email" autocomplete="email" required>
                <input type="password" class="password-input" id="userPasswordInput" placeholder="ContraseÃ±a" autocomplete="current-password" required>
                <button class="password-btn" onclick="handleUserLogin()">Iniciar SesiÃ³n</button>
                <div class="password-error" id="userLoginError"></div>
                <div style="margin-top: 15px; text-align: center;">
                    <a href="#" onclick="showRegisterForm()" style="color: #667eea; text-decoration: none; font-size: 14px;">Â¿No tienes cuenta? RegÃ­strate</a>
                </div>
                <div style="margin-top: 10px; text-align: center;">
                    <a href="#" onclick="showLegacyLogin()" style="color: #888; text-decoration: none; font-size: 12px;">Modo compatibilidad (contraseÃ±a simple)</a>
                </div>
            </div>

            <!-- User Registration Form -->
            <div id="userRegisterForm" style="display: none;">
                <input type="email" class="password-input" id="registerEmail" placeholder="Email" autocomplete="email" required>
                <input type="password" class="password-input" id="registerPassword" placeholder="ContraseÃ±a" autocomplete="new-password" required>
                <input type="password" class="password-input" id="registerConfirmPassword" placeholder="Confirmar contraseÃ±a" autocomplete="new-password" required>
                <button class="password-btn" onclick="handleUserRegister()">Registrarse</button>
                <div class="password-error" id="userRegisterError"></div>
                <div style="margin-top: 15px; text-align: center;">
                    <a href="#" onclick="showLoginForm()" style="color: #667eea; text-decoration: none; font-size: 14px;">Â¿Ya tienes cuenta? Inicia sesiÃ³n</a>
                </div>
            </div>

            <!-- Legacy Login Form (Original System) -->
            <div id="legacyLoginForm" style="display: none;">
                <div id="loginForm">
                    <input type="password" class="password-input" id="passwordInput" placeholder="ContraseÃ±a" autocomplete="current-password">
                    <button class="password-btn" onclick="checkPassword()">Ingresar</button>
                    <div class="password-error" id="passwordError">ContraseÃ±a incorrecta</div>
                </div>

                <div class="password-setup" id="setupForm" style="display: none;">
                    <h3>Configurar ContraseÃ±a</h3>
                    <p>Es la primera vez que accedes. Establece una contraseÃ±a:</p>
                    <input type="password" class="password-input" id="newPasswordInput" placeholder="Nueva contraseÃ±a" autocomplete="new-password">
                    <input type="password" class="password-input" id="confirmPasswordInput" placeholder="Confirmar contraseÃ±a" autocomplete="new-password">
                    <button class="password-btn" onclick="setupPassword()">Establecer ContraseÃ±a</button>
                    <div class="password-error" id="setupError">Las contraseÃ±as no coinciden</div>
                </div>
                
                <div style="margin-top: 15px; text-align: center;">
                    <a href="#" onclick="showLoginForm()" style="color: #667eea; text-decoration: none; font-size: 14px;">â† Volver al login con email</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Application Content -->
    <div class="app-content" id="appContent">
        <div class="sidebar">
        <h2>Ultra Kanban</h2>
        <div class="project-list" id="projectList">
            <div class="project-item active" data-project="default">
                Default Board
            </div>
        </div>
        <button class="add-project" onclick="createProject()">+ Add Board</button>

        <div class="trash-section" id="trashSection" style="display: none;">
            <h3 style="color: #6b7280; font-size: 12px; margin: 10px 0 5px 0; text-transform: uppercase;">Trash</h3>
            <div class="trash-list" id="trashList"></div>
            <button class="empty-trash-btn" onclick="emptyTrash()" style="background: #fef2f2; border: 1px solid #fca5a5; color: #dc2626; padding: 6px 12px; border-radius: 6px; font-size: 11px; width: 100%; margin-top: 5px;">Empty Trash</button>
        </div>

        <div class="backup-controls">
            <button class="backup-btn" onclick="exportData()">
                <span style="font-size: 12px;">ğŸ“¥</span>
                Export
            </button>
            <button class="backup-btn" onclick="document.getElementById('importInput').click()">
                <span style="font-size: 12px;">ğŸ“¤</span>
                Import
            </button>
            <button class="backup-btn" onclick="document.getElementById('tasksImportInput').click()">
                <span style="font-size: 12px;">ğŸ“</span>
                Tasks
            </button>
            <button class="backup-btn" onclick="toggleTrash()">
                <span style="font-size: 12px;">ğŸ—‘ï¸</span>
                Trash
            </button>
            <button class="backup-btn" onclick="createBackup()">
                <span style="font-size: 12px;">ğŸ’¾</span>
                Backup
            </button>
            <div class="backup-status" id="backupStatus" style="grid-column: 1 / -1; text-align: center; margin-top: 4px; color: #6b7280; font-size: 9px;">Auto-saving...</div>
            <input type="file" id="importInput" class="import-input" accept=".json" onchange="importData(event)">
            <input type="file" id="tasksImportInput" class="import-input" accept=".txt,.md" onchange="importTasksFromFile(event)">
            <button class="backup-btn" onclick="lockApp()" style="background: #fef2f2; border-color: #fca5a5; color: #dc2626; grid-column: 1 / -1; margin-top: 4px;">
                <span style="font-size: 12px;">ğŸ”’</span>
                Logout
            </button>
        </div>
    </div>

    <div class="main-content">
        <div class="header">
            <div class="header-top" style="display: flex; justify-content: center; align-items: center; margin-bottom: 10px;">
                <div class="workspace-selector">
                    <select id="workspaceSelect" class="workspace-dropdown" style="font-size: 16px; font-weight: 600; min-width: 200px; text-align: center; background: rgba(255,255,255,0.9); border: 1px solid #d1d5db;">
                        <option value="personal">ğŸ“ Main Workspace</option>
                    </select>
                    <button class="workspace-btn" onclick="showWorkspaceModal()">+</button>
                </div>
            </div>
            <div class="header-bottom" style="display: flex; justify-content: space-between; align-items: center;">
                <input type="text" class="board-title" id="boardTitle" value="" placeholder="Enter board title...">
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div class="project-info">
                        Board: <span id="currentProject">Default Board</span>
                    </div>
                    <button onclick="showInfoModal()" style="background: rgba(255,255,255,0.9); border: 1px solid #d1d5db; border-radius: 50%; width: 32px; height: 32px; cursor: pointer; color: #374151; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 1px 3px rgba(0,0,0,0.1); display: flex; align-items: center; justify-content: center;" onmouseover="this.style.background='rgba(59, 130, 246, 0.1)'; this.style.borderColor='#3b82f6'; this.style.color='#1e40af';" onmouseout="this.style.background='rgba(255,255,255,0.9)'; this.style.borderColor='#d1d5db'; this.style.color='#374151';" title="App Information">
                        â„¹ï¸
                    </button>
                </div>
            </div>
        </div>

        <div class="kanban-board">
            <div class="column todo" data-column="todo">
                <div class="column-header">TO DO</div>
                <div class="task-list" id="todoList"></div>
                <div class="add-task" onclick="showAddTaskModal('todo')">+ Add Task</div>
            </div>

            <div class="column doing" data-column="doing">
                <div class="column-header">DOING</div>
                <div class="task-list" id="doingList"></div>
            </div>

            <div class="column done" data-column="done">
                <div class="column-header">DONE</div>
                <div class="task-list" id="doneList"></div>
            </div>
        </div>
    </div>

    <!-- Context Menu for Projects -->
    <div class="project-context-menu" id="projectContextMenu">
        <div class="context-menu-item duplicate" onclick="duplicateProjectFromMenu()">
            <span>ğŸ“„</span> Duplicate Project
        </div>
        <div class="context-menu-item delete" onclick="deleteProjectFromMenu()">
            <span>ğŸ—‘ï¸</span> Move to Trash
        </div>
    </div>

    <!-- Context Menu for Trash Items -->
    <div class="project-context-menu" id="trashContextMenu">
        <div class="context-menu-item" onclick="restoreProjectFromMenu()">
            <span>â†©ï¸</span> Restore Project
        </div>
        <div class="context-menu-item delete" onclick="permanentDeleteFromMenu()">
            <span>âŒ</span> Delete Permanently
        </div>
    </div>

    <!-- Context Menu for Tasks -->
    <div class="task-context-menu" id="taskContextMenu">
        <div class="context-menu-item" onclick="attachImageFromMenu()" id="attachImageMenuItem">
            <span>ğŸ–¼ï¸</span> Attach Image
        </div>
        <div class="context-menu-item" onclick="viewImageFromMenu()" id="viewImageMenuItem" style="display: none;">
            <span>ğŸ‘ï¸</span> View Image
        </div>
        <div class="context-menu-item" onclick="downloadImageFromMenu()" id="downloadImageMenuItem" style="display: none;">
            <span>ğŸ“¥</span> Download Image
        </div>
        <div class="context-menu-item" onclick="copyImageToClipboard()" id="copyImageMenuItem" style="display: none;">
            <span>ğŸ“‹</span> Copy to Clipboard
        </div>
        <div class="context-menu-item" onclick="removeImageFromMenu()" id="removeImageMenuItem" style="display: none;">
            <span>ğŸ—‘ï¸</span> Remove Image
        </div>
    </div>

    <!-- Workspace Management Modal -->
    <div class="modal" id="workspaceModal" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <h2 style="margin-bottom: 20px;">ğŸ¢ Workspace Management</h2>
            
            <div style="margin-bottom: 20px;">
                <h3>Create New Workspace</h3>
                <input type="text" id="newWorkspaceName" placeholder="Workspace name (e.g., Team Alpha, My Projects, Travel Plans)" style="width: 100%; padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 6px;">
                <div style="font-size: 12px; color: #666; margin-bottom: 10px;">ğŸ’¡ Tip: Use descriptive names like "Work Boards", "Family Tasks", or "Travel Planning" for smart emoji detection</div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="createWorkspace()" style="background: #10b981; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer;">Create Workspace</button>
                    <button onclick="showWorkspaceShareUrl()" style="background: #3b82f6; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer;">ğŸ”— Share Sync URL</button>
                    <button onclick="debugWorkspaceData()" style="background: #f59e0b; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">ğŸ” Debug Data</button>
                </div>
            </div>
            
            <div style="margin-bottom: 20px; border-top: 1px solid #eee; padding-top: 20px;">
                <h3>Manage Existing Workspaces</h3>
                <div id="workspaceListContainer" style="margin: 10px 0;">
                    <!-- Workspace list will be populated here -->
                </div>
                <button onclick="refreshWorkspaceList()" style="background: #6b7280; color: white; padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">ğŸ”„ Refresh List</button>
            </div>
            
            <button onclick="closeWorkspaceModal()" style="background: #6b7280; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; float: right;">Close</button>
        </div>
    </div>

    <!-- Information Modal -->
    <div class="modal" id="infoModal" style="display: none;">
        <div class="modal-content" style="max-width: 450px;">
            <h2 style="margin-bottom: 20px; text-align: center;">ğŸš€ Ultra Kanban</h2>
            
            <div style="font-size: 14px; line-height: 1.6; color: #374151;">
                <p><strong>ğŸ“‹ How to use:</strong> Create boards, add tasks, drag them between TO DO â†’ DOING â†’ DONE columns.</p>
                
                <p><strong>ğŸ¢ Workspaces:</strong> Organize different projects (Work, Personal, etc.) in separate workspaces.</p>
                
                <p><strong>ğŸ”„ Real-time sync:</strong> Changes sync automatically across devices. Share your URL for team collaboration.</p>
                
                <p><strong>ğŸ’¾ Controls:</strong> Export/Import data, attach images to tasks, use trash for deleted boards.</p>
                
                <p><strong>ğŸ” Secure:</strong> Email or password authentication protects your data.</p>
            </div>
            
            <button onclick="closeInfoModal()" style="background: #3b82f6; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 20px;">Got it!</button>
        </div>
    </div>

    <div class="modal" id="taskModal">
        <div class="modal-content">
            <h3>Add New Task</h3>
            <input type="text" id="taskInput" placeholder="Enter task description...">
            <div class="task-actions">
                <button class="btn btn-primary" onclick="addTask()">Add Task</button>
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="projectModal">
        <div class="modal-content">
            <h3>Create New Board</h3>
            <input type="text" id="projectInput" placeholder="Enter board name...">
            <div class="task-actions">
                <button class="btn btn-primary" onclick="addProject()">Create Board</button>
                <button class="btn btn-secondary" onclick="closeProjectModal()">Cancel</button>
            </div>
        </div>
    </div>
    </div> <!-- Close app-content -->

    <script>
        let currentProject = 'default';
        let currentColumn = '';
        let draggedTask = null;

        // Data version for migration support
        const DATA_VERSION = '1.1.0';
        const BACKUP_PREFIX = 'kanban_backup_';
        const MAX_BACKUPS = 10;

        let projects = {
            'default': {
                name: 'Default Project',
                title: 'My Kanban Board',
                sortingMode: 'free', // free, alphabetical, newest-first, oldest-first
                tasks: {
                    todo: [],
                    doing: [],
                    done: []
                },
                taskMetadata: {
                    todo: [],
                    doing: [],
                    done: []
                }
            }
        };

        // Project trash for recovery
        let projectTrash = [];

        // Firebase Storage Management System
        class FirebaseStorageManager {
            constructor() {
                this.userId = 'user_' + this.generateUserId(); // Simple user ID for demo
                this.workspaceId = 'personal'; // Default workspace
                this.isOnline = navigator.onLine;
                this.initializeOfflineSupport();
            }

            generateUserId() {
                // Check URL for shared user ID first
                const urlParams = new URLSearchParams(window.location.search);
                const sharedUserId = urlParams.get('user');
                
                if (sharedUserId) {
                    // Clean the user ID - remove extra "user_" prefix if present
                    const cleanUserId = sharedUserId.startsWith('user_user_') ? 
                        sharedUserId.substring(5) : sharedUserId;
                    localStorage.setItem('kanbanUserId', cleanUserId);
                    return cleanUserId;
                }
                
                // Check localStorage
                let userId = localStorage.getItem('kanbanUserId');
                if (!userId) {
                    // Generate new user ID
                    userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('kanbanUserId', userId);
                    
                    // Show sharing info
                    this.showSharingInfo(userId);
                }
                
                // Clean any existing double prefix
                if (userId.startsWith('user_user_')) {
                    userId = userId.substring(5);
                    localStorage.setItem('kanbanUserId', userId);
                }
                
                return userId;
            }
            
            showSharingInfo(userId) {
                const shareUrl = window.location.origin + window.location.pathname + '?user=' + userId;
                console.log('ğŸ”— Share this URL to sync across devices:', shareUrl);
                
                // Show notification with share URL
                setTimeout(() => {
                    const notification = document.createElement('div');
                    notification.innerHTML = `
                        ğŸ”— <strong>Share URL:</strong><br>
                        <input type="text" value="${shareUrl}" readonly style="width: 100%; margin-top: 5px; padding: 5px; font-size: 10px; border: 1px solid #ccc; border-radius: 4px;" onclick="this.select()">
                        <br><small>Copy this URL to sync the same data on other devices</small>
                    `;
                    notification.style.cssText = `
                        position: fixed;
                        top: 70px;
                        right: 20px;
                        background: #3b82f6;
                        color: white;
                        padding: 15px;
                        border-radius: 8px;
                        font-size: 12px;
                        z-index: 10000;
                        max-width: 300px;
                        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    `;
                    
                    document.body.appendChild(notification);
                    
                    // Auto-hide after 10 seconds
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 10000);
                }, 2000);
            }

            initializeOfflineSupport() {
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    this.syncOfflineChanges();
                });
                window.addEventListener('offline', () => {
                    this.isOnline = false;
                });
            }

            async save() {
                const data = {
                    version: '1.0.0',
                    projects: projects,
                    currentProject: currentProject,
                    projectTrash: projectTrash || [],
                    timestamp: new Date().toISOString()
                };

                const success = { firebase: false, localStorage: false };

                // Always save to localStorage as backup (workspace-specific keys)
                try {
                    localStorage.setItem(`kanbanProjects_${this.workspaceId}`, JSON.stringify(data.projects));
                    localStorage.setItem(`currentProject_${this.workspaceId}`, data.currentProject);
                    localStorage.setItem(`kanbanVersion_${this.workspaceId}`, data.version);
                    localStorage.setItem(`projectTrash_${this.workspaceId}`, JSON.stringify(data.projectTrash));
                    
                    // Store snapshot for conflict detection
                    const snapshot = {
                        projects: data.projects,
                        currentProject: data.currentProject,
                        projectTrash: data.projectTrash
                    };
                    localStorage.setItem(`lastSavedData_${this.workspaceId}`, JSON.stringify(snapshot));
                    
                    success.localStorage = true;
                } catch (error) {
                    console.error('localStorage save failed:', error);
                }

                // Save to Firebase if online
                if (this.isOnline && window.database) {
                    try {
                        const workspaceRef = window.firebaseRef(window.database, `workspaces/${this.workspaceId}/data`);
                        await window.firebaseSet(workspaceRef, data);
                        success.firebase = true;
                        this.lastSaveTime = Date.now(); // Track save time to prevent merge race conditions
                        console.log(`Data saved to Firebase workspace: ${this.workspaceId}`);
                    } catch (error) {
                        console.error('Firebase save failed:', error);
                        // Mark for offline sync
                        localStorage.setItem('kanbanPendingSync', 'true');
                    }
                }

                this.updateBackupStatus(success);
                return success;
            }

            async load() {
                let data = null;

                // Try to load from Firebase first if online
                if (this.isOnline && window.database) {
                    try {
                        const workspaceRef = window.firebaseRef(window.database, `workspaces/${this.workspaceId}/data`);
                        const snapshot = await window.firebaseGet(workspaceRef);
                        if (snapshot.exists()) {
                            data = snapshot.val();
                            console.log(`Data loaded from Firebase workspace: ${this.workspaceId}`);
                            
                            // Setup real-time listener
                            this.setupRealtimeListener();
                        }
                    } catch (error) {
                        console.error('Firebase load failed:', error);
                    }
                }

                // Fallback to localStorage (workspace-specific keys)
                if (!data) {
                    try {
                        const savedProjects = localStorage.getItem(`kanbanProjects_${this.workspaceId}`);
                        const savedCurrentProject = localStorage.getItem(`currentProject_${this.workspaceId}`);
                        const savedVersion = localStorage.getItem(`kanbanVersion_${this.workspaceId}`);
                        const savedTrash = localStorage.getItem(`projectTrash_${this.workspaceId}`);

                        if (savedProjects) {
                            data = {
                                version: savedVersion || '1.0.0',
                                projects: JSON.parse(savedProjects),
                                currentProject: savedCurrentProject || 'default',
                                projectTrash: savedTrash ? JSON.parse(savedTrash) : [],
                                timestamp: new Date().toISOString()
                            };
                            console.log('Data loaded from localStorage');
                        }
                    } catch (error) {
                        console.error('localStorage load failed:', error);
                        data = null;
                    }
                }

                return data;
            }

            stopRealtimeListener() {
                if (this.realtimeUnsubscribe) {
                    console.log('ğŸ”‡ Stopping real-time listener');
                    this.realtimeUnsubscribe();
                    this.realtimeUnsubscribe = null;
                }
            }

            setupRealtimeListener() {
                if (!window.database) return;
                
                // Clean up existing listener first
                this.stopRealtimeListener();

                console.log(`ğŸ§ Setting up real-time listener for workspace: ${this.workspaceId}`);
                const workspaceRef = window.firebaseRef(window.database, `workspaces/${this.workspaceId}/data`);
                
                // Store the unsubscribe function
                this.realtimeUnsubscribe = window.firebaseOnValue(workspaceRef, (snapshot) => {
                    if (snapshot.exists()) {
                        const data = snapshot.val();
                        // Only update if the data is newer
                        // Always merge remote changes, ignore timestamps for now to fix sync issues
                        console.log('ğŸ“¡ Received real-time update from Firebase');
                        console.log('ğŸ” Local projects before merge:', Object.keys(projects));
                        console.log('ğŸ” Remote projects to merge:', Object.keys(data.projects || {}));
                        
                        // Log current project tasks before merge
                        if (currentProject && projects[currentProject]) {
                            const localTasks = projects[currentProject].tasks;
                            console.log('ğŸ” Local tasks before merge:', {
                                todo: localTasks?.todo?.length || 0,
                                doing: localTasks?.doing?.length || 0,
                                done: localTasks?.done?.length || 0
                            });
                            console.log('ğŸ” Local TODO tasks:', localTasks?.todo || []);
                        }
                        
                        // Log remote project tasks
                        if (currentProject && data.projects[currentProject]) {
                            const remoteTasks = data.projects[currentProject].tasks;
                            console.log('ğŸ” Remote tasks before merge:', {
                                todo: remoteTasks?.todo?.length || 0,
                                doing: remoteTasks?.doing?.length || 0,
                                done: remoteTasks?.done?.length || 0
                            });
                            console.log('ğŸ” Remote TODO tasks:', remoteTasks?.todo || []);
                        }
                        
                        this.mergeRemoteChanges(data);
                        
                        // Log current project tasks after merge
                        if (currentProject && projects[currentProject]) {
                            const mergedTasks = projects[currentProject].tasks;
                            console.log('ğŸ” Local tasks after merge:', {
                                todo: mergedTasks?.todo?.length || 0,
                                doing: mergedTasks?.doing?.length || 0,
                                done: mergedTasks?.done?.length || 0
                            });
                            console.log('ğŸ” Final TODO tasks:', mergedTasks?.todo || []);
                        }
                        
                        // Show sync notification
                        this.showSyncNotification('Data synced from cloud');
                    }
                });
            }

            hasUnsavedChanges() {
                // Check if current data differs from last saved data
                const lastSavedData = localStorage.getItem(`lastSavedData_${this.workspaceId}`);
                if (!lastSavedData) return false;
                
                try {
                    const saved = JSON.parse(lastSavedData);
                    const current = {
                        projects: projects,
                        currentProject: currentProject,
                        projectTrash: projectTrash
                    };
                    
                    return JSON.stringify(saved) !== JSON.stringify(current);
                } catch (error) {
                    console.error('Error checking unsaved changes:', error);
                    return false;
                }
            }

            applyRemoteData(data) {
                const previousProject = currentProject;
                projects = data.projects;
                projectTrash = data.projectTrash || [];
                
                // Ensure all projects have proper structure
                Object.keys(projects).forEach(projectId => {
                    projects[projectId] = ensureProjectStructure(projects[projectId]);
                });
                
                // Update UI but keep current project active - Fixed renderKanbanBoard error
                renderProjects();
                renderTasks(); // Fixed: was renderKanbanBoard()
                
                console.log('âœ… Applied remote data successfully');
            }

            mergeRemoteChanges(remoteData) {
                console.log('ğŸ”„ Merging remote changes with local data');
                console.log('ğŸ” Current projects keys:', Object.keys(projects));
                console.log('ğŸ” Remote data keys:', Object.keys(remoteData.projects || {}));
                
                // Skip merge if we just saved to prevent overwriting our own changes
                const now = Date.now();
                if (this.lastSaveTime && (now - this.lastSaveTime) < 2000) {
                    console.log('â¸ï¸ Skipping merge - just saved data, preventing race condition');
                    return;
                }
                
                const localProjects = { ...projects };
                const remoteProjects = remoteData.projects || {};
                
                // Merge projects at task level
                Object.keys(remoteProjects).forEach(projectId => {
                    if (!localProjects[projectId]) {
                        // New project from remote - add it
                        console.log(`â• Adding new remote project: ${projectId}`);
                        localProjects[projectId] = remoteProjects[projectId];
                    } else {
                        // Project exists locally - merge tasks
                        console.log(`ğŸ”„ Merging tasks for project: ${projectId}`);
                        console.log(`ğŸ” BEFORE - Local tasks: TODO=${localProjects[projectId].tasks?.todo?.length || 0}, DOING=${localProjects[projectId].tasks?.doing?.length || 0}, DONE=${localProjects[projectId].tasks?.done?.length || 0}`);
                        console.log(`ğŸ” BEFORE - Remote tasks: TODO=${remoteProjects[projectId].tasks?.todo?.length || 0}, DOING=${remoteProjects[projectId].tasks?.doing?.length || 0}, DONE=${remoteProjects[projectId].tasks?.done?.length || 0}`);
                        
                        const mergedProject = this.mergeProjectTasks(
                            localProjects[projectId], 
                            remoteProjects[projectId]
                        );
                        
                        console.log(`ğŸ” AFTER - Merged tasks: TODO=${mergedProject.tasks?.todo?.length || 0}, DOING=${mergedProject.tasks?.doing?.length || 0}, DONE=${mergedProject.tasks?.done?.length || 0}`);
                        
                        localProjects[projectId] = mergedProject;
                    }
                });
                
                // Check for deleted projects (exist locally but not remotely)
                Object.keys(localProjects).forEach(projectId => {
                    if (!remoteProjects[projectId]) {
                        console.log(`â“ Local project not in remote: ${projectId} - keeping local version`);
                        // Keep local project - might be newly created
                    }
                });
                
                projects = localProjects;
                
                // Merge trash
                const localTrash = projectTrash || [];
                const remoteTrash = remoteData.projectTrash || [];
                const mergedTrash = [...localTrash];
                
                remoteTrash.forEach(remoteItem => {
                    if (!mergedTrash.find(local => local.originalId === remoteItem.originalId)) {
                        console.log(`â• Adding remote trash item: ${remoteItem.name}`);
                        mergedTrash.push(remoteItem);
                    }
                });
                
                projectTrash = mergedTrash;
                
                // Update UI - Fixed renderKanbanBoard error
                renderProjects();
                renderTasks(); // Fixed: was renderKanbanBoard() 
                
                console.log('âœ… Merge completed successfully');
                
                // Temporarily disable auto-save after merge to prevent race conditions
                // setTimeout(() => this.save(), 2000);
            }

            mergeProjectTasks(localProject, remoteProject) {
                // Create merged project with remote metadata but merged tasks
                const merged = {
                    ...remoteProject, // Use remote name, title, etc.
                    tasks: {
                        todo: this.mergeTaskLists(localProject.tasks?.todo || [], remoteProject.tasks?.todo || []),
                        doing: this.mergeTaskLists(localProject.tasks?.doing || [], remoteProject.tasks?.doing || []),
                        done: this.mergeTaskLists(localProject.tasks?.done || [], remoteProject.tasks?.done || [])
                    }
                };
                
                return merged;
            }

            mergeTaskLists(localTasks, remoteTasks) {
                console.log(`ğŸ” Merging task lists - Local: ${localTasks.length}, Remote: ${remoteTasks.length}`);
                
                // Simple merge: combine both lists and remove duplicates
                // This isn't perfect but prevents data loss
                const merged = [...localTasks];
                console.log(`ğŸ” Starting with ${merged.length} local tasks`);
                
                remoteTasks.forEach((remoteTask, index) => {
                    // Handle both string and object tasks for comparison
                    const remoteTaskText = typeof remoteTask === 'string' ? remoteTask : remoteTask.text;
                    console.log(`ğŸ” Processing remote task ${index}: ${remoteTaskText ? remoteTaskText.substring(0, 30) : 'unnamed task'}`);
                    
                    // Check if task already exists (compare text content)
                    let existingTaskIndex = -1;
                    const exists = merged.some((localTask, index) => {
                        const localTaskText = typeof localTask === 'string' ? localTask : localTask.text;
                        if (localTaskText === remoteTaskText) {
                            existingTaskIndex = index;
                            return true;
                        }
                        return false;
                    });
                    
                    if (!exists) {
                        merged.push(remoteTask);
                        const taskPreview = remoteTaskText ? remoteTaskText.substring(0, 30) : 'unnamed task';
                        console.log(`â• Adding remote task: ${taskPreview}... (merged list now has ${merged.length} tasks)`);
                    } else {
                        // Task exists - merge any additional properties (like images)
                        const existingTask = merged[existingTaskIndex];
                        const remoteTaskObj = typeof remoteTask === 'object' ? remoteTask : { text: remoteTask };
                        const existingTaskObj = typeof existingTask === 'string' ? { text: existingTask } : existingTask;
                        
                        // Preserve image data from either source
                        const mergedTaskObj = {
                            text: existingTaskObj.text || remoteTaskObj.text,
                            ...(existingTaskObj.image ? { image: existingTaskObj.image } : {}),
                            ...(remoteTaskObj.image ? { image: remoteTaskObj.image } : {})
                        };
                        
                        merged[existingTaskIndex] = mergedTaskObj;
                        const taskPreview = remoteTaskText ? remoteTaskText.substring(0, 30) : 'unnamed task';
                        const hasImage = mergedTaskObj.image ? ' (with image)' : '';
                        console.log(`ğŸ”„ Updated existing task: ${taskPreview}...${hasImage}`);
                    }
                });
                
                console.log(`ğŸ” Final merged list has ${merged.length} tasks`);
                return merged;
            }

            async syncOfflineChanges() {
                const hasPendingSync = localStorage.getItem('kanbanPendingSync');
                if (hasPendingSync && window.database) {
                    try {
                        await this.save();
                        localStorage.removeItem('kanbanPendingSync');
                        this.showSyncNotification('Offline changes synced');
                    } catch (error) {
                        console.error('Failed to sync offline changes:', error);
                    }
                }
            }

            showSyncNotification(message) {
                const notification = document.createElement('div');
                notification.textContent = `ğŸ”„ ${message}`;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #3b82f6;
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    font-size: 14px;
                    z-index: 10000;
                    opacity: 0;
                    transform: translateY(-10px);
                    transition: all 0.3s ease;
                `;
                
                document.body.appendChild(notification);
                
                // Animate in
                setTimeout(() => {
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateY(0)';
                }, 100);
                
                // Remove after 3 seconds
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateY(-10px)';
                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, 3000);
            }

            updateBackupStatus(success) {
                const statusEl = document.getElementById('backupStatus');
                if (!statusEl) return;

                const now = new Date().toLocaleTimeString();

                if (success.firebase && success.localStorage) {
                    statusEl.textContent = `â˜ï¸ Synced at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.firebase) {
                    statusEl.textContent = `â˜ï¸ Cloud saved at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.localStorage) {
                    statusEl.textContent = `ğŸ’¾ Local saved at ${now}`;
                    statusEl.style.color = 'rgba(255, 193, 7, 0.8)';
                } else {
                    statusEl.textContent = `âŒ Save failed at ${now}`;
                    statusEl.style.color = 'rgba(244, 67, 54, 0.8)';
                }

                setTimeout(() => {
                    if (this.isOnline) {
                        statusEl.textContent = 'â˜ï¸ Auto-syncing...';
                    } else {
                        statusEl.textContent = 'ğŸ’¾ Offline mode...';
                    }
                    statusEl.style.color = 'rgba(255, 255, 255, 0.7)';
                }, 3000);
            }

            // Export data to JSON file
            exportData() {
                const data = {
                    version: '1.0.0',
                    projects: projects,
                    currentProject: currentProject,
                    projectTrash: projectTrash || [],
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ultra-kanban-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.updateBackupStatus({ export: true, import: false });
            }

            // Import data from JSON file
            async importData(file) {
                try {
                    const text = await file.text();
                    const importedData = JSON.parse(text);

                    if (!this.validateData(importedData)) {
                        throw new Error('Invalid data format');
                    }

                    // Update global variables
                    projects = importedData.projects;
                    currentProject = importedData.currentProject;
                    projectTrash = importedData.projectTrash || [];

                    // Ensure all projects have proper structure
                    Object.keys(projects).forEach(projectId => {
                        projects[projectId] = ensureProjectStructure(projects[projectId]);
                    });

                    // Save to Firebase and localStorage
                    await this.save();

                    // Update UI
                    renderProjects();
                    renderTasks();
                    // Only render trash if currently visible
                    if (trashVisible) renderTrash();
                    switchProject(currentProject);

                    this.updateBackupStatus({ export: false, import: true });
                    this.showSyncNotification('Data imported successfully');

                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Import failed: ' + error.message);
                }
            }

            // Validate imported data structure
            validateData(data) {
                if (!data || typeof data !== 'object') return false;
                if (!data.version || !data.projects || !data.currentProject) return false;

                for (const [projectId, project] of Object.entries(data.projects)) {
                    if (!project.name || !project.title) return false;
                    // Don't require tasks structure as we can fix it with ensureProjectStructure
                }

                return true;
            }
        }

        // Legacy Storage Manager (keeping for backward compatibility)
        class StorageManager {
            constructor(workspaceId = 'personal') {
                this.workspaceId = workspaceId;
                this.storageKey = `kanbanProjects_${workspaceId}`;
                this.currentProjectKey = `currentProject_${workspaceId}`;
                this.versionKey = `kanbanVersion_${workspaceId}`;
                this.lastBackupKey = `lastBackup_${workspaceId}`;
                this.initIndexedDB();
            }

            // Initialize IndexedDB for robust storage
            async initIndexedDB() {
                try {
                    this.db = await new Promise((resolve, reject) => {
                        const request = indexedDB.open('UltraKanbanDB', 1);
                        request.onerror = () => reject(request.error);
                        request.onsuccess = () => resolve(request.result);
                        request.onupgradeneeded = (event) => {
                            const db = event.target.result;
                            if (!db.objectStoreNames.contains('projects')) {
                                db.createObjectStore('projects', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('backups')) {
                                const backupStore = db.createObjectStore('backups', { keyPath: 'id' });
                                backupStore.createIndex('timestamp', 'timestamp', { unique: false });
                            }
                        };
                    });
                } catch (error) {
                    console.warn('IndexedDB not available, using localStorage only:', error);
                }
            }

            // Validate data integrity
            validateData(data) {
                if (!data || typeof data !== 'object') return false;
                if (!data.version || !data.projects || !data.currentProject) return false;

                for (const [projectId, project] of Object.entries(data.projects)) {
                    if (!project.name || !project.title || !project.tasks) return false;
                    if (!project.tasks.todo || !project.tasks.doing || !project.tasks.done) return false;
                    if (!Array.isArray(project.tasks.todo) || !Array.isArray(project.tasks.doing) || !Array.isArray(project.tasks.done)) return false;
                }
                return true;
            }

            // Create timestamped data package
            createDataPackage() {
                return {
                    version: DATA_VERSION,
                    timestamp: new Date().toISOString(),
                    projects: structuredClone(projects),
                    currentProject: currentProject,
                    projectTrash: structuredClone(projectTrash),
                    metadata: {
                        totalProjects: Object.keys(projects).length,
                        totalTasks: Object.values(projects).reduce((sum, p) =>
                            sum + p.tasks.todo.length + p.tasks.doing.length + p.tasks.done.length, 0),
                        trashedProjects: projectTrash.length
                    }
                };
            }

            // Save to multiple storage backends
            async save() {
                const data = this.createDataPackage();
                const success = { localStorage: false, indexedDB: false };

                // Save to localStorage
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(data.projects));
                    localStorage.setItem(this.currentProjectKey, data.currentProject);
                    localStorage.setItem(this.versionKey, data.version);
                    localStorage.setItem(this.lastBackupKey, data.timestamp);
                    success.localStorage = true;
                } catch (error) {
                    console.error('localStorage save failed:', error);
                }

                // Save to IndexedDB
                if (this.db) {
                    try {
                        const transaction = this.db.transaction(['projects'], 'readwrite');
                        const store = transaction.objectStore('projects');
                        await store.put({ id: 'main', data: data });
                        success.indexedDB = true;
                    } catch (error) {
                        console.error('IndexedDB save failed:', error);
                    }
                }

                this.updateBackupStatus(success);
                return success;
            }

            // Load from storage with fallback
            async load() {
                let data = null;

                // Try IndexedDB first
                if (this.db) {
                    try {
                        const transaction = this.db.transaction(['projects'], 'readonly');
                        const store = transaction.objectStore('projects');
                        const result = await store.get('main');
                        if (result && result.data && this.validateData(result.data)) {
                            data = result.data;
                        }
                    } catch (error) {
                        console.warn('IndexedDB load failed:', error);
                    }
                }

                // Fallback to localStorage
                if (!data) {
                    try {
                        const savedProjects = localStorage.getItem(this.storageKey);
                        const savedCurrentProject = localStorage.getItem(this.currentProjectKey);
                        const savedVersion = localStorage.getItem(this.versionKey);

                        if (savedProjects) {
                            data = {
                                version: savedVersion || '1.0.0',
                                projects: JSON.parse(savedProjects),
                                currentProject: savedCurrentProject || 'default',
                                timestamp: localStorage.getItem(this.lastBackupKey) || new Date().toISOString()
                            };

                            if (!this.validateData(data)) {
                                throw new Error('Data validation failed');
                            }
                        }
                    } catch (error) {
                        console.error('localStorage load failed:', error);
                        data = null;
                    }
                }

                return data;
            }

            // Create backup in IndexedDB
            async createBackup() {
                if (!this.db) return false;

                try {
                    const data = this.createDataPackage();
                    const transaction = this.db.transaction(['backups'], 'readwrite');
                    const store = transaction.objectStore('backups');

                    const backupId = `backup_${Date.now()}`;
                    await store.put({
                        id: backupId,
                        timestamp: data.timestamp,
                        data: data
                    });

                    // Clean old backups
                    await this.cleanOldBackups();
                    return true;
                } catch (error) {
                    console.error('Backup creation failed:', error);
                    return false;
                }
            }

            // Clean old backups (keep only MAX_BACKUPS)
            async cleanOldBackups() {
                if (!this.db) return;

                try {
                    const transaction = this.db.transaction(['backups'], 'readwrite');
                    const store = transaction.objectStore('backups');
                    const index = store.index('timestamp');

                    const allBackups = await index.getAll();
                    if (allBackups.length > MAX_BACKUPS) {
                        const toDelete = allBackups
                            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp))
                            .slice(0, allBackups.length - MAX_BACKUPS);

                        for (const backup of toDelete) {
                            await store.delete(backup.id);
                        }
                    }
                } catch (error) {
                    console.error('Backup cleanup failed:', error);
                }
            }

            // Export data as JSON file
            exportData() {
                const data = this.createDataPackage();
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ultra-kanban-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.updateBackupStatus({ export: true });
            }

            // Import data from JSON file
            async importData(file) {
                try {
                    const text = await file.text();
                    const importedData = JSON.parse(text);

                    if (!this.validateData(importedData)) {
                        throw new Error('Invalid data format');
                    }

                    // Create backup before import
                    await this.createBackup();

                    // Apply imported data
                    projects = importedData.projects;
                    currentProject = importedData.currentProject || 'default';

                    // Save and render
                    await this.save();
                    renderProjects();
                    switchProject(currentProject);

                    this.updateBackupStatus({ import: true });
                    return true;
                } catch (error) {
                    console.error('Import failed:', error);
                    alert('Import failed: ' + error.message);
                    return false;
                }
            }

            // Update backup status display
            updateBackupStatus(success) {
                const statusEl = document.getElementById('backupStatus');
                const now = new Date().toLocaleTimeString();

                if (success.export) {
                    statusEl.textContent = `Exported at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.import) {
                    statusEl.textContent = `Imported at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.localStorage && success.indexedDB) {
                    statusEl.textContent = `All saved at ${now}`;
                    statusEl.style.color = 'rgba(76, 175, 80, 0.8)';
                } else if (success.localStorage || success.indexedDB) {
                    statusEl.textContent = `Partial save at ${now}`;
                    statusEl.style.color = 'rgba(255, 193, 7, 0.8)';
                } else {
                    statusEl.textContent = `Save failed at ${now}`;
                    statusEl.style.color = 'rgba(244, 67, 54, 0.8)';
                }

                setTimeout(() => {
                    statusEl.textContent = 'Auto-saving...';
                    statusEl.style.color = 'rgba(255, 255, 255, 0.7)';
                }, 3000);
            }
        }

        // Initialize storage manager
        const storage = new FirebaseStorageManager();

        // Define auth functions EARLY to ensure they're available for HTML onclick handlers
        function showLoginForm() {
            document.getElementById('userLoginForm').style.display = 'block';
            document.getElementById('userRegisterForm').style.display = 'none';
            document.getElementById('legacyLoginForm').style.display = 'none';
            document.getElementById('authFormDescription').textContent = 'Accede a tu cuenta personal';
        }

        function showRegisterForm() {
            document.getElementById('userLoginForm').style.display = 'none';
            document.getElementById('userRegisterForm').style.display = 'block';
            document.getElementById('legacyLoginForm').style.display = 'none';
            document.getElementById('authFormDescription').textContent = 'Crea tu cuenta personal';
        }

        function showLegacyLogin() {
            console.log('ğŸ”„ Switching to legacy login mode...');
            document.getElementById('userLoginForm').style.display = 'none';
            document.getElementById('userRegisterForm').style.display = 'none';
            document.getElementById('legacyLoginForm').style.display = 'block';
            document.getElementById('authFormDescription').textContent = 'Modo compatibilidad';
            
            // Initialize legacy mode
            console.log('ğŸš€ Calling initializeLegacyMode...');
            if (typeof initializeLegacyMode === 'function') {
                initializeLegacyMode();
            } else {
                console.error('âŒ initializeLegacyMode not yet available');
                setTimeout(() => {
                    if (typeof initializeLegacyMode === 'function') {
                        initializeLegacyMode();
                    }
                }, 100);
            }
        }

        // Make functions globally available
        window.showLoginForm = showLoginForm;
        window.showRegisterForm = showRegisterForm;
        window.showLegacyLogin = showLegacyLogin;

        // Placeholder functions for async operations - will be defined properly later
        async function handleUserLogin() { console.log('handleUserLogin called early - will be replaced'); }
        async function handleUserRegister() { console.log('handleUserRegister called early - will be replaced'); }
        async function checkPassword() { console.log('checkPassword called early - will be replaced'); }
        async function setupPassword() { console.log('setupPassword called early - will be replaced'); }
        
        // Make all functions globally available immediately
        window.handleUserLogin = handleUserLogin;
        window.handleUserRegister = handleUserRegister;
        window.checkPassword = checkPassword;
        window.setupPassword = setupPassword;

        console.log('âœ… Early auth functions defined:', {
            showLoginForm: typeof window.showLoginForm,
            showRegisterForm: typeof window.showRegisterForm, 
            showLegacyLogin: typeof window.showLegacyLogin,
            handleUserLogin: typeof window.handleUserLogin,
            handleUserRegister: typeof window.handleUserRegister,
            checkPassword: typeof window.checkPassword,
            setupPassword: typeof window.setupPassword,
            initializeLegacyMode: typeof window.initializeLegacyMode
        });

        // Password Protection System removed - using legacy PasswordManager instead

        // New User Authentication Manager
        class UserAuthManager {
            constructor() {
                this.userKey = 'kanbanCurrentUser';
                this.sessionKey = 'kanbanUserSession';
                this.sessionDuration = 365 * 24 * 60 * 60 * 1000; // 1 year
            }

            async hashEmail(email) {
                const encoder = new TextEncoder();
                const data = encoder.encode(email.toLowerCase().trim() + 'kanban_email_salt');
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            async hashPassword(password, email) {
                const encoder = new TextEncoder();
                const data = encoder.encode(password + email.toLowerCase() + 'kanban_pwd_salt');
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            async registerUser(email, password) {
                try {
                    console.log('ğŸ“ Registration attempt for:', email);
                    
                    // Validate Firebase is ready
                    if (!window.database || !window.firebaseGet || !window.firebaseSet) {
                        console.error('âŒ Firebase not properly initialized');
                        return { success: false, error: 'Sistema no disponible. Recarga la pÃ¡gina.' };
                    }

                    const emailHash = await this.hashEmail(email);
                    console.log('ğŸ“§ Email hash for registration:', emailHash.substring(0, 10) + '...');
                    
                    // Check if user already exists
                    const exists = await this.userExists(emailHash);
                    console.log('ğŸ‘¤ User exists check:', exists);
                    
                    if (exists) {
                        console.log('âŒ User already exists');
                        return { success: false, error: 'Usuario ya existe' };
                    }

                    const passwordHash = await this.hashPassword(password, email);
                    console.log('ğŸ”’ Password hash generated for registration');

                    console.log('ğŸ”¥ Creating user in Firebase...');
                    const userRef = window.firebaseRef(window.database, `users/${emailHash}`);
                    await window.firebaseSet(userRef, {
                        email: email.toLowerCase().trim(),
                        passwordHash: passwordHash,
                        created: new Date().toISOString(),
                        lastLogin: new Date().toISOString()
                    });
                    console.log('ğŸ‘¤ User created in Firebase');

                    console.log('ğŸ—‚ï¸ Creating user workspace...');
                    const workspaceRef = window.firebaseRef(window.database, `userWorkspaces/${emailHash}`);
                    await window.firebaseSet(workspaceRef, {
                        projects: {},
                        currentProject: null,
                        settings: {},
                        created: new Date().toISOString()
                    });
                    console.log('ğŸ—‚ï¸ User workspace created');

                    console.log('âœ… Registration successful for:', email);
                    return { success: true, userHash: emailHash };
                    
                } catch (error) {
                    console.error('ğŸ’¥ Registration exception:', error);
                    return { success: false, error: `Error en registro: ${error.message}` };
                }
            }

            async loginUser(email, password) {
                try {
                    console.log('ğŸ” Login attempt for:', email);
                    
                    // Validate Firebase is ready
                    if (!window.database || !window.firebaseGet || !window.firebaseUpdate) {
                        console.error('âŒ Firebase not properly initialized');
                        return { success: false, error: 'Sistema no disponible. Recarga la pÃ¡gina.' };
                    }

                    const emailHash = await this.hashEmail(email);
                    console.log('ğŸ“§ Email hash generated:', emailHash.substring(0, 10) + '...');
                    
                    const passwordHash = await this.hashPassword(password, email);
                    console.log('ğŸ”’ Password hash generated');

                    // Check user credentials
                    const userRef = window.firebaseRef(window.database, `users/${emailHash}`);
                    console.log('ğŸ” Checking user in Firebase...');
                    
                    let snapshot;
                    try {
                        snapshot = await window.firebaseGet(userRef);
                    } catch (firebaseError) {
                        console.error('ğŸ”¥ Firebase get error:', firebaseError);
                        return { success: false, error: 'Error de conexiÃ³n con la base de datos' };
                    }
                    
                    if (!snapshot.exists()) {
                        console.log('âŒ User not found in Firebase');
                        return { success: false, error: 'Usuario no encontrado' };
                    }

                    const userData = snapshot.val();
                    console.log('ğŸ‘¤ User data found:', { email: userData.email, created: userData.created });
                    
                    if (userData.passwordHash !== passwordHash) {
                        console.log('âŒ Password mismatch');
                        return { success: false, error: 'ContraseÃ±a incorrecta' };
                    }

                    console.log('âœ… Password verified, updating last login...');
                    
                    // Update last login (non-blocking)
                    try {
                        await window.firebaseUpdate(userRef, {
                            lastLogin: new Date().toISOString()
                        });
                        console.log('ğŸ“… Last login updated');
                    } catch (updateError) {
                        console.warn('âš ï¸ Could not update last login:', updateError);
                        // Don't fail login if we can't update timestamp
                    }

                    // Create session
                    const session = {
                        userHash: emailHash,
                        email: userData.email,
                        loginTime: Date.now(),
                        expires: Date.now() + this.sessionDuration
                    };

                    localStorage.setItem(this.userKey, emailHash);
                    sessionStorage.setItem(this.sessionKey, JSON.stringify(session));
                    
                    console.log('âœ… Login successful for:', userData.email);
                    return { success: true, userHash: emailHash, email: userData.email };

                } catch (error) {
                    console.error('ğŸ’¥ Login exception:', error);
                    return { success: false, error: `Error en login: ${error.message}` };
                }
            }

            async userExists(emailHash) {
                try {
                    if (window.database) {
                        const userRef = window.firebaseRef(window.database, `users/${emailHash}`);
                        const snapshot = await window.firebaseGet(userRef);
                        return snapshot.exists();
                    }
                    return false;
                } catch (error) {
                    console.error('User check failed:', error);
                    return false;
                }
            }

            getCurrentUser() {
                const session = sessionStorage.getItem(this.sessionKey);
                if (session) {
                    const parsed = JSON.parse(session);
                    if (parsed.expires > Date.now()) {
                        return {
                            userHash: parsed.userHash,
                            email: parsed.email,
                            isLoggedIn: true
                        };
                    }
                }
                return { isLoggedIn: false };
            }

            logout() {
                localStorage.removeItem(this.userKey);
                sessionStorage.removeItem(this.sessionKey);
                // Clear all kanban data
                localStorage.removeItem('kanbanProjects');
                localStorage.removeItem('currentProject');
                localStorage.removeItem('kanbanUserId');
                localStorage.removeItem('userWorkspaces');
            }

            isValidSession() {
                const user = this.getCurrentUser();
                return user.isLoggedIn;
            }
        }

        // Legacy Password Manager (Simple Password Mode)
        class PasswordManager {
            constructor() {
                this.userId = 'kanban_legacy_user';
                this.passwordKey = 'kanbanPassword';
                this.sessionKey = 'kanbanSession';
                this.sessionDuration = 7 * 24 * 60 * 60 * 1000; // 7 days
            }

            async hashPassword(password) {
                const encoder = new TextEncoder();
                const data = encoder.encode(password + 'kanban_salt');
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            }

            async setPassword(password) {
                const hashedPassword = await this.hashPassword(password);
                localStorage.setItem(this.passwordKey, hashedPassword);
                
                // Also save to Firebase if available
                if (window.database) {
                    try {
                        const passwordRef = window.firebaseRef(window.database, `legacyPasswords/${this.userId}`);
                        await window.firebaseSet(passwordRef, {
                            hash: hashedPassword,
                            created: new Date().toISOString()
                        });
                        console.log('ğŸ” Legacy password saved to Firebase');
                    } catch (error) {
                        console.error('Failed to save legacy password to Firebase:', error);
                    }
                }
            }

            async checkPassword(password) {
                const hashedPassword = await this.hashPassword(password);
                
                // Check Firebase first (for cross-device sync)
                if (window.database) {
                    try {
                        const passwordRef = window.firebaseRef(window.database, `legacyPasswords/${this.userId}`);
                        const snapshot = await window.firebaseGet(passwordRef);
                        if (snapshot.exists()) {
                            const data = snapshot.val();
                            return data.hash === hashedPassword;
                        }
                    } catch (error) {
                        console.error('Failed to check Firebase password:', error);
                    }
                }
                
                // Fall back to localStorage
                const savedHash = localStorage.getItem(this.passwordKey);
                return savedHash === hashedPassword;
            }

            async hasPassword() {
                // Check Firebase first
                if (window.database) {
                    try {
                        const passwordRef = window.firebaseRef(window.database, `legacyPasswords/${this.userId}`);
                        const snapshot = await window.firebaseGet(passwordRef);
                        if (snapshot.exists()) {
                            return true;
                        }
                    } catch (error) {
                        console.error('Failed to check Firebase password:', error);
                    }
                }
                
                // Check localStorage
                return localStorage.getItem(this.passwordKey) !== null;
            }

            createSession() {
                const sessionData = {
                    timestamp: Date.now(),
                    expires: Date.now() + this.sessionDuration
                };
                sessionStorage.setItem(this.sessionKey, JSON.stringify(sessionData));
            }

            isSessionValid() {
                const sessionData = sessionStorage.getItem(this.sessionKey);
                if (!sessionData) return false;
                
                try {
                    const session = JSON.parse(sessionData);
                    return Date.now() < session.expires;
                } catch {
                    return false;
                }
            }

            clearSession() {
                sessionStorage.removeItem(this.sessionKey);
            }
        }

        const userAuth = new UserAuthManager();
        const passwordManager = new PasswordManager();

        // New User Authentication UI Functions
        // Auth UI functions now defined early for immediate availability

        // Functions are assigned to window immediately after definition

        // Replace placeholder with real implementation
        handleUserLogin = async function() {
            const email = document.getElementById('emailInput').value.trim();
            const password = document.getElementById('userPasswordInput').value;
            const errorDiv = document.getElementById('userLoginError');

            if (!email || !password) {
                errorDiv.textContent = 'Email y contraseÃ±a son requeridos';
                errorDiv.style.display = 'block';
                return;
            }

            if (!email.includes('@')) {
                errorDiv.textContent = 'Ingresa un email vÃ¡lido';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                errorDiv.style.display = 'none';
                console.log('ğŸ” Starting login for:', email);
                const result = await userAuth.loginUser(email, password);
                console.log('ğŸ” Login result:', result);
                
                if (result.success) {
                    console.log(`ğŸ”‘ User logged in successfully: ${result.email}`);
                    await initializeUserSession(result.userHash, result.email);
                } else {
                    console.error('âŒ Login failed:', result.error);
                    errorDiv.textContent = result.error;
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('ğŸ’¥ Login exception:', error);
                errorDiv.textContent = 'Error al iniciar sesiÃ³n: ' + error.message;
                errorDiv.style.display = 'block';
            }
        };

        // Replace placeholder with real implementation  
        handleUserRegister = async function() {
            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value;
            const confirmPassword = document.getElementById('registerConfirmPassword').value;
            const errorDiv = document.getElementById('userRegisterError');

            if (!email || !password || !confirmPassword) {
                errorDiv.textContent = 'Todos los campos son requeridos';
                errorDiv.style.display = 'block';
                return;
            }

            if (!email.includes('@')) {
                errorDiv.textContent = 'Ingresa un email vÃ¡lido';
                errorDiv.style.display = 'block';
                return;
            }

            if (password !== confirmPassword) {
                errorDiv.textContent = 'Las contraseÃ±as no coinciden';
                errorDiv.style.display = 'block';
                return;
            }

            if (password.length < 6) {
                errorDiv.textContent = 'La contraseÃ±a debe tener al menos 6 caracteres';
                errorDiv.style.display = 'block';
                return;
            }

            try {
                errorDiv.style.display = 'none';
                console.log('ğŸš€ Starting user registration for:', email);
                const result = await userAuth.registerUser(email, password);
                console.log('ğŸ“ Registration result:', result);
                
                if (result.success) {
                    console.log(`âœ¨ User registered successfully: ${email}`);
                    // Auto-login after registration
                    console.log('ğŸ” Auto-login after registration...');
                    const loginResult = await userAuth.loginUser(email, password);
                    console.log('ğŸ” Auto-login result:', loginResult);
                    if (loginResult.success) {
                        console.log('âœ… Auto-login successful, initializing session...');
                        await initializeUserSession(loginResult.userHash, email);
                    } else {
                        console.error('âŒ Auto-login failed:', loginResult.error);
                        errorDiv.textContent = 'Registro exitoso pero fallÃ³ el login automÃ¡tico. Intenta hacer login manualmente.';
                        errorDiv.style.display = 'block';
                    }
                } else {
                    console.error('âŒ Registration failed:', result.error);
                    errorDiv.textContent = result.error;
                    errorDiv.style.display = 'block';
                }
            } catch (error) {
                console.error('ğŸ’¥ Registration exception:', error);
                errorDiv.textContent = 'Error al registrar usuario: ' + error.message;
                errorDiv.style.display = 'block';
            }
        };

        async function initializeUserSession(userHash, email) {
            // Update storage to use the new user system
            storage.userId = userHash;
            
            // Load user data from Firebase
            await loadUserData(userHash);
            
            // Initialize workspaces AFTER user authentication
            console.log('ğŸ—‚ï¸ Initializing workspaces for user:', email);
            initializeWorkspaces();
            await loadWorkspacesFromFirebase();
            setupWorkspacesRealtimeListener();
            
            // Hide password overlay and show app
            document.getElementById('passwordOverlay').style.display = 'none';
            document.getElementById('appContent').style.display = 'flex';
            
            // Update UI with user info
            updateUserInterface(email);
            
            // Render workspace dropdown
            renderWorkspaceDropdown();
            
            // Render projects and initialize app
            renderProjects();
            if (currentProject && projects[currentProject]) {
                switchProject(currentProject);
            } else if (Object.keys(projects).length > 0) {
                switchProject(Object.keys(projects)[0]);
            } else {
                // Show create board message for empty workspace
                console.log('ğŸ”§ Setting empty workspace message');
                const boardTitle = document.getElementById('boardTitle');
                if (boardTitle) {
                    boardTitle.value = 'Please, create a Board';
                    boardTitle.disabled = true;
                    boardTitle.style.color = '#6b7280';
                    boardTitle.style.fontStyle = 'italic';
                    console.log('âœ… Board title set to:', boardTitle.value);
                }
            }
        }

        async function loadUserData(userHash) {
            try {
                if (window.database) {
                    const workspaceRef = window.firebaseRef(window.database, `userWorkspaces/${userHash}`);
                    const snapshot = await window.firebaseGet(workspaceRef);
                    
                    if (snapshot.exists()) {
                        const userData = snapshot.val();
                        projects = userData.projects || {};
                        currentProject = userData.currentProject;
                        console.log(`ğŸ“Š Loaded ${Object.keys(projects).length} boards for user`);
                    } else {
                        // Initialize empty user workspace
                        projects = {};
                        currentProject = null;
                        await saveUserData(userHash);
                    }
                }
            } catch (error) {
                console.error('Failed to load user data:', error);
                projects = {};
                currentProject = null;
            }
        }

        async function saveUserData(userHash) {
            try {
                if (window.database) {
                    const workspaceRef = window.firebaseRef(window.database, `userWorkspaces/${userHash}`);
                    await window.firebaseSet(workspaceRef, {
                        projects: projects,
                        currentProject: currentProject,
                        settings: {},
                        lastUpdate: new Date().toISOString()
                    });
                }
                
                // Also save to localStorage for offline access (workspace-specific keys)
                const workspaceId = currentWorkspace || 'personal';
                localStorage.setItem(`kanbanProjects_${workspaceId}`, JSON.stringify(projects));
                localStorage.setItem(`currentProject_${workspaceId}`, currentProject || '');
            } catch (error) {
                console.error('Failed to save user data:', error);
            }
        }

        function updateUserInterface(email) {
            // Add user info below the kanban board, centered
            const mainContent = document.querySelector('.main-content');
            const userInfoDiv = document.createElement('div');
            userInfoDiv.className = 'user-info-bottom';
            userInfoDiv.innerHTML = `
                <div style="display: flex; justify-content: center; align-items: center; margin-top: 20px; padding: 8px 16px; background: rgba(255,255,255,0.8); border-radius: 8px; font-size: 12px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <span style="color: #374151; font-weight: 500; margin-right: 12px;">ğŸ‘¤ Conectado como: ${email}</span>
                    <button onclick="handleLogout()" style="background: #ef4444; color: white; padding: 4px 12px; border: none; border-radius: 4px; font-size: 11px; cursor: pointer; transition: background 0.2s;">Cerrar SesiÃ³n</button>
                </div>
            `;
            
            // Insert at the end of main content
            mainContent.appendChild(userInfoDiv);
        }

        function handleLogout() {
            if (confirm('Â¿Seguro que deseas cerrar sesiÃ³n?')) {
                userAuth.logout();
                location.reload();
            }
        }

        function createDefaultProject() {
            const projectId = 'project_' + Date.now();
            projects[projectId] = {
                name: 'MI PRIMER BOARD',
                title: 'Mi Primer Board',
                tasks: {
                    todo: [],
                    doing: [],
                    done: []
                }
            };
            currentProject = projectId;
            saveUserData(userAuth.getCurrentUser().userHash);
        }

        // Password UI Functions (Legacy System)
        // Replace placeholder with real implementation
        checkPassword = async function() {
            console.log('ğŸ” Checking password...');
            const password = document.getElementById('passwordInput').value;
            const errorDiv = document.getElementById('passwordError');

            if (!password) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Ingresa una contraseÃ±a';
                return;
            }

            const isValid = await passwordManager.checkPassword(password);
            if (isValid) {
                passwordManager.createSession();
                unlockApp();
            } else {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'ContraseÃ±a incorrecta';
                document.getElementById('passwordInput').value = '';
                document.getElementById('passwordInput').focus();
            }
        };

        // Replace placeholder with real implementation  
        setupPassword = async function() {
            console.log('ğŸ“ Setting up new password...');
            const newPassword = document.getElementById('newPasswordInput').value;
            const confirmPassword = document.getElementById('confirmPasswordInput').value;
            const errorDiv = document.getElementById('setupError');

            if (!newPassword || newPassword.length < 4) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'La contraseÃ±a debe tener al menos 4 caracteres';
                return;
            }

            if (newPassword !== confirmPassword) {
                errorDiv.style.display = 'block';
                errorDiv.textContent = 'Las contraseÃ±as no coinciden';
                return;
            }

            await passwordManager.setPassword(newPassword);
            passwordManager.createSession();
            unlockApp();
        };

        // Verify all auth functions are properly loaded
        console.log('âœ… Auth functions loaded:', {
            showLoginForm: typeof window.showLoginForm,
            showRegisterForm: typeof window.showRegisterForm,
            showLegacyLogin: typeof window.showLegacyLogin,
            handleUserLogin: typeof window.handleUserLogin,
            handleUserRegister: typeof window.handleUserRegister,
            checkPassword: typeof window.checkPassword,
            setupPassword: typeof window.setupPassword
        });

        async function unlockApp() {
            document.getElementById('passwordOverlay').style.display = 'none';
            document.getElementById('appContent').classList.add('unlocked');
            
            // Initialize workspaces for legacy users
            console.log('ğŸ—‚ï¸ Initializing workspaces for legacy user');
            initializeWorkspaces();
            await loadWorkspacesFromFirebase();
            setupWorkspacesRealtimeListener();
            renderWorkspaceDropdown();
            
            loadData(); // Load the application data
        }

        function lockApp() {
            passwordManager.clearSession();
            document.getElementById('passwordOverlay').style.display = 'flex';
            document.getElementById('appContent').classList.remove('unlocked');
            document.getElementById('passwordInput').value = '';
            document.getElementById('passwordError').style.display = 'none';
        }

        // Initialize password protection
        async function initializePasswordProtection() {
            console.log('ğŸ” Initializing authentication system...');
            
            // First check if user has a valid session with new system
            const currentUser = userAuth.getCurrentUser();
            if (currentUser.isLoggedIn) {
                console.log('âœ… Valid user session found:', currentUser.email);
                await initializeUserSession(currentUser.userHash, currentUser.email);
                return;
            }

            // Check for legacy session
            if (passwordManager.isSessionValid()) {
                console.log('âœ… Valid legacy session found, unlocking app');
                unlockApp();
                return;
            }

            // Show the new login form by default
            console.log('ğŸ‘¤ No valid session, showing user authentication');
            showLoginForm();
            document.getElementById('emailInput').focus();
        }

        // Define initializeLegacyMode function
        async function initializeLegacyMode() {
            console.log('ğŸ”§ Initializing legacy mode...');
            
            try {
                const hasPassword = await passwordManager.hasPassword();
                console.log('ğŸ” Has password check result:', hasPassword);
                
                if (hasPassword) {
                    // Show login form
                    console.log('ğŸ”‘ Password exists - showing login form');
                    document.getElementById('loginForm').style.display = 'block';
                    document.getElementById('setupForm').style.display = 'none';
                    document.getElementById('passwordInput').focus();
                } else {
                    // Show password setup form
                    console.log('ğŸ“ No password - showing setup form');
                    document.getElementById('loginForm').style.display = 'none';
                    document.getElementById('setupForm').style.display = 'block';
                    document.getElementById('newPasswordInput').focus();
                }
            } catch (error) {
                console.error('âŒ Error initializing legacy mode:', error);
                // Fallback to setup form
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('setupForm').style.display = 'block';
                document.getElementById('newPasswordInput').focus();
            }
        }
        window.initializeLegacyMode = initializeLegacyMode;

        // Handle Enter key in authentication inputs
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                // New user system
                if (document.getElementById('userPasswordInput') === document.activeElement || 
                    document.getElementById('emailInput') === document.activeElement) {
                    handleUserLogin();
                } else if (document.getElementById('registerConfirmPassword') === document.activeElement ||
                          document.getElementById('registerPassword') === document.activeElement ||
                          document.getElementById('registerEmail') === document.activeElement) {
                    handleUserRegister();
                } 
                // Legacy system
                else if (document.getElementById('passwordInput') === document.activeElement) {
                    checkPassword();
                } else if (document.getElementById('confirmPasswordInput') === document.activeElement ||
                          document.getElementById('newPasswordInput') === document.activeElement) {
                    setupPassword();
                }
            }
        });

        // Load data with enhanced persistence
        // Ensure project has proper structure
        function ensureProjectStructure(project) {
            if (!project.tasks) {
                project.tasks = {
                    todo: [],
                    doing: [],
                    done: []
                };
            }
            if (!project.tasks.todo) project.tasks.todo = [];
            if (!project.tasks.doing) project.tasks.doing = [];
            if (!project.tasks.done) project.tasks.done = [];
            return project;
        }

        async function loadData() {
            try {
                const data = await storage.load();
                if (data) {
                    projects = data.projects;
                    currentProject = data.currentProject;
                    projectTrash = data.projectTrash || [];
                    
                    // Ensure all projects have proper structure
                    Object.keys(projects).forEach(projectId => {
                        projects[projectId] = ensureProjectStructure(projects[projectId]);
                    });
                }
            } catch (error) {
                console.error('Failed to load data:', error);
            }

            renderProjects();
            // Don't auto-render trash - only show when toggled
            switchProject(currentProject);
        }

        // Save data with enhanced persistence
        async function saveData() {
            try {
                // Always use the workspace storage system for consistent data paths
                await storage.save();
            } catch (error) {
                console.error('Failed to save data:', error);
            }
        }

        // Auto-save every 30 seconds
        setInterval(saveData, 30000);

        // Save before page unload
        window.addEventListener('beforeunload', saveData);

        // Periodic backup (every 5 minutes)
        setInterval(async () => {
            try {
                await storage.createBackup();
            } catch (error) {
                console.error('Auto-backup failed:', error);
            }
        }, 5 * 60 * 1000);

        // Global functions for UI
        function exportData() {
            storage.exportData();
        }

        function createBackup() {
            storage.createBackup().then(success => {
                if (success) {
                    storage.updateBackupStatus({ export: false, import: false });
                } else {
                    alert('Backup creation failed. Check console for details.');
                }
            });
        }

        function importData(event) {
            const file = event.target.files[0];
            if (file) {
                storage.importData(file);
                event.target.value = ''; // Reset input
            }
        }

        // Import tasks from text file
        async function importTasksFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            try {
                const text = await file.text();
                const lines = text.split(/\r?\n/)
                    .map(line => line.trim())
                    .filter(line => line.length > 0); // Remove empty lines

                if (lines.length === 0) {
                    alert('No valid tasks found in the file.');
                    return;
                }

                // Add tasks to the current project's TODO column
                const addedTasks = [];
                lines.forEach(line => {
                    if (line.length > 0) {
                        projects[currentProject].tasks.todo.push(line);
                        addedTasks.push(line);
                    }
                });

                // Save and refresh the UI
                await saveData();
                renderTasks();

                // Show success feedback
                showTaskImportFeedback(addedTasks.length, file.name);

                // Reset input
                event.target.value = '';

            } catch (error) {
                console.error('Task import failed:', error);
                alert('Failed to import tasks: ' + error.message);
                event.target.value = '';
            }
        }

        // Show feedback for task import
        function showTaskImportFeedback(count, filename) {
            const statusEl = document.getElementById('backupStatus');
            const originalText = statusEl.textContent;
            const originalColor = statusEl.style.color;

            statusEl.textContent = `Imported ${count} tasks from ${filename}`;
            statusEl.style.color = 'rgba(76, 175, 80, 0.8)';

            setTimeout(() => {
                statusEl.textContent = originalText;
                statusEl.style.color = originalColor;
            }, 4000);
        }

        // Render projects in sidebar
        function renderProjects() {
            const projectList = document.getElementById('projectList');
            projectList.innerHTML = '';
            
            // Add drag and drop event listeners to the container
            projectList.addEventListener('dragover', handleProjectDragOver);
            projectList.addEventListener('drop', handleProjectDrop);

            Object.keys(projects).forEach(projectId => {
                const projectDiv = document.createElement('div');
                projectDiv.className = `project-item ${projectId === currentProject ? 'active' : ''}`;
                projectDiv.setAttribute('data-project', projectId);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'project-item-content';

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.className = 'project-name';
                nameInput.value = projects[projectId].name;
                nameInput.readOnly = true;
                nameInput.setAttribute('data-project-id', projectId);

                // Double-click to edit
                nameInput.addEventListener('dblclick', () => startEditingProjectName(nameInput, projectId));

                // Handle enter/escape keys
                nameInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        finishEditingProjectName(nameInput, projectId);
                    } else if (e.key === 'Escape') {
                        cancelEditingProjectName(nameInput, projectId);
                    }
                });

                // Handle blur (clicking outside)
                nameInput.addEventListener('blur', () => {
                    if (!nameInput.readOnly) {
                        finishEditingProjectName(nameInput, projectId);
                    }
                });

                contentDiv.appendChild(nameInput);

                // Add task count badge
                const taskCount = projects[projectId].tasks?.todo?.length || 0;
                const countBadge = document.createElement('span');
                countBadge.className = `task-count ${taskCount === 0 ? 'zero' : ''}`;
                countBadge.textContent = taskCount;
                countBadge.title = `${taskCount} tareas pendientes`;
                contentDiv.appendChild(countBadge);

                // Add right-click context menu
                projectDiv.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showProjectContextMenu(e, projectId);
                });

                projectDiv.appendChild(contentDiv);

                // Click to switch project (but not when editing)
                // Add drag and drop functionality
                projectDiv.draggable = true;
                projectDiv.addEventListener('dragstart', handleProjectDragStart);
                projectDiv.addEventListener('dragover', handleProjectDragOver);
                projectDiv.addEventListener('drop', handleProjectDrop);
                projectDiv.addEventListener('dragend', handleProjectDragEnd);

                projectDiv.onclick = (e) => {
                    if (e.target === nameInput && !nameInput.readOnly) {
                        return; // Don't switch if editing
                    }
                    if (e.target.className !== 'delete-task') {
                        switchProject(projectId);
                    }
                };

                projectList.appendChild(projectDiv);
            });
        }

        // Project drag and drop functionality
        let draggedProject = null;

        function handleProjectDragStart(e) {
            draggedProject = e.target.getAttribute('data-project');
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleProjectDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            // Remove existing drag-over classes
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('drag-over');
            });

            // Add drag-over class to current target
            const targetProject = e.target.closest('.project-item');
            if (targetProject && targetProject.getAttribute('data-project') !== draggedProject) {
                targetProject.classList.add('drag-over');
            }
        }

        function handleProjectDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            
            const targetElement = e.target.closest('.project-item');
            if (!targetElement) return;
            
            const targetProjectId = targetElement.getAttribute('data-project');

            if (draggedProject && targetProjectId && draggedProject !== targetProjectId) {
                reorderProjects(draggedProject, targetProjectId);
                renderProjects(); // Re-render to show new order
                saveData(); // Save the new order
            }

            // Clean up
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('drag-over');
            });
        }

        function handleProjectDragEnd(e) {
            e.target.classList.remove('dragging');
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('drag-over');
            });
            draggedProject = null;
        }

        function reorderProjects(draggedId, targetId) {
            const projectKeys = Object.keys(projects);
            const draggedIndex = projectKeys.indexOf(draggedId);
            const targetIndex = projectKeys.indexOf(targetId);

            if (draggedIndex !== -1 && targetIndex !== -1) {
                // Remove dragged project from array
                projectKeys.splice(draggedIndex, 1);
                // Insert at target position
                projectKeys.splice(targetIndex, 0, draggedId);

                // Rebuild projects object in new order
                const reorderedProjects = {};
                projectKeys.forEach(key => {
                    reorderedProjects[key] = projects[key];
                });
                projects = reorderedProjects;

                saveData();
                renderProjects();
            }
        }

        // Switch between projects
        function switchProject(projectId) {
            currentProject = projectId;
            document.getElementById('currentProject').textContent = projects[projectId].name;
            
            const boardTitle = document.getElementById('boardTitle');
            boardTitle.value = projects[projectId].title;
            boardTitle.disabled = false;
            boardTitle.style.color = '#1f2937'; // Reset to normal color
            boardTitle.style.fontStyle = 'normal'; // Reset italic

            // Update active project in sidebar
            document.querySelectorAll('.project-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelector(`[data-project="${projectId}"]`).classList.add('active');

            // Render tasks for current project
            renderTasks();
            saveData();
        }

        // Render tasks for current project
        function renderTasks() {
            // Defensive check for valid project data
            if (!currentProject || !projects[currentProject] || !projects[currentProject].tasks) {
                console.log('âš ï¸ No valid board data for rendering tasks');
                clearAllTasks();
                return;
            }
            
            console.log('ğŸ¨ Rendering tasks for board:', currentProject);
            const columns = ['todo', 'doing', 'done'];
            columns.forEach(column => {
                const taskList = document.getElementById(column + 'List');
                if (!taskList) return;
                
                taskList.innerHTML = '';

                const tasks = projects[currentProject].tasks[column] || [];
                tasks.forEach((task, index) => {
                    // Create drop indicator
                    const dropIndicator = document.createElement('div');
                    dropIndicator.className = 'drop-indicator';
                    dropIndicator.setAttribute('data-drop-index', index);
                    dropIndicator.setAttribute('data-column', column);
                    taskList.appendChild(dropIndicator);

                    // Create task item
                    const taskDiv = document.createElement('div');
                    taskDiv.className = 'task-item';
                    taskDiv.draggable = true;
                    taskDiv.setAttribute('data-task-id', index);
                    taskDiv.setAttribute('data-column', column);

                    // Create task wrapper
                    const wrapperDiv = document.createElement('div');
                    wrapperDiv.className = 'task-item-wrapper';

                    // Create editable task content
                    const taskContent = document.createElement('div');
                    taskContent.className = 'task-content';
                    taskContent.contentEditable = false;
                    // Display task text properly (handle both string tasks and object tasks)
                    const taskText = typeof task === 'string' ? task : (task.text || task);
                    taskContent.innerHTML = makeURLsClickable(taskText);
                    taskContent.setAttribute('data-task-id', index);
                    taskContent.setAttribute('data-column', column);

                    // Add single-click to edit and double-click to copy
                    let clickTimer = null;
                    taskContent.addEventListener('click', (e) => {
                        // Prevent editing when dragging
                        if (e.target.closest('.task-item').classList.contains('dragging')) return;

                        if (clickTimer) {
                            // This is a double-click
                            clearTimeout(clickTimer);
                            clickTimer = null;
                            copyTaskText(taskContent);
                        } else {
                            // This might be a single-click, wait to see if double-click follows
                            clickTimer = setTimeout(() => {
                                clickTimer = null;
                                if (taskContent.contentEditable !== 'true') {
                                    startEditingTask(taskContent, column, index);
                                }
                            }, 250);
                        }
                    });

                    // Handle enter/escape keys
                    taskContent.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            finishEditingTask(taskContent, column, index);
                        } else if (e.key === 'Escape') {
                            cancelEditingTask(taskContent, column, index);
                        }
                    });

                    // Handle blur (clicking outside)
                    taskContent.addEventListener('blur', () => {
                        if (taskContent.contentEditable === 'true') {
                            finishEditingTask(taskContent, column, index);
                        }
                    });

                    // Check if task has image attachment (handle both string tasks and object tasks)
                    const taskData = typeof task === 'string' ? { text: task } : task;
                    const hasImage = taskData.image;
                    
                    // Create task actions container
                    const actionsContainer = document.createElement('div');
                    actionsContainer.className = 'task-actions-container';
                    
                    // Add subtle image indicator if task has image
                    if (hasImage) {
                        const imageIndicator = document.createElement('div');
                        imageIndicator.className = 'task-image-mark';
                        imageIndicator.title = 'This task has an image attachment - right-click task for image options';
                        wrapperDiv.appendChild(imageIndicator);
                    }
                    
                    // Create delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'delete-task';
                    deleteBtn.textContent = 'Ã—';
                    deleteBtn.onclick = () => deleteTask(column, index);
                    
                    actionsContainer.appendChild(deleteBtn);

                    wrapperDiv.appendChild(taskContent);
                    wrapperDiv.appendChild(actionsContainer);
                    taskDiv.appendChild(wrapperDiv);

                    // Add drag event listeners
                    taskDiv.addEventListener('dragstart', handleTaskDragStart);
                    taskDiv.addEventListener('dragend', handleTaskDragEnd);
                    taskDiv.addEventListener('dragover', handleTaskDragOver);
                    taskDiv.addEventListener('drop', handleTaskDrop);
                    
                    // Add right-click context menu for image functionality
                    taskDiv.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        showTaskContextMenu(e, column, index);
                    });
                    
                    // Add hover tooltip for right-click instructions
                    let hoverTimeout;
                    taskDiv.addEventListener('mouseenter', (e) => {
                        hoverTimeout = setTimeout(() => {
                            showRightClickTooltip(e, taskDiv);
                        }, 1000); // Show after 1 second
                    });
                    
                    taskDiv.addEventListener('mouseleave', () => {
                        clearTimeout(hoverTimeout);
                        hideRightClickTooltip();
                    });

                    taskList.appendChild(taskDiv);
                });

                // Add final drop indicator
                const finalDropIndicator = document.createElement('div');
                finalDropIndicator.className = 'drop-indicator';
                finalDropIndicator.setAttribute('data-drop-index', projects[currentProject].tasks[column].length);
                finalDropIndicator.setAttribute('data-column', column);
                taskList.appendChild(finalDropIndicator);
            });
        }

        // Create new project
        function createProject() {
            document.getElementById('projectModal').style.display = 'flex';
            document.getElementById('projectInput').focus();
        }

        function addProject() {
            const projectName = document.getElementById('projectInput').value.trim().toUpperCase();
            if (projectName) {
                const projectId = 'project_' + Date.now();
                projects[projectId] = {
                    name: projectName,
                    title: projectName,
                    tasks: {
                        todo: [],
                        doing: [],
                        done: []
                    }
                };
                renderProjects();
                switchProject(projectId);
                closeProjectModal();
            }
        }

        function deleteProject(projectId, event) {
            event.stopPropagation();
            if (confirm('Move this board to trash? You can restore it later.')) {
                // Move project to trash
                const trashedProject = {
                    ...projects[projectId],
                    originalId: projectId,
                    trashedAt: Date.now()
                };
                projectTrash.push(trashedProject);

                // Remove from active projects
                delete projects[projectId];
                if (currentProject === projectId) {
                    switchProject('default');
                }

                renderProjects();
                // Only render trash if currently visible
                if (trashVisible) renderTrash();
                saveData();

                // Show success message
                showNotification(`Board "${trashedProject.name}" moved to trash`, '#dc2626');
            }
        }

        function duplicateProject(projectId, event) {
            event.stopPropagation();
            const originalProject = projects[projectId];
            const newProjectId = 'project_' + Date.now();
            const newProjectName = originalProject.name + ' COPY';

            projects[newProjectId] = {
                name: newProjectName,
                title: originalProject.title + ' Copy',
                tasks: {
                    todo: [...originalProject.tasks.todo],
                    doing: [...originalProject.tasks.doing],
                    done: [...originalProject.tasks.done]
                }
            };

            renderProjects();
            saveData();

            // Show feedback
            const notification = document.createElement('div');
            notification.textContent = `Board "${newProjectName}" created successfully!`;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                z-index: 1000;
                font-size: 14px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Context menu functionality
        let contextMenuProjectId = null;

        function showProjectContextMenu(event, projectId) {
            const contextMenu = document.getElementById('projectContextMenu');
            contextMenuProjectId = projectId;

            // Show/hide delete option for default project
            const deleteItem = contextMenu.querySelector('.delete');
            if (projectId === 'default') {
                deleteItem.style.display = 'none';
            } else {
                deleteItem.style.display = 'flex';
            }

            // Position and show context menu
            contextMenu.style.left = event.clientX + 'px';
            contextMenu.style.top = event.clientY + 'px';
            contextMenu.style.display = 'block';

            // Close context menu when clicking elsewhere
            document.addEventListener('click', hideProjectContextMenu);
        }

        function hideProjectContextMenu() {
            const contextMenu = document.getElementById('projectContextMenu');
            contextMenu.style.display = 'none';
            document.removeEventListener('click', hideProjectContextMenu);
        }

        function duplicateProjectFromMenu() {
            if (contextMenuProjectId) {
                duplicateProject(contextMenuProjectId, { stopPropagation: () => {} });
                hideProjectContextMenu();
            }
        }

        function deleteProjectFromMenu() {
            if (contextMenuProjectId && contextMenuProjectId !== 'default') {
                deleteProject(contextMenuProjectId, { stopPropagation: () => {} });
                hideProjectContextMenu();
            }
        }

        // Trash context menu functionality
        let contextMenuTrashIndex = null;

        function showTrashContextMenu(event, trashIndex) {
            const contextMenu = document.getElementById('trashContextMenu');
            contextMenuTrashIndex = trashIndex;

            contextMenu.style.left = event.clientX + 'px';
            contextMenu.style.top = event.clientY + 'px';
            contextMenu.style.display = 'block';

            document.addEventListener('click', hideTrashContextMenu);
        }

        function hideTrashContextMenu() {
            const contextMenu = document.getElementById('trashContextMenu');
            contextMenu.style.display = 'none';
            document.removeEventListener('click', hideTrashContextMenu);
        }

        function restoreProjectFromMenu() {
            if (contextMenuTrashIndex !== null) {
                restoreProject(contextMenuTrashIndex);
                hideTrashContextMenu();
            }
        }

        function permanentDeleteFromMenu() {
            if (contextMenuTrashIndex !== null) {
                permanentDelete(contextMenuTrashIndex);
                hideTrashContextMenu();
            }
        }

        // Trash management functions
        // Track trash visibility state
        let trashVisible = false;

        function toggleTrash() {
            const trashSection = document.getElementById('trashSection');
            trashVisible = !trashVisible;
            
            if (trashVisible && projectTrash.length > 0) {
                trashSection.style.display = 'block';
                renderTrash();
            } else {
                trashSection.style.display = 'none';
            }
        }

        function renderTrash() {
            const trashList = document.getElementById('trashList');
            const trashSection = document.getElementById('trashSection');

            // Don't auto-show trash section, only render if already visible
            if (!trashVisible || projectTrash.length === 0) {
                trashSection.style.display = 'none';
                return;
            }

            trashSection.style.display = 'block';
            trashList.innerHTML = '';

            projectTrash.forEach((trashedProject, index) => {
                const trashItem = document.createElement('div');
                trashItem.className = 'trash-item';
                trashItem.setAttribute('data-trash-index', index);

                const daysAgo = Math.floor((Date.now() - trashedProject.trashedAt) / (1000 * 60 * 60 * 24));
                const timeText = daysAgo === 0 ? 'Today' : `${daysAgo} days ago`;

                trashItem.innerHTML = `
                    <div class="trash-item-name">${trashedProject.name}</div>
                    <div style="font-size: 10px; color: #9ca3af;">${timeText}</div>
                `;

                // Add right-click context menu for trash items
                trashItem.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    showTrashContextMenu(e, index);
                });

                trashList.appendChild(trashItem);
            });
        }

        function restoreProject(trashIndex) {
            const trashedProject = projectTrash[trashIndex];
            if (!trashedProject) return;

            // Generate new ID if original ID exists
            let newId = trashedProject.originalId;
            if (projects[newId]) {
                newId = 'project_' + Date.now();
            }

            // Restore project
            projects[newId] = {
                name: trashedProject.name,
                title: trashedProject.title,
                sortingMode: trashedProject.sortingMode || 'free',
                tasks: trashedProject.tasks,
                taskMetadata: trashedProject.taskMetadata || {}
            };

            // Remove from trash
            projectTrash.splice(trashIndex, 1);

            renderProjects();
            // Only render trash if currently visible
            if (trashVisible) renderTrash();
            saveData();

            showNotification(`Board "${trashedProject.name}" restored successfully!`, '#10b981');
        }

        function permanentDelete(trashIndex) {
            const trashedProject = projectTrash[trashIndex];
            if (!trashedProject) return;

            if (confirm(`Permanently delete "${trashedProject.name}" board? This cannot be undone.`)) {
                projectTrash.splice(trashIndex, 1);
                // Only render trash if currently visible
                if (trashVisible) renderTrash();
                saveData();
                showNotification(`Board "${trashedProject.name}" permanently deleted`, '#dc2626');
            }
        }

        function emptyTrash() {
            if (projectTrash.length === 0) return;

            if (confirm(`Permanently delete all ${projectTrash.length} boards in trash? This cannot be undone.`)) {
                projectTrash = [];
                // Only render trash if currently visible
                if (trashVisible) renderTrash();
                saveData();
                showNotification('Trash emptied successfully', '#dc2626');
            }
        }

        // Notification function
        function showNotification(message, color = '#10b981') {
            const notification = document.createElement('div');
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${color};
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                z-index: 1000;
                font-size: 14px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            `;
            document.body.appendChild(notification);

            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        function closeProjectModal() {
            document.getElementById('projectModal').style.display = 'none';
            document.getElementById('projectInput').value = '';
        }

        // Task management
        function showAddTaskModal(column) {
            currentColumn = column;
            document.getElementById('taskModal').style.display = 'flex';
            document.getElementById('taskInput').focus();
        }

        async function addTask() {
            const taskText = document.getElementById('taskInput').value.trim();
            if (taskText) {
                console.log(`ğŸ†• Adding task "${taskText}" to ${currentColumn} in ${currentProject}`);
                
                // 1. UPDATE: Modify the data array directly
                projects[currentProject].tasks[currentColumn].push(taskText);
                console.log(`ğŸ“Š Task array now has ${projects[currentProject].tasks[currentColumn].length} items in ${currentColumn}`);
                
                // 2. SAVE: Use the save function
                console.log('ğŸ’¾ Saving task to Firebase...');
                await saveData();
                console.log('âœ… Task saved to Firebase');
                
                // 3. RENDER: Update the UI
                renderTasks();
                renderProjects(); // Update task counts
                closeModal();
            }
        }

        async function deleteTask(column, index) {
            // Temporarily disable real-time sync during delete to prevent race conditions
            if (storage.realtimeUnsubscribe) {
                storage.stopRealtimeListener();
            }
            
            // 1. UPDATE: Modify the data array directly
            projects[currentProject].tasks[column].splice(index, 1);
            
            // 2. SAVE: Use the save function
            await saveData();
            
            // 3. RENDER: Update the UI
            renderTasks();
            renderProjects(); // Update task counts
            
            // Re-enable real-time sync after a short delay
            setTimeout(() => {
                if (storage.setupRealtimeListener) {
                    storage.setupRealtimeListener();
                }
            }, 1000);
        }

        function closeModal() {
            document.getElementById('taskModal').style.display = 'none';
            document.getElementById('taskInput').value = '';
        }

        // Image attachment functions
        function attachImageToTask(column, index) {
            console.log('ğŸ–¼ï¸ Attaching image to task:', column, index);
            
            // Validate inputs
            if (!currentProject || !projects[currentProject] || !projects[currentProject].tasks[column]) {
                console.error('âŒ Invalid project or column:', currentProject, column);
                return;
            }
            
            if (index >= projects[currentProject].tasks[column].length) {
                console.error('âŒ Invalid task index:', index);
                return;
            }
            
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.style.display = 'none'; // Hide the input
            document.body.appendChild(input); // Add to DOM temporarily
            
            input.onchange = (e) => {
                const file = e.target.files[0];
                console.log('ğŸ“ File selected:', file ? file.name : 'none');
                
                if (file) {
                    // Check file size (limit to 5MB)
                    if (file.size > 5 * 1024 * 1024) {
                        alert('Image is too large. Please choose an image smaller than 5MB.');
                        document.body.removeChild(input);
                        return;
                    }
                    
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const imageData = e.target.result;
                            console.log('ğŸ“¸ Image data loaded, size:', imageData.length);
                            
                            // Convert string task to object if needed
                            let task = projects[currentProject].tasks[column][index];
                            if (typeof task === 'string') {
                                task = { text: task };
                                projects[currentProject].tasks[column][index] = task;
                            }
                            
                            // 1. UPDATE: Modify the data array directly
                            task.image = imageData;
                            
                            console.log('âœ… Image attached to task successfully');
                            
                            // 2. SAVE: Use the save function
                            await saveData();
                            
                            // 3. RENDER: Update the UI
                            renderTasks();
                            
                            // Show success feedback
                            const notification = document.createElement('div');
                            notification.textContent = 'âœ… Image attached!';
                            notification.style.cssText = `
                                position: fixed;
                                top: 20px;
                                right: 20px;
                                background: #10b981;
                                color: white;
                                padding: 10px 15px;
                                border-radius: 6px;
                                z-index: 10000;
                                font-size: 14px;
                            `;
                            document.body.appendChild(notification);
                            setTimeout(() => notification.remove(), 2000);
                            
                        } catch (error) {
                            console.error('âŒ Error processing image:', error);
                            alert('Error processing image. Please try again.');
                        }
                        
                        // Clean up
                        document.body.removeChild(input);
                    };
                    
                    reader.onerror = () => {
                        console.error('âŒ Error reading file');
                        alert('Error reading file. Please try again.');
                        document.body.removeChild(input);
                    };
                    
                    reader.readAsDataURL(file);
                } else {
                    // User cancelled file selection
                    document.body.removeChild(input);
                }
            };
            
            // Trigger file selection
            console.log('ğŸ“‚ Opening file picker...');
            input.click();
        }

        function showTaskImageModal(imageData, taskText) {
            // Create modal to show image with download option
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            
            // Generate filename based on task text
            const fileName = (taskText ? taskText.substring(0, 30).replace(/[^a-z0-9]/gi, '_') : 'task_image') + '.png';
            
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 90vw; max-height: 90vh; padding: 20px;">
                    <h3 style="margin: 0 0 15px 0; text-align: center; color: #374151;">Task Image</h3>
                    <img src="${imageData}" style="max-width: 100%; max-height: 60vh; object-fit: contain; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button onclick="downloadTaskImage('${imageData}', '${fileName}')" style="background: #10b981; color: white; padding: 12px 16px; border: none; border-radius: 6px; cursor: pointer; flex: 1; font-weight: 500;">
                            ğŸ“¥ Download
                        </button>
                        <button onclick="copyImageDataToClipboard('${imageData}')" style="background: #3b82f6; color: white; padding: 12px 16px; border: none; border-radius: 6px; cursor: pointer; flex: 1; font-weight: 500;">
                            ğŸ“‹ Copy
                        </button>
                        <button onclick="this.closest('.modal').remove()" style="background: #6b7280; color: white; padding: 12px 16px; border: none; border-radius: 6px; cursor: pointer; flex: 1; font-weight: 500;">
                            âœ• Close
                        </button>
                    </div>
                </div>
            `;
            
            // Close on backdrop click
            modal.onclick = (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            };
            
            // Close on Escape key
            const handleKeyPress = (e) => {
                if (e.key === 'Escape') {
                    modal.remove();
                    document.removeEventListener('keydown', handleKeyPress);
                }
            };
            document.addEventListener('keydown', handleKeyPress);
            
            document.body.appendChild(modal);
        }

        function downloadTaskImage(imageData, fileName) {
            try {
                // Create a temporary link element
                const link = document.createElement('a');
                link.href = imageData;
                link.download = fileName;
                link.style.display = 'none';
                
                // Add to DOM, click, and remove
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('ğŸ“¥ Image downloaded:', fileName);
                
                // Show success notification
                const notification = document.createElement('div');
                notification.textContent = 'ğŸ“¥ Image downloaded!';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #10b981;
                    color: white;
                    padding: 10px 15px;
                    border-radius: 6px;
                    z-index: 10000;
                    font-size: 14px;
                `;
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 2000);
                
            } catch (error) {
                console.error('âŒ Error downloading image:', error);
                alert('Error downloading image. Please try right-clicking the image and selecting "Save image as..."');
            }
        }

        // Task context menu and image functions
        let currentTaskContext = null;

        function showTaskContextMenu(event, column, index) {
            const contextMenu = document.getElementById('taskContextMenu');
            const taskData = projects[currentProject].tasks[column][index];
            const hasImage = typeof taskData === 'object' && taskData.image;
            
            // Store current task context
            currentTaskContext = { column, index };
            
            // Show/hide menu items based on whether task has image
            document.getElementById('attachImageMenuItem').style.display = 'block';
            document.getElementById('viewImageMenuItem').style.display = hasImage ? 'block' : 'none';
            document.getElementById('downloadImageMenuItem').style.display = hasImage ? 'block' : 'none';
            document.getElementById('copyImageMenuItem').style.display = hasImage ? 'block' : 'none';
            document.getElementById('removeImageMenuItem').style.display = hasImage ? 'block' : 'none';
            
            // Position and show context menu
            contextMenu.style.left = event.pageX + 'px';
            contextMenu.style.top = event.pageY + 'px';
            contextMenu.style.display = 'block';
            
            // Hide menu when clicking elsewhere
            const hideMenu = (e) => {
                if (!contextMenu.contains(e.target)) {
                    contextMenu.style.display = 'none';
                    document.removeEventListener('click', hideMenu);
                }
            };
            setTimeout(() => document.addEventListener('click', hideMenu), 100);
        }

        function attachImageFromMenu() {
            if (currentTaskContext) {
                attachImageToTask(currentTaskContext.column, currentTaskContext.index);
                document.getElementById('taskContextMenu').style.display = 'none';
            }
        }

        function viewImageFromMenu() {
            if (currentTaskContext) {
                const taskData = projects[currentProject].tasks[currentTaskContext.column][currentTaskContext.index];
                if (taskData.image) {
                    showTaskImageModal(taskData.image, taskData.text || taskData);
                }
                document.getElementById('taskContextMenu').style.display = 'none';
            }
        }

        function downloadImageFromMenu() {
            if (currentTaskContext) {
                const taskData = projects[currentProject].tasks[currentTaskContext.column][currentTaskContext.index];
                if (taskData.image) {
                    const fileName = (taskData.text ? taskData.text.substring(0, 30).replace(/[^a-z0-9]/gi, '_') : 'task_image') + '.png';
                    downloadTaskImage(taskData.image, fileName);
                }
                document.getElementById('taskContextMenu').style.display = 'none';
            }
        }

        async function removeImageFromMenu() {
            if (currentTaskContext) {
                const taskData = projects[currentProject].tasks[currentTaskContext.column][currentTaskContext.index];
                if (typeof taskData === 'object' && taskData.image) {
                    // 1. UPDATE: Modify the data array directly
                    projects[currentProject].tasks[currentTaskContext.column][currentTaskContext.index] = taskData.text || '';
                    
                    console.log('ğŸ—‘ï¸ Image removed from task');
                    
                    // 2. SAVE: Use the save function
                    await saveData();
                    
                    // 3. RENDER: Update the UI
                    renderTasks();
                    renderProjects();
                }
                document.getElementById('taskContextMenu').style.display = 'none';
            }
        }

        function copyImageToClipboard() {
            if (currentTaskContext) {
                const taskData = projects[currentProject].tasks[currentTaskContext.column][currentTaskContext.index];
                if (taskData.image) {
                    copyImageDataToClipboard(taskData.image);
                }
                document.getElementById('taskContextMenu').style.display = 'none';
            }
        }

        async function copyImageDataToClipboard(imageData) {
            try {
                // Check if clipboard API is supported
                if (!navigator.clipboard) {
                    throw new Error('Clipboard API not supported');
                }

                // Convert base64 to blob
                const response = await fetch(imageData);
                const blob = await response.blob();
                
                // Copy to clipboard
                await navigator.clipboard.write([
                    new ClipboardItem({
                        [blob.type]: blob
                    })
                ]);
                
                console.log('ğŸ“‹ Image copied to clipboard');
                
                // Show success notification
                const notification = document.createElement('div');
                notification.textContent = 'ğŸ“‹ Image copied to clipboard!';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #10b981;
                    color: white;
                    padding: 10px 15px;
                    border-radius: 6px;
                    z-index: 10000;
                    font-size: 14px;
                `;
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 2000);
                
            } catch (error) {
                console.error('âŒ Error copying image to clipboard:', error);
                
                // Fallback: show instructions for manual copy
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.style.display = 'flex';
                modal.innerHTML = `
                    <div class="modal-content" style="max-width: 400px; text-align: center;">
                        <h3 style="margin: 0 0 15px 0; color: #374151;">Copy Image</h3>
                        <p style="margin: 10px 0; color: #6b7280; font-size: 14px;">
                            Right-click the image below and select "Copy image" to copy it to your clipboard.
                        </p>
                        <img src="${imageData}" style="max-width: 100%; max-height: 300px; object-fit: contain; border-radius: 8px; margin: 10px 0;">
                        <button onclick="this.closest('.modal').remove()" style="background: #6b7280; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; width: 100%; margin-top: 10px;">Close</button>
                    </div>
                `;
                
                // Close on backdrop click
                modal.onclick = (e) => {
                    if (e.target === modal) {
                        modal.remove();
                    }
                };
                
                document.body.appendChild(modal);
            }
        }

        // Tooltip functions
        let currentTooltip = null;

        function showRightClickTooltip(event, taskElement) {
            // Don't show tooltip if task is being edited
            if (taskElement.querySelector('[contenteditable="true"]')) {
                return;
            }
            
            const tooltip = document.createElement('div');
            tooltip.className = 'right-click-tooltip';
            tooltip.innerHTML = 'ğŸ’¡ Right-click for image options';
            tooltip.style.cssText = `
                position: fixed;
                background: #1f2937;
                color: white;
                padding: 8px 12px;
                border-radius: 6px;
                font-size: 12px;
                z-index: 10000;
                pointer-events: none;
                box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                white-space: nowrap;
            `;
            
            // Position tooltip above the task
            const rect = taskElement.getBoundingClientRect();
            tooltip.style.left = (rect.left + rect.width / 2 - 80) + 'px'; // Center horizontally
            tooltip.style.top = (rect.top - 35) + 'px'; // Above the task
            
            document.body.appendChild(tooltip);
            currentTooltip = tooltip;
            
            // Auto-hide after 3 seconds
            setTimeout(() => {
                if (currentTooltip === tooltip) {
                    hideRightClickTooltip();
                }
            }, 3000);
        }

        function hideRightClickTooltip() {
            if (currentTooltip) {
                currentTooltip.remove();
                currentTooltip = null;
            }
        }

        // Task editing functions
        function startEditingTask(element, column, index) {
            element.contentEditable = true;
            element.focus();

            // Select all text
            const range = document.createRange();
            range.selectNodeContents(element);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);

            element.setAttribute('data-original-value', element.textContent);
        }

        async function finishEditingTask(element, column, index) {
            const newText = element.textContent.trim();
            if (newText && newText !== '') {
                // 1. UPDATE: Modify the data array directly
                let currentTask = projects[currentProject].tasks[column][index];
                if (typeof currentTask === 'object' && currentTask.text !== undefined) {
                    // Update object task
                    currentTask.text = newText;
                } else {
                    // Update simple string task
                    projects[currentProject].tasks[column][index] = newText;
                }
                
                // 2. SAVE: Use the save function
                await saveData();
                
                // 3. RENDER: Update the UI
                element.innerHTML = makeURLsClickable(newText);
            } else {
                // Revert to original value if empty
                element.textContent = element.getAttribute('data-original-value');
            }
            element.contentEditable = false;
            element.removeAttribute('data-original-value');
        }

        function cancelEditingTask(element, column, index) {
            element.textContent = element.getAttribute('data-original-value');
            element.contentEditable = false;
            element.removeAttribute('data-original-value');
        }

        // Copy task text to clipboard
        async function copyTaskText(element) {
            const text = element.textContent.trim();

            try {
                await navigator.clipboard.writeText(text);
                showCopyFeedback(element, 'Copied!');
            } catch (error) {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showCopyFeedback(element, 'Copied!');
            }
        }

        // Show copy feedback
        function showCopyFeedback(element, message) {
            // Add visual feedback to the task
            element.classList.add('copied');
            setTimeout(() => {
                element.classList.remove('copied');
            }, 300);

            // Create and show feedback tooltip
            const feedback = document.createElement('div');
            feedback.className = 'copy-feedback';
            feedback.textContent = message;

            const rect = element.getBoundingClientRect();
            feedback.style.left = rect.left + rect.width / 2 - 25 + 'px';
            feedback.style.top = rect.top - 10 + 'px';

            document.body.appendChild(feedback);

            // Animate in
            setTimeout(() => feedback.classList.add('show'), 10);

            // Remove after animation
            setTimeout(() => {
                feedback.classList.remove('show');
                setTimeout(() => {
                    if (feedback.parentNode) {
                        document.body.removeChild(feedback);
                    }
                }, 300);
            }, 1500);
        }

        // Enhanced drag and drop functionality
        let draggedTaskData = null;
        let isReordering = false;

        function handleTaskDragStart(e) {
            draggedTask = e.target;
            const taskId = parseInt(e.target.getAttribute('data-task-id'));
            const column = e.target.getAttribute('data-column');

            draggedTaskData = {
                taskId: taskId,
                column: column,
                content: projects[currentProject].tasks[column][taskId]
            };

            e.target.classList.add('dragging');

            // Determine if this is reordering within the same column or moving between columns
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleTaskDragEnd(e) {
            e.target.classList.remove('dragging', 'reordering');

            // Clear all drop indicators
            document.querySelectorAll('.drop-indicator').forEach(indicator => {
                indicator.classList.remove('active');
            });

            document.querySelectorAll('.task-list').forEach(list => {
                list.classList.remove('drag-over-reorder');
            });

            draggedTask = null;
            draggedTaskData = null;
            isReordering = false;
        }

        function handleTaskDragOver(e) {
            e.preventDefault();

            if (!draggedTask || !draggedTaskData) return;

            const rect = e.target.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const isAbove = e.clientY < midpoint;

            // Find the closest drop indicator
            const taskElement = e.target.closest('.task-item');
            if (taskElement) {
                const taskList = taskElement.parentElement;
                const indicators = taskList.querySelectorAll('.drop-indicator');

                // Clear all indicators first
                indicators.forEach(indicator => indicator.classList.remove('active'));

                const taskId = parseInt(taskElement.getAttribute('data-task-id'));
                const column = taskElement.getAttribute('data-column');

                // Activate appropriate indicator
                if (isAbove) {
                    const indicator = taskList.querySelector(`[data-drop-index="${taskId}"]`);
                    if (indicator) indicator.classList.add('active');
                } else {
                    const indicator = taskList.querySelector(`[data-drop-index="${taskId + 1}"]`);
                    if (indicator) indicator.classList.add('active');
                }

                // Add visual feedback for reordering vs moving
                if (column === draggedTaskData.column) {
                    taskList.classList.add('drag-over-reorder');
                    draggedTask.classList.add('reordering');
                    isReordering = true;
                } else {
                    taskList.classList.remove('drag-over-reorder');
                    draggedTask.classList.remove('reordering');
                    isReordering = false;
                }
            }
        }

        function handleTaskDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            if (!draggedTask || !draggedTaskData) return;

            const targetElement = e.target.closest('.task-item');
            if (!targetElement) return;

            const targetTaskId = parseInt(targetElement.getAttribute('data-task-id'));
            const targetColumn = targetElement.getAttribute('data-column');

            const rect = targetElement.getBoundingClientRect();
            const midpoint = rect.top + rect.height / 2;
            const isAbove = e.clientY < midpoint;

            // Calculate drop position
            let dropIndex = isAbove ? targetTaskId : targetTaskId + 1;

            // Handle the drop
            const sourceColumn = draggedTaskData.column;
            const sourceIndex = draggedTaskData.taskId;

            if (sourceColumn === targetColumn) {
                // Reordering within the same column
                if (sourceIndex !== dropIndex && sourceIndex !== dropIndex - 1) {
                    // 1. UPDATE: Modify the data array directly
                    const task = projects[currentProject].tasks[sourceColumn].splice(sourceIndex, 1)[0];

                    // Adjust drop index if we removed an item before it
                    if (sourceIndex < dropIndex) {
                        dropIndex--;
                    }

                    projects[currentProject].tasks[targetColumn].splice(dropIndex, 0, task);
                    
                    // 2. SAVE: Use the save function
                    saveData();
                    
                    // 3. RENDER: Update the UI
                    renderTasks();
                    renderProjects();
                }
            } else {
                // Moving between columns
                // 1. UPDATE: Modify the data array directly
                const task = projects[currentProject].tasks[sourceColumn].splice(sourceIndex, 1)[0];
                projects[currentProject].tasks[targetColumn].splice(dropIndex, 0, task);
                
                // 2. SAVE: Use the save function
                saveData();
                
                // 3. RENDER: Update the UI
                renderTasks();
                renderProjects();
            }
        }

        // Legacy drag and drop for column-level drops (fallback)
        function handleDragStart(e) {
            if (!e.target.classList.contains('task-item')) return;
            handleTaskDragStart(e);
        }

        function handleDragEnd(e) {
            if (!e.target.classList.contains('task-item')) return;
            handleTaskDragEnd(e);
        }

        // Add drag and drop event listeners to columns
        document.querySelectorAll('.column').forEach(column => {
            column.addEventListener('dragover', handleDragOver);
            column.addEventListener('drop', handleDrop);
            column.addEventListener('dragenter', handleDragEnter);
            column.addEventListener('dragleave', handleDragLeave);
        });

        function handleDragOver(e) {
            e.preventDefault();
        }

        function handleDragEnter(e) {
            e.preventDefault();
            e.currentTarget.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
        }

        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');

            if (draggedTask) {
                const sourceColumn = draggedTask.getAttribute('data-column');
                const targetColumn = e.currentTarget.getAttribute('data-column');
                const taskIndex = parseInt(draggedTask.getAttribute('data-task-id'));

                if (sourceColumn !== targetColumn) {
                    // Move task between columns
                    const task = projects[currentProject].tasks[sourceColumn][taskIndex];
                    projects[currentProject].tasks[sourceColumn].splice(taskIndex, 1);
                    projects[currentProject].tasks[targetColumn].push(task);

                    renderTasks();
                    saveData();
                }
            }
        }

        // Board title editing
        document.getElementById('boardTitle').addEventListener('input', function() {
            projects[currentProject].title = this.value;
            saveData();
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Ctrl+N to create new task in TODO column
            if (e.ctrlKey && e.key === 'n') {
                e.preventDefault();
                showAddTaskModal('todo');
                return;
            }

            if (e.key === 'Escape') {
                closeModal();
                closeProjectModal();
            } else if (e.key === 'Enter' && document.getElementById('taskModal').style.display === 'flex') {
                addTask();
            } else if (e.key === 'Enter' && document.getElementById('projectModal').style.display === 'flex') {
                addProject();
            }
        });

        // Project name editing functions
        function startEditingProjectName(input, projectId) {
            input.readOnly = false;
            input.focus();
            input.select();
            input.setAttribute('data-original-value', input.value);
        }

        function finishEditingProjectName(input, projectId) {
            const newName = input.value.trim().toUpperCase();
            if (newName && newName !== '') {
                projects[projectId].name = newName;
                document.getElementById('currentProject').textContent = projects[currentProject].name;
                saveData();
            } else {
                // Revert to original value if empty
                input.value = input.getAttribute('data-original-value');
            }
            input.readOnly = true;
            input.removeAttribute('data-original-value');
        }

        function cancelEditingProjectName(input, projectId) {
            input.value = input.getAttribute('data-original-value');
            input.readOnly = true;
            input.removeAttribute('data-original-value');
        }

        // Auto-refresh functionality
        function refreshData() {
            loadData().then(() => {
                console.log('Data refreshed automatically');
            }).catch(error => {
                console.error('Auto-refresh failed:', error);
            });
        }

        // Refresh data when page becomes visible (tab switching)
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                refreshData();
            }
        });

        // Refresh data when window gains focus
        window.addEventListener('focus', function() {
            refreshData();
        });

        // Function to make URLs clickable
        function makeURLsClickable(text) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            return text.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
        }

        // Periodic refresh every 2 minutes (in case of multi-device usage)
        setInterval(refreshData, 2 * 60 * 1000);

        // Force refresh on page load to ensure latest data
        window.addEventListener('load', function() {
            setTimeout(refreshData, 500); // Small delay to ensure everything is loaded
        });

        // Workspace Management System
        let currentWorkspace = 'personal';
        let userWorkspaces = {};

        // Initialize workspace system
        // Get consistent userId for workspace sync
        function getWorkspaceUserId() {
            const currentUser = userAuth.getCurrentUser();
            if (currentUser.isLoggedIn) {
                return currentUser.userHash;
            }
            
            // Check URL for shared user ID first (for cross-browser sync)
            const urlParams = new URLSearchParams(window.location.search);
            const sharedUserId = urlParams.get('user');
            
            if (sharedUserId) {
                // Clean the user ID - remove extra "user_" prefix if present
                const cleanUserId = sharedUserId.startsWith('user_user_') ? 
                    sharedUserId.substring(5) : sharedUserId;
                
                // Save the shared user ID to localStorage for future use
                localStorage.setItem('kanbanLegacyUserId', cleanUserId);
                console.log('ğŸ”— Using shared userId from URL for workspace sync:', cleanUserId);
                return cleanUserId;
            }
            
            // For legacy users, create or get a consistent user ID
            let legacyUserId = localStorage.getItem('kanbanLegacyUserId');
            if (!legacyUserId) {
                // Generate a consistent ID based on localStorage data or create new
                legacyUserId = `legacy_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                localStorage.setItem('kanbanLegacyUserId', legacyUserId);
                console.log('ğŸ†” Generated legacy userId for workspace sync:', legacyUserId);
            }
            
            // Set storage.userId if not already set
            if (!storage.userId) {
                storage.userId = legacyUserId;
            }
            
            return legacyUserId;
        }

        // Show workspace sharing URL
        function showWorkspaceShareUrl() {
            const userId = getWorkspaceUserId();
            const shareUrl = window.location.origin + window.location.pathname + '?user=' + encodeURIComponent(userId);
            
            const notification = document.createElement('div');
            notification.innerHTML = `
                ğŸ”— <strong>Share Workspaces URL:</strong><br>
                <input type="text" value="${shareUrl}" readonly style="width: 100%; margin-top: 5px; padding: 5px; font-size: 11px; border: 1px solid #ccc; border-radius: 4px;" onclick="this.select()">
                <br><small>Use this URL to sync workspaces across devices/browsers</small>
            `;
            notification.style.cssText = `
                position: fixed;
                top: 70px;
                right: 20px;
                background: #1f2937;
                color: white;
                padding: 15px;
                border-radius: 8px;
                z-index: 1000;
                max-width: 400px;
                font-size: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                border: 1px solid #374151;
            `;
            
            document.body.appendChild(notification);
            
            // Remove after 10 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 10000);
            
            console.log('ğŸ”— Share this URL to sync workspaces across devices:', shareUrl);
        }
        
        // Debug function to show workspace data structure
        function debugWorkspaceData() {
            console.log('ğŸ” DEBUG: Current userWorkspaces:', userWorkspaces);
            console.log('ğŸ” DEBUG: localStorage userWorkspaces:', localStorage.getItem('userWorkspaces'));
            
            const notification = document.createElement('div');
            notification.innerHTML = `
                <strong>Debug Workspace Data:</strong><br>
                <pre style="font-size: 10px; overflow-x: auto; max-width: 350px;">${JSON.stringify(userWorkspaces, null, 2)}</pre>
            `;
            notification.style.cssText = `
                position: fixed;
                top: 10px;
                left: 10px;
                background: #1f2937;
                color: white;
                padding: 15px;
                border-radius: 8px;
                z-index: 1000;
                max-width: 400px;
                font-size: 12px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                border: 1px solid #374151;
                max-height: 400px;
                overflow-y: auto;
            `;
            
            document.body.appendChild(notification);
            
            // Remove after 15 seconds or on click
            const removeNotification = () => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            };
            setTimeout(removeNotification, 15000);
            notification.addEventListener('click', removeNotification);
        }

        // Save workspaces with Firebase sync (similar to task data)
        async function saveWorkspaces() {
            try {
                console.log('ğŸ’¾ saveWorkspaces called with data:', userWorkspaces);
                
                // Save to localStorage
                localStorage.setItem('userWorkspaces', JSON.stringify(userWorkspaces));
                
                // Save to Firebase if we have database connection
                const userId = getWorkspaceUserId();
                
                if (userId && window.database) {
                    const dataToSave = {
                        workspaces: userWorkspaces,
                        lastUpdate: new Date().toISOString()
                    };
                    console.log('ğŸ’¾ Saving to Firebase path userWorkspaces/' + userId + ':', dataToSave);
                    
                    const userWorkspacesRef = window.firebaseRef(window.database, `userWorkspaces/${userId}`);
                    await window.firebaseSet(userWorkspacesRef, dataToSave);
                    storage.lastWorkspacesSaveTime = Date.now(); // Track save time to prevent merge race conditions
                    console.log('âœ… Workspaces saved to Firebase for userId:', userId);
                } else {
                    console.warn('âš ï¸ Cannot save to Firebase - missing userId or database:', { userId, database: !!window.database });
                }
            } catch (error) {
                console.error('âŒ Failed to save workspaces:', error);
            }
        }

        async function loadWorkspacesFromFirebase() {
            try {
                const userId = getWorkspaceUserId();
                
                if (!userId || !window.database) {
                    console.log('ğŸ“± Loading workspaces from localStorage only');
                    return;
                }

                console.log('ğŸ“¡ Loading workspaces from Firebase for userId:', userId);
                const userWorkspacesRef = window.firebaseRef(window.database, `userWorkspaces/${userId}`);
                const snapshot = await window.firebaseGet(userWorkspacesRef);
                
                if (snapshot.exists()) {
                    const firebaseData = snapshot.val();
                    console.log('ğŸ“¡ Raw Firebase data received:', firebaseData);
                    
                    const remoteWorkspaces = firebaseData.workspaces || {};
                    console.log('ğŸ“¡ Extracted remote workspaces:', remoteWorkspaces);
                    console.log('ğŸ“¡ Remote workspace keys:', Object.keys(remoteWorkspaces));
                    
                    // Debug each workspace
                    Object.keys(remoteWorkspaces).forEach(key => {
                        console.log(`ğŸ“¡ Remote workspace ${key}:`, remoteWorkspaces[key]);
                    });
                    
                    // Skip merge if we just saved to prevent race conditions
                    const now = Date.now();
                    if (storage.lastWorkspacesSaveTime && (now - storage.lastWorkspacesSaveTime) < 2000) {
                        console.log('â¸ï¸ Skipping workspace merge - just saved data, preventing race condition');
                        return;
                    }
                    
                    // Merge remote workspaces with local ones
                    Object.keys(remoteWorkspaces).forEach(workspaceId => {
                        if (!userWorkspaces[workspaceId]) {
                            console.log(`â• Adding remote workspace: ${workspaceId}`);
                            userWorkspaces[workspaceId] = remoteWorkspaces[workspaceId];
                        } else {
                            // Update existing workspace with any newer data
                            userWorkspaces[workspaceId] = {
                                ...userWorkspaces[workspaceId],
                                ...remoteWorkspaces[workspaceId]
                            };
                        }
                    });
                    
                    // Save merged workspaces to localStorage
                    localStorage.setItem('userWorkspaces', JSON.stringify(userWorkspaces));
                    renderWorkspaceDropdown();
                    
                    console.log('âœ… Workspaces merged from Firebase');
                }
            } catch (error) {
                console.error('Failed to load workspaces from Firebase:', error);
            }
        }

        function setupWorkspacesRealtimeListener() {
            const userId = getWorkspaceUserId();
            
            if (!userId || !window.database) {
                console.log('âš ï¸ Cannot setup workspace listener - no userId or database');
                return;
            }

            // Clean up existing listener first
            if (window.workspaceRealtimeUnsubscribe) {
                console.log('ğŸ”‡ Stopping existing workspace real-time listener');
                window.workspaceRealtimeUnsubscribe();
                window.workspaceRealtimeUnsubscribe = null;
            }

            console.log('ğŸ§ Setting up real-time listener for user workspaces, userId:', userId);
            const userWorkspacesRef = window.firebaseRef(window.database, `userWorkspaces/${userId}`);
            
            window.workspaceRealtimeUnsubscribe = window.firebaseOnValue(userWorkspacesRef, (snapshot) => {
                if (snapshot.exists()) {
                    const firebaseData = snapshot.val();
                    const remoteWorkspaces = firebaseData.workspaces || {};
                    
                    console.log('ğŸ“¡ Received real-time workspaces update from Firebase');
                    console.log('ğŸ“¡ Raw real-time Firebase data:', firebaseData);
                    console.log('ğŸ” Extracted real-time remote workspaces:', remoteWorkspaces);
                    console.log('ğŸ” Remote workspace keys:', Object.keys(remoteWorkspaces));
                    
                    // Debug each workspace in real-time update
                    Object.keys(remoteWorkspaces).forEach(key => {
                        console.log(`ğŸ” Real-time workspace ${key}:`, remoteWorkspaces[key]);
                    });
                    
                    // Skip merge if we just saved to prevent race conditions (only for very recent saves)
                    const now = Date.now();
                    if (storage.lastWorkspacesSaveTime && (now - storage.lastWorkspacesSaveTime) < 500) {
                        console.log('â¸ï¸ Skipping workspaces merge - just saved data, preventing race condition');
                        return;
                    }
                    
                    // Merge remote workspaces
                    let hasChanges = false;
                    Object.keys(remoteWorkspaces).forEach(workspaceId => {
                        const remoteWorkspace = remoteWorkspaces[workspaceId];
                        const localWorkspace = userWorkspaces[workspaceId];
                        
                        if (!localWorkspace) {
                            console.log(`â• Adding new remote workspace: ${workspaceId}`, remoteWorkspace);
                            userWorkspaces[workspaceId] = remoteWorkspace;
                            hasChanges = true;
                        } else {
                            // Update existing workspace with remote data if it's newer or has missing properties
                            let needsUpdate = false;
                            
                            // Check if remote has properties that local is missing
                            if (!localWorkspace.name && remoteWorkspace.name) {
                                localWorkspace.name = remoteWorkspace.name;
                                needsUpdate = true;
                                console.log(`ğŸ”„ Updated workspace name: ${workspaceId} -> ${remoteWorkspace.name}`);
                            }
                            
                            if (!localWorkspace.id && remoteWorkspace.id) {
                                localWorkspace.id = remoteWorkspace.id;
                                needsUpdate = true;
                            }
                            
                            if (needsUpdate) {
                                hasChanges = true;
                            }
                        }
                    });
                    
                    if (hasChanges) {
                        // Save merged workspaces to localStorage only (don't save to Firebase to avoid loop)
                        localStorage.setItem('userWorkspaces', JSON.stringify(userWorkspaces));
                        console.log('ğŸ” Updated userWorkspaces after sync:', userWorkspaces);
                        renderWorkspaceDropdown();
                        console.log('âœ… Workspaces updated from real-time sync');
                    }
                }
            });
        }

        function stopWorkspaceRealtimeListener() {
            if (window.workspaceRealtimeUnsubscribe) {
                console.log('ğŸ”‡ Stopping workspace real-time listener');
                window.workspaceRealtimeUnsubscribe();
                window.workspaceRealtimeUnsubscribe = null;
            }
        }

        function initializeWorkspaces() {
            // Load user's workspaces from localStorage
            const savedWorkspaces = localStorage.getItem('userWorkspaces');
            console.log('ğŸ”§ initializeWorkspaces - raw localStorage data:', savedWorkspaces);
            
            if (savedWorkspaces) {
                try {
                    userWorkspaces = JSON.parse(savedWorkspaces);
                    console.log('ğŸ”§ initializeWorkspaces - parsed userWorkspaces:', userWorkspaces);
                    console.log('ğŸ”§ initializeWorkspaces - workspace keys:', Object.keys(userWorkspaces));
                } catch (error) {
                    console.error('ğŸ”§ Failed to parse saved workspaces:', error);
                    userWorkspaces = {};
                }
            } else {
                // Create default personal workspace
                userWorkspaces = {
                    'personal': {
                        id: 'personal',
                        name: 'ğŸ“ Main Workspace',
                        type: 'main',
                        owner: storage.userId,
                        created: new Date().toISOString()
                    }
                };
                saveWorkspaces(); // Use new save function
            }
            
            // Migration: Update existing personal workspace name if it's still the old name
            if (userWorkspaces['personal'] && 
                (userWorkspaces['personal'].name === 'ğŸ“ Personal Workspace' || 
                 userWorkspaces['personal'].name.includes('Personal Workspace'))) {
                console.log('ğŸ”„ Migrating personal workspace name to Main Workspace');
                userWorkspaces['personal'].name = 'ğŸ“ Main Workspace';
                userWorkspaces['personal'].type = 'main';
                saveWorkspaces(); // Use new save function
            }
            
            renderWorkspaceDropdown();
        }

        function renderWorkspaceDropdown() {
            const dropdown = document.getElementById('workspaceSelect');
            dropdown.innerHTML = '';
            
            Object.values(userWorkspaces).forEach(workspace => {
                // Skip invalid workspaces
                if (!workspace || typeof workspace !== 'object' || !workspace.id) {
                    console.warn('âš ï¸ Skipping invalid workspace in dropdown:', workspace);
                    return;
                }
                
                const option = document.createElement('option');
                option.value = workspace.id;
                option.textContent = workspace.name || workspace.id || 'Unnamed Workspace';
                dropdown.appendChild(option);
            });
            
            dropdown.value = currentWorkspace;
            dropdown.addEventListener('change', switchWorkspace);
        }

        function showWorkspaceModal() {
            document.getElementById('workspaceModal').style.display = 'flex';
            refreshWorkspaceList();
        }
        
        function refreshWorkspaceList() {
            const container = document.getElementById('workspaceListContainer');
            if (!container) return;
            
            container.innerHTML = '';
            
            Object.keys(userWorkspaces).forEach(workspaceId => {
                const workspace = userWorkspaces[workspaceId];
                
                // Debug logging
                console.log('ğŸ” Rendering workspace:', workspaceId, workspace);
                
                // Skip if workspace is invalid or missing required properties
                if (!workspace || typeof workspace !== 'object') {
                    console.warn('âš ï¸ Skipping invalid workspace:', workspaceId, workspace);
                    return;
                }
                
                // Skip if workspace has no name or id (corrupted data)
                if (!workspace.name && !workspace.id) {
                    console.warn('âš ï¸ Skipping workspace with no name or id:', workspaceId, workspace);
                    return;
                }
                
                const isCurrentWorkspace = workspaceId === currentWorkspace;
                // Allow deletion of non-personal workspaces (more permissive)
                const canDelete = workspaceId !== 'personal' && (
                    !workspace.owner || // No owner set (legacy workspaces)
                    workspace.owner === storage.userId // User is owner
                );
                console.log('ğŸ” Workspace delete check:', workspaceId, 'canDelete:', canDelete, 'owner:', workspace.owner, 'userId:', storage.userId);
                
                const workspaceDiv = document.createElement('div');
                workspaceDiv.style.cssText = `
                    display: flex; 
                    justify-content: space-between; 
                    align-items: center; 
                    padding: 8px 12px; 
                    margin: 5px 0; 
                    background: ${isCurrentWorkspace ? '#e0f2fe' : '#f9fafb'}; 
                    border: 1px solid ${isCurrentWorkspace ? '#0891b2' : '#e5e7eb'}; 
                    border-radius: 6px;
                `;
                
                const nameSpan = document.createElement('span');
                const workspaceName = workspace.name || workspace.id || 'Unnamed Workspace';
                nameSpan.textContent = `${workspaceName}${isCurrentWorkspace ? ' (Actual)' : ''}`;
                nameSpan.style.cssText = `font-weight: ${isCurrentWorkspace ? 'bold' : 'normal'}; color: ${isCurrentWorkspace ? '#0891b2' : '#374151'};`;
                
                const actionsDiv = document.createElement('div');
                actionsDiv.style.display = 'flex';
                actionsDiv.style.gap = '8px';
                
                if (!isCurrentWorkspace) {
                    const switchBtn = document.createElement('button');
                    switchBtn.textContent = 'ğŸ“‚ Abrir';
                    switchBtn.style.cssText = 'background: #3b82f6; color: white; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;';
                    switchBtn.onclick = () => {
                        switchWorkspace({ target: { value: workspaceId } });
                        closeWorkspaceModal();
                    };
                    actionsDiv.appendChild(switchBtn);
                }
                
                if (canDelete) {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = 'ğŸ—‘ï¸ Eliminar';
                    deleteBtn.style.cssText = 'background: #ef4444; color: white; padding: 4px 8px; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;';
                    deleteBtn.onclick = () => deleteWorkspace(workspaceId);
                    actionsDiv.appendChild(deleteBtn);
                }
                
                // Remove type indicator since we no longer distinguish workspace types
                
                workspaceDiv.appendChild(nameSpan);
                workspaceDiv.appendChild(actionsDiv);
                container.appendChild(workspaceDiv);
            });
            
            if (Object.keys(userWorkspaces).length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #6b7280; padding: 20px;">No hay workspaces disponibles</div>';
            }
        }

        function closeWorkspaceModal() {
            document.getElementById('workspaceModal').style.display = 'none';
            document.getElementById('newWorkspaceName').value = '';
        }

        function showInfoModal() {
            document.getElementById('infoModal').style.display = 'flex';
        }
        
        function closeInfoModal() {
            document.getElementById('infoModal').style.display = 'none';
        }

        // Function to dynamically assign emoji based on workspace name
        function getWorkspaceEmoji(name) {
            const lowerName = name.toLowerCase();
            
            // Work/Business related
            if (lowerName.includes('work') || lowerName.includes('office') || lowerName.includes('business') || lowerName.includes('company')) return 'ğŸ’¼';
            if (lowerName.includes('team') || lowerName.includes('group') || lowerName.includes('squad')) return 'ğŸ‘¥';
            if (lowerName.includes('project') || lowerName.includes('task') || lowerName.includes('plan')) return 'ğŸ“‹';
            if (lowerName.includes('meeting') || lowerName.includes('agenda')) return 'ğŸ—“ï¸';
            
            // Personal/Family
            if (lowerName.includes('personal') || lowerName.includes('private') || lowerName.includes('my')) return 'ğŸ‘¤';
            if (lowerName.includes('family') || lowerName.includes('home') || lowerName.includes('house')) return 'ğŸ ';
            if (lowerName.includes('kids') || lowerName.includes('children') || lowerName.includes('baby')) return 'ğŸ‘¶';
            
            // Creative/Hobbies
            if (lowerName.includes('art') || lowerName.includes('design') || lowerName.includes('creative')) return 'ğŸ¨';
            if (lowerName.includes('music') || lowerName.includes('song') || lowerName.includes('band')) return 'ğŸµ';
            if (lowerName.includes('photo') || lowerName.includes('picture') || lowerName.includes('camera')) return 'ğŸ“¸';
            if (lowerName.includes('book') || lowerName.includes('read') || lowerName.includes('library')) return 'ğŸ“š';
            if (lowerName.includes('game') || lowerName.includes('gaming') || lowerName.includes('play')) return 'ğŸ®';
            
            // Health/Fitness
            if (lowerName.includes('health') || lowerName.includes('fitness') || lowerName.includes('gym') || lowerName.includes('workout')) return 'ğŸ’ª';
            if (lowerName.includes('diet') || lowerName.includes('food') || lowerName.includes('recipe') || lowerName.includes('cooking')) return 'ğŸ³';
            if (lowerName.includes('doctor') || lowerName.includes('medical') || lowerName.includes('hospital')) return 'ğŸ¥';
            
            // Education/Learning
            if (lowerName.includes('school') || lowerName.includes('university') || lowerName.includes('college') || lowerName.includes('study')) return 'ğŸ“';
            if (lowerName.includes('learn') || lowerName.includes('course') || lowerName.includes('lesson') || lowerName.includes('tutorial')) return 'ğŸ“–';
            
            // Travel/Adventure
            if (lowerName.includes('travel') || lowerName.includes('trip') || lowerName.includes('vacation') || lowerName.includes('holiday')) return 'âœˆï¸';
            if (lowerName.includes('adventure') || lowerName.includes('explore') || lowerName.includes('journey')) return 'ğŸ—ºï¸';
            if (lowerName.includes('car') || lowerName.includes('drive') || lowerName.includes('road')) return 'ğŸš—';
            
            // Technology
            if (lowerName.includes('tech') || lowerName.includes('code') || lowerName.includes('dev') || lowerName.includes('software')) return 'ğŸ’»';
            if (lowerName.includes('app') || lowerName.includes('mobile') || lowerName.includes('website')) return 'ğŸ“±';
            if (lowerName.includes('data') || lowerName.includes('database') || lowerName.includes('server')) return 'ğŸ”§';
            
            // Finance/Money
            if (lowerName.includes('money') || lowerName.includes('budget') || lowerName.includes('finance') || lowerName.includes('bank')) return 'ğŸ’°';
            if (lowerName.includes('investment') || lowerName.includes('stock') || lowerName.includes('trading')) return 'ğŸ“ˆ';
            if (lowerName.includes('shopping') || lowerName.includes('buy') || lowerName.includes('purchase')) return 'ğŸ›’';
            
            // Nature/Garden
            if (lowerName.includes('garden') || lowerName.includes('plant') || lowerName.includes('flower') || lowerName.includes('green')) return 'ğŸŒ±';
            if (lowerName.includes('nature') || lowerName.includes('forest') || lowerName.includes('tree')) return 'ğŸŒ³';
            if (lowerName.includes('beach') || lowerName.includes('ocean') || lowerName.includes('sea')) return 'ğŸ–ï¸';
            
            // Special occasions
            if (lowerName.includes('birthday') || lowerName.includes('party') || lowerName.includes('celebration')) return 'ğŸ‰';
            if (lowerName.includes('wedding') || lowerName.includes('marriage')) return 'ğŸ’';
            if (lowerName.includes('christmas') || lowerName.includes('holiday')) return 'ğŸ„';
            
            // Default emojis by first letter
            const firstLetter = name.charAt(0).toLowerCase();
            const letterEmojis = {
                'a': 'ğŸ…°ï¸', 'b': 'ğŸ…±ï¸', 'c': 'ğŸŒ™', 'd': 'ğŸ’', 'e': 'âš¡', 'f': 'ğŸ”¥', 'g': 'ğŸ¯', 'h': 'â¤ï¸', 'i': 'ğŸ’¡',
                'j': 'ğŸª', 'k': 'ğŸ”‘', 'l': 'ğŸ’', 'm': 'â­', 'n': 'ğŸµ', 'o': 'ğŸŒŸ', 'p': 'ğŸ¯', 'q': 'ğŸ‘‘', 'r': 'ğŸŒˆ',
                's': 'âœ¨', 't': 'ğŸŒ', 'u': 'ğŸ¦„', 'v': 'âœ…', 'w': 'ğŸŒŠ', 'x': 'âŒ', 'y': 'ğŸ’›', 'z': 'âš¡'
            };
            
            return letterEmojis[firstLetter] || 'ğŸ“';
        }

        async function createWorkspace() {
            const name = document.getElementById('newWorkspaceName').value.trim();
            
            if (!name) {
                alert('Por favor ingresa un nombre para el workspace');
                return;
            }
            
            console.log('ğŸ—ï¸ Creating new workspace:', name);
            
            try {
                const workspaceId = `workspace_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const emoji = getWorkspaceEmoji(name);
                
                const workspace = {
                    id: workspaceId,
                    name: `${emoji} ${name}`,
                    type: 'workspace',
                    owner: storage.userId,
                    created: new Date().toISOString()
                };
                
                // Add to local workspaces
                userWorkspaces[workspaceId] = workspace;
                
                // Save workspaces with Firebase sync
                await saveWorkspaces();
                
                // Refresh dropdown and switch to new workspace
                renderWorkspaceDropdown();
                switchWorkspace({ target: { value: workspaceId } });
                closeWorkspaceModal();
                
                console.log('âœ… Workspace created successfully:', workspaceId);
                
            } catch (error) {
                console.error('âŒ Error creating workspace:', error);
                alert('Error creando workspace. Intenta nuevamente.');
            }
        }
        
        async function deleteWorkspace(workspaceId) {
            console.log('ğŸ—‘ï¸ Delete workspace requested:', workspaceId);
            
            if (!workspaceId || workspaceId === 'personal') {
                alert('No puedes eliminar el workspace principal');
                return;
            }
            
            const workspace = userWorkspaces[workspaceId];
            if (!workspace) {
                alert('Workspace no encontrado');
                return;
            }
            
            const confirmDelete = confirm(`Â¿EstÃ¡s seguro de eliminar "${workspace.name}"?\n\nEsta acciÃ³n no se puede deshacer y eliminarÃ¡ todos los proyectos del workspace.`);
            if (!confirmDelete) return;
            
            try {
                console.log('ğŸ—‘ï¸ Proceeding with workspace deletion:', workspaceId);
                
                // Temporarily disable real-time sync during deletion to prevent race conditions
                stopWorkspaceRealtimeListener();
                
                // Remove from local storage
                delete userWorkspaces[workspaceId];
                await saveWorkspaces();
                
                // Remove workspace data from Firebase
                if (userAuth.getCurrentUser().isLoggedIn) {
                    const workspaceDataRef = window.firebaseRef(window.database, `workspaces/${workspaceId}`);
                    await window.firebaseRemove(workspaceDataRef);
                    console.log('ğŸ—‘ï¸ Workspace data removed from Firebase');
                }
                
                // If currently in deleted workspace, switch to personal
                if (currentWorkspace === workspaceId) {
                    currentWorkspace = 'personal';
                    switchWorkspace({ target: { value: 'personal' } });
                }
                
                renderWorkspaceDropdown();
                console.log('âœ… Workspace deleted successfully');
                
                // Re-enable real-time sync after a short delay
                setTimeout(() => {
                    setupWorkspacesRealtimeListener();
                }, 1500);
                
            } catch (error) {
                console.error('âŒ Error deleting workspace:', error);
                alert('Error eliminando workspace. Intenta nuevamente.');
            }
        }

        function clearAllTasks() {
            // Debug: Check current board title before clearing
            const boardTitle = document.getElementById('boardTitle');
            if (boardTitle) {
                console.log('ğŸ” Current board title before clearing:', boardTitle.value);
            }
            
            // Clear all task lists immediately and thoroughly
            const columns = ['todo', 'doing', 'done'];
            
            columns.forEach(column => {
                const taskList = document.getElementById(column + 'List');
                if (taskList) {
                    // Clear all children including tasks and drop indicators
                    while (taskList.firstChild) {
                        taskList.removeChild(taskList.firstChild);
                    }
                    // Double-check with innerHTML clear
                    taskList.innerHTML = '';
                }
            });
            
            // Clear project info
            const currentProjectSpan = document.getElementById('currentProject');
            if (currentProjectSpan) currentProjectSpan.textContent = 'No board';
            
            // Clear board title (text will be set appropriately after loading)
            const boardTitleEl = document.getElementById('boardTitle');
            if (boardTitleEl) {
                console.log('ğŸ§¹ Clearing board title, was:', boardTitleEl.value);
                boardTitleEl.value = '';
                boardTitleEl.disabled = false; // Reset disabled state
                boardTitleEl.style.color = '#1f2937'; // Reset color
                boardTitleEl.style.fontStyle = 'normal'; // Reset italic
                console.log('ğŸ§¹ Board title cleared and reset');
            }
            
            console.log('ğŸ§¹ All tasks and UI elements cleared thoroughly');
        }

        async function switchWorkspace(event) {
            const newWorkspaceId = event.target.value;
            console.log('ğŸ¢ Switching workspace from', currentWorkspace, 'to', newWorkspaceId);
            
            if (newWorkspaceId === currentWorkspace) {
                console.log('ğŸ¢ Same workspace selected, no change needed');
                return;
            }
            
            try {
                // Save current workspace data
                console.log('ğŸ’¾ Saving current workspace data...');
                await saveData();
                
                // Switch to new workspace
                currentWorkspace = newWorkspaceId;
                
                // Update storage to use workspace-specific data
                console.log(`ğŸ”„ Updating storage to workspace: ${currentWorkspace}`);
                storage.workspaceId = currentWorkspace;
                
                // Stop existing real-time listener and setup new one for new workspace
                storage.stopRealtimeListener();
                
                // Create new storage manager for new workspace (if using legacy system)
                if (storage instanceof StorageManager) {
                    storage = new StorageManager(currentWorkspace);
                }
                
                // Clear current data and UI immediately
                console.log('ğŸ—‘ï¸ Clearing current data and UI...');
                projects = {};
                currentProject = null;
                projectTrash = [];
                
                // Clear all tasks from UI immediately
                clearAllTasks();
                
                // Load new workspace data
                console.log('ğŸ“¥ Loading new workspace data...');
                await loadData();
                
                // Setup real-time listener for new workspace
                console.log('ğŸ§ Setting up real-time listener for new workspace...');
                storage.setupRealtimeListener();
                
                // Force UI refresh
                console.log('ğŸ”„ Refreshing UI...');
                renderProjects();
                
                // Switch to first available project or handle empty workspace
                if (Object.keys(projects).length > 0) {
                    const firstProject = Object.keys(projects)[0];
                    console.log('ğŸ¯ Switching to board:', firstProject);
                    switchProject(firstProject);
                } else {
                    console.log('ğŸ“ Empty workspace - showing create board message');
                    // Set appropriate message for empty workspace
                    const boardTitleEl2 = document.getElementById('boardTitle');
                    if (boardTitleEl2) {
                        boardTitleEl2.value = 'Please, create a Board';
                        boardTitleEl2.disabled = true;
                        boardTitleEl2.style.color = '#6b7280';
                        boardTitleEl2.style.fontStyle = 'italic';
                        console.log('âœ… Empty workspace - Board title set to:', boardTitleEl2.value);
                    }
                }
                
                console.log('âœ… Workspace switch completed');
                
                console.log(`âœ… Switched to workspace: ${userWorkspaces[currentWorkspace]?.name}`);
                
            } catch (error) {
                console.error('âŒ Error switching workspace:', error);
                // Revert dropdown selection
                document.getElementById('workspaceSelect').value = currentWorkspace;
            }
        }

        // Add event listener for workspace dropdown
        document.getElementById('workspaceSelect').addEventListener('change', switchWorkspace);
        console.log('ğŸ¯ Workspace dropdown event listener added');

        // Initialize the application with password protection
        console.log('ğŸš€ Starting app initialization...');
        
        // Check authentication state
        console.log('ğŸ” Checking authentication state...');
        const userAuthState = userAuth.isValidSession();
        console.log('ğŸ“Š User auth state:', userAuthState);
        
        // Check if password manager has a session (simple check)
        const legacySessionExists = localStorage.getItem('kanbanSession');
        console.log('ğŸ“Š Legacy session exists:', legacySessionExists ? 'yes' : 'no');
        
        if (userAuthState) {
            console.log('âœ… Valid user session found, unlocking app');
            document.getElementById('passwordOverlay').style.display = 'none';
            document.getElementById('appContent').style.display = 'flex';
        } else if (legacySessionExists) {
            console.log('âœ… Valid legacy session found, unlocking app');
            document.getElementById('passwordOverlay').style.display = 'none';
            document.getElementById('appContent').style.display = 'flex';
        } else {
            console.log('âŒ No valid session, showing login form');
            document.getElementById('passwordOverlay').style.display = 'flex';
            document.getElementById('appContent').style.display = 'none';
        }
        
        // Check for workspace in URL
        const urlParams = new URLSearchParams(window.location.search);
        const workspaceFromUrl = urlParams.get('workspace');
        if (workspaceFromUrl) {
            currentWorkspace = workspaceFromUrl;
            storage.workspaceId = currentWorkspace;
            
            // Add workspace to user's list if not already there
            if (!userWorkspaces[workspaceFromUrl]) {
                const emoji = getWorkspaceEmoji('Workspace');
                userWorkspaces[workspaceFromUrl] = {
                    id: workspaceFromUrl,
                    name: `${emoji} Workspace`,
                    type: 'workspace',
                    owner: storage.userId,
                    joined: new Date().toISOString()
                };
                saveWorkspaces();
                renderWorkspaceDropdown();
            }
        }
        
        // Wait for Firebase to be properly initialized
        function waitForFirebase() {
            if (window.database && window.firebaseGet && window.firebaseSet && window.firebaseUpdate) {
                console.log('ğŸ”¥ Firebase fully ready, initializing authentication...');
                initializePasswordProtection();
            } else {
                console.log('â³ Waiting for Firebase initialization...');
                setTimeout(waitForFirebase, 500);
            }
        }
        
        // Start checking for Firebase readiness
        setTimeout(waitForFirebase, 100);
    </script>
</body>
</html>
